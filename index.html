<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pathfinder</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 9 9'><rect width='9' height='9' fill='%23f8fafc'/><g stroke='%2394a3b8' stroke-width='0.05'><line x1='0' y1='0' x2='9' y2='0'/><line x1='0' y1='2' x2='9' y2='2'/><line x1='0' y1='4' x2='9' y2='4'/><line x1='0' y1='6' x2='9' y2='6'/><line x1='0' y1='8' x2='9' y2='8'/><line x1='2' y1='0' x2='2' y2='9'/><line x1='4' y1='0' x2='4' y2='9'/><line x1='6' y1='0' x2='6' y2='9'/><line x1='8' y1='0' x2='8' y2='9'/></g><path d='M2.5 5H6.5V2H3.5V7' fill='none' stroke='%233b82f6' stroke-width='0.9' stroke-linecap='round' stroke-linejoin='round'/><circle cx='2.5' cy='5' r='0.525' fill='%233b82f6'/><circle cx='3.5' cy='7' r='0.525' fill='%23ef4444'/></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital@0;1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        :root { font-size: var(--app-scale, min(2vh, 3.5vw)); --ui-gap: clamp(0.65rem, 1.8vw, 1rem); --ui-gap-tight: clamp(0.35rem, 1.1vw, 0.6rem); --ui-pad: clamp(0.65rem, 1.6vw, 1rem); --ui-radius: clamp(0.5rem, 1.2vw, 0.9rem); --ui-panel-pad: clamp(0.75rem, 2vw, 1.25rem); --tile-size: clamp(2.2rem, 4.6vw, 3rem); --tap-min: 44px; --theme-gate: #3b82f6; --theme-goal: #ef4444; --theme-block: #cbd5e1; --theme-block-dot: #94a3b8; --theme-pin: #64748b; --theme-portal: #d946ef; --theme-filter: #000000; --theme-cross: #000000; --theme-modal-bg: rgba(248,250,252,0.95); --theme-modal-panel: #ffffff; --theme-modal-border: #cbd5e1; --theme-modal-text: #334155; --theme-modal-muted: #64748b; --theme-modal-accent: #0f172a; --theme-win-bg: #ffffff; --theme-win-border: #3b82f6; --theme-win-text: #64748b; --theme-win-accent: #1e3a8a; --theme-alert-bg: #1e40af; --theme-alert-stroke: #93c5fd; --theme-alert-text: #ffffff; --theme-logo-bg: #ffffff; --theme-logo-grid: #94a3b8; --theme-logo-path: #3b82f6; --theme-logo-gate: #3b82f6; --theme-logo-goal: #ef4444; --theme-burst: #fde047; --theme-check: #1e293b; --theme-leave-bg: #dc2626; --theme-leave-hover: #b91c1c; --theme-leave-text: #ffffff; --theme-leave-border: #b91c1c; --theme-mega-output-bg: #0f172a; --theme-mega-output-text: #f0abfc; --theme-mega-output-border: #334155; --theme-mega-primary-bg: #a21caf; --theme-mega-primary-text: #ffffff; --theme-mega-primary-border: #d946ef; --theme-mega-secondary-bg: #86198f; --theme-mega-secondary-text: #ffffff; --theme-mega-secondary-border: #d946ef; --theme-mega-gemini-bg: #4338ca; --theme-mega-gemini-text: #ffffff; --theme-mega-gemini-border: #6366f1; --theme-mega-copy-bg: #ffffff; --theme-mega-copy-text: #334155; --theme-mega-copy-border: #cbd5e1; --theme-mega-desc-text: #64748b; }
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; user-select: none; -webkit-user-select: none; transition: background-color 0.3s ease; }
        canvas { cursor: crosshair; width: 100%; height: auto; aspect-ratio: 1/1; display: block; touch-action: none; background-color: white; }
        canvas:focus { outline: none; }
        .modal { background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); }
        .modal-content { transition: all 0.3s ease; }
        #winSubMessage { font-family: 'Caveat', cursive; }
        button:active:not(:disabled) { transform: translateY(1px); }
        button:focus-visible { outline: none; box-shadow: none; }
        button:disabled { cursor: not-allowed; opacity: 0.5; filter: grayscale(1); background-color: #94a3b8 !important; }
        .searching-dot { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        textarea { font-family: monospace; font-size: 0.7rem; line-height: 1.2; resize: none; transition: all 0.2s ease; }
        .serif-desc { font-family: 'Merriweather', serif; font-style: italic; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .hand-drawn { font-family: 'Permanent Marker', cursive; text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite; }
        @keyframes shake { 10%, 90% { transform: translate3d(-4px, 0, 0) rotate(-1deg); } 20%, 80% { transform: translate3d(6px, 0, 0) rotate(2deg); } 30%, 50%, 70% { transform: translate3d(-8px, 0, 0) rotate(-2deg); } 40%, 60% { transform: translate3d(8px, 0, 0) rotate(1deg); } }
        @keyframes spin-grow-fade { 0% { transform: scale(1) rotate(0deg); opacity: 1; } 100% { transform: scale(3) rotate(360deg); opacity: 0; } }
        .animate-spin-grow-fade { animation: spin-grow-fade 1s forwards cubic-bezier(0.4, 0, 0.2, 1); }
        .app-layout { max-width: 65vh; }
        .panel { border-radius: var(--ui-radius); border: 1px solid var(--theme-modal-border); background: var(--theme-modal-panel); }
        .panel-pad { padding: var(--ui-panel-pad); }
        .stack { display: flex; flex-direction: column; gap: var(--ui-gap); }
        .stack-tight { display: flex; flex-direction: column; gap: var(--ui-gap-tight); }
        .row { display: flex; align-items: center; gap: var(--ui-gap); }
        .row-tight { display: flex; align-items: center; gap: var(--ui-gap-tight); }

        #headerLeft { flex: 0 0 clamp(3.9rem, 9.5vw, 4.1rem); width: clamp(3.9rem, 9.5vw, 4.1rem); }
        #headerMiddle { min-width: 0; flex: 1 1 32%; flex-basis: clamp(8.25rem, 32%, 11rem); max-width: 13rem; overflow: hidden; }
        #headerRight { min-width: 0; flex: 1 1 44%; flex-basis: clamp(9.5rem, 44%, 16rem); display: flex; align-items: center; justify-content: center; padding-inline: var(--ui-pad); }
        #headerMiddleContent { --header-middle-col-pad: calc(var(--ui-gap-tight) * 0.9); width: 100%; display: grid; grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr); justify-content: stretch; align-items: center; }
        .header-middle-col { min-width: 0; padding: 0 var(--header-middle-col-pad); display: flex; align-items: center; }
        #headerMiddleColLeft { justify-content: flex-end; }
        #headerMiddleColCenter { justify-content: center; }
        #headerMiddleColRight { justify-content: flex-start; }
        #playMetrics, #editorMetrics { width: 100%; min-width: 0; max-width: clamp(13.5rem, 33vw, 18.5rem); margin-inline: auto; justify-content: center; align-items: center; }
        #playMetrics { gap: clamp(1rem, 2.4vw, 1.5rem); }
        #editorMetrics { gap: clamp(0.85rem, 2.1vw, 1.35rem); }
        @media (orientation: portrait) {
            #headerRight { padding-inline: clamp(0.4rem, 1.6vw, 0.7rem); }
            #playMetrics { gap: clamp(0.7rem, 2.1vw, 1rem); max-width: clamp(12.8rem, 91%, 16.5rem); }
            #editorMetrics { gap: clamp(0.55rem, 1.8vw, 0.85rem); max-width: clamp(12.6rem, 90%, 16rem); }
        }
        @media (orientation: landscape) {
            #headerRight { padding-inline: clamp(0.55rem, 1.5vw, 1rem); }
            #playMetrics { gap: clamp(1.05rem, 2.1vw, 1.5rem); }
            #editorMetrics { gap: clamp(0.95rem, 1.8vw, 1.3rem); }
        }
        .app-layout.forced-landscape #headerRight { padding-inline: clamp(0.55rem, 1.5vw, 1rem); }
        .app-layout.forced-landscape #playMetrics { gap: clamp(1.05rem, 2.1vw, 1.5rem); }
        .app-layout.forced-landscape #editorMetrics { gap: clamp(0.95rem, 1.8vw, 1.3rem); }
        #levelInfoWrap { min-width: 0; display: flex; flex-direction: column; align-items: center; }
        #levelNavigator { display: flex; flex-direction: column; gap: calc(var(--ui-gap-tight) * 0.55); align-items: center; }

        @media (orientation: landscape) and (max-width: 899px) {
            #headerMiddle { flex-basis: clamp(7.5rem, 30%, 10rem); }
            #headerRight { flex-basis: clamp(8.75rem, 40%, 14rem); padding-inline: clamp(0.25rem, 1vw, 0.5rem); }
        }

        @media (orientation: landscape) and (min-width: 900px) {
            #headerMiddle { flex-basis: clamp(11rem, 24vw, 13rem); }
            #headerRight { flex-basis: clamp(14.5rem, 34vw, 20rem); }
            .app-layout { max-width: min(98vw, 180vh); display: flex; flex-direction: row-reverse; align-items: flex-start; gap: calc(var(--ui-gap) * 1.6); }
            .layout-left-pane { width: clamp(21rem, 34vw, 30rem); max-height: 96vh; overflow: hidden; padding-right: var(--ui-gap-tight); display: flex; flex-direction: column; gap: var(--ui-gap-tight); }
            .layout-right-pane { width: min(58vh, 52vw); flex-shrink: 0; }
            #gameButtonGrid:not(.hidden), #editorButtonGrid:not(.hidden) { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: var(--ui-gap-tight); }
            #solutionOutput { flex: 0 1 14rem; max-width: 14rem; }
            .landscape-editor-tools #editorPalette { --palette-cell-size: clamp(2.55rem, 4.1vw, 3.05rem); --palette-grid-gap: clamp(0.28rem, 0.7vw, 0.42rem); }
            .landscape-editor-tools .palette-grid { grid-template-columns: repeat(4, var(--palette-cell-size)); }
        }
        .app-layout.forced-landscape { max-width: min(98vw, 180vh); display: flex; flex-direction: row-reverse; align-items: flex-start; gap: calc(var(--ui-gap) * 1.6); }
        .app-layout.forced-landscape .layout-left-pane { width: clamp(21rem, 34vw, 30rem); max-height: 96vh; overflow: hidden; padding-right: var(--ui-gap-tight); display: flex; flex-direction: column; gap: var(--ui-gap-tight); }
        .app-layout.forced-landscape .layout-right-pane { width: min(58vh, 52vw); flex-shrink: 0; }
        .app-layout.forced-landscape #gameButtonGrid:not(.hidden), .app-layout.forced-landscape #editorButtonGrid:not(.hidden) { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: var(--ui-gap-tight); }
        .app-layout.forced-landscape #solutionOutput { flex: 0 1 14rem; max-width: 14rem; }
        .app-layout.forced-landscape .landscape-editor-tools #editorPalette { --palette-cell-size: clamp(2.55rem, 4.1vw, 3.05rem); --palette-grid-gap: clamp(0.28rem, 0.7vw, 0.42rem); }
        .app-layout.forced-landscape .landscape-editor-tools .palette-grid { grid-template-columns: repeat(4, var(--palette-cell-size)); }
        .landscape-editor-tools { width: 100%; }
        .landscape-editor-tools .palette-grid { flex-grow: 0; margin-left: 0; gap: var(--palette-grid-gap, var(--ui-gap-tight)); }
        .landscape-editor-tools .palette-grid .palette-item { width: var(--palette-cell-size); height: var(--palette-cell-size); }
        .landscape-editor-tools #editUndoGridBtn { width: var(--palette-cell-size) !important; height: calc((2 * var(--palette-cell-size)) + (1 * var(--palette-grid-gap, var(--ui-gap-tight)))) !important; }
        .landscape-editor-tools #editorPaletteLayout { display: grid; grid-template-columns: auto 1fr; grid-template-areas: "line palette"; gap: var(--ui-gap); align-items: stretch; }
        .landscape-editor-tools #editorLineGridPanel { grid-area: line; border-top: 0; border-right: 1px solid #cbd5e1; padding: 0 calc(var(--ui-gap) * 0.9) 0 0; justify-content: flex-start; align-items: stretch; flex-direction: column; }
        .landscape-editor-tools #editorItemPalettePanel { grid-area: palette; }
        .landscape-editor-tools #lineGridTools { display: flex; flex-direction: column; gap: var(--ui-gap-tight); align-items: stretch; width: 7rem; }
        .landscape-editor-tools #lineToolRow, .landscape-editor-tools #lineSetRow, .landscape-editor-tools #gridRotateMirrorRow, .landscape-editor-tools #gridSizeButtonsRow { justify-content: center; }
        .landscape-editor-tools #lineSetRow #editCopyMetrics { width: 100%; min-width: 0; }
        .landscape-editor-tools #gridControlArea { flex-direction: column; gap: var(--ui-gap-tight); align-items: stretch; max-width: none; flex-grow: 0; padding: var(--ui-gap-tight); margin-top: 0.15rem; }
        .landscape-editor-tools #gridLabelRow { justify-content: center; padding: 0; }
        .landscape-editor-tools #gridSizeLabel { margin-right: 0; }
        .landscape-editor-tools #gridSizeButtonsRow { display: flex; gap: var(--ui-gap-tight); padding: 0; }
        .landscape-editor-tools #gridSizeButtonsRow #gridSizePlusBtn { margin-left: 0; }
        .landscape-editor-tools #gridRotateMirrorRow { padding-right: 0; }

        .screen-modal { position: absolute; inset: 0; z-index: 30; background: var(--theme-modal-bg); backdrop-filter: blur(12px); padding: var(--ui-pad); }
        .screen-modal-top { z-index: 35; }
        .screen-modal-panel { width: 100%; height: 100%; border-radius: var(--ui-radius); padding: var(--ui-panel-pad); }
        #editorPalette { --palette-cell-size: clamp(2.35rem, 5vw, 2.95rem); }
        #editorItemPalettePanel { display: grid; grid-template-columns: minmax(0, 1fr) var(--palette-cell-size); }
        .palette-grid { display: grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: var(--ui-gap-tight); width: 100%; margin: 0; }
        .palette-item { width: var(--palette-cell-size); height: var(--palette-cell-size); border-radius: var(--ui-radius); display: flex; align-items: center; justify-content: center; cursor: pointer; border: 2px solid #cbd5e1; transition: transform 0.1s, border-color 0.2s, background-color 0.2s; touch-action: none; }
        .palette-grid .palette-item { width: 100%; height: auto; aspect-ratio: 1 / 1; }
        .palette-item svg { width: 65%; height: 65%; }
        .palette-item.selected { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .palette-item:active { transform: scale(0.95); }
        #editUndoGridBtn { width: var(--palette-cell-size) !important; height: calc((2 * var(--palette-cell-size)) + (1 * var(--ui-gap-tight))) !important; }
        .landscape-editor-tools #editorItemPalettePanel { display: flex; }
        .landscape-editor-tools .palette-grid { width: max-content; grid-template-columns: repeat(4, var(--palette-cell-size)); }
        .landscape-editor-tools .palette-grid .palette-item { width: var(--palette-cell-size); height: var(--palette-cell-size); aspect-ratio: auto; }

        .editor-input { background: rgba(0,0,0,0.15); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 0.5rem; width: 4rem; text-align: center; font-weight: 800; font-size: 1.5rem; line-height: 1; padding: 0.25rem 0; outline: none; transition: border-color 0.2s; }
        .editor-input:focus { border-color: white; }

        #dragGhost { position: fixed; pointer-events: none; z-index: 1000; opacity: 0.9; transform: translate(-50%, -50%); filter: drop-shadow(0 8px 12px rgba(0,0,0,0.4)); display: none; }
        #dragGhost svg { width: 100%; height: 100%; }
        #alertOverlay { pointer-events: none; transition: opacity 0.2s ease; }
    </style>
</head>
<body class="bg-slate-100 text-gray-900 flex flex-col items-center justify-start min-h-[100dvh] w-full overflow-y-auto overflow-x-hidden p-[var(--ui-pad)]">
<svg style="display:none;" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <g id="def-gate"><g transform="rotate(-45 50 50)" fill="none" stroke="currentColor" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"><path d="M25 30 L50 55 L25 80" /><path d="M55 30 L80 55 L55 80" /></g></g>
        <g id="def-goal"><circle cx="50" cy="50" r="32" fill="none" stroke="currentColor" stroke-width="10" /><circle cx="50" cy="50" r="14" fill="currentColor" /></g>
        <g id="def-falsegoal"><circle cx="50" cy="60" r="25" fill="#334155"/><path d="M 50 35 Q 60 20 75 15" fill="none" stroke="#94a3b8" stroke-width="4"/><circle cx="75" cy="15" r="5" fill="#ef4444"/><circle cx="75" cy="15" r="2.5" fill="#fde047"/><path d="M 45 35 L 55 35 L 55 45 L 45 45 Z" fill="#64748b"/></g>
        <g id="def-block"><rect x="5" y="5" width="90" height="90" rx="20" fill="currentColor" /><g fill="var(--theme-block-dot)"><circle cx="25" cy="25" r="5" /><circle cx="50" cy="25" r="5" /><circle cx="75" cy="25" r="5" /><circle cx="25" cy="50" r="5" /><circle cx="50" cy="50" r="5" /><circle cx="75" cy="50" r="5" /><circle cx="25" cy="75" r="5" /><circle cx="50" cy="75" r="5" /><circle cx="75" cy="75" r="5" /></g></g>
        <g id="def-mustcross"><g stroke="currentColor" stroke-width="8" opacity="0.4" fill="none"><path d="M15 35 L35 35 L35 15" /><path d="M85 35 L65 35 L65 15" /><path d="M15 65 L35 65 L35 85" /><path d="M85 65 L65 65 L65 85" /></g></g>
        <g id="def-goose"><path d="M30 0 L70 0 L100 30 L100 70 L70 100 L30 100 L0 70 L0 30" fill="#000" /><path d="M25 60 Q25 45 45 45 L65 45 Q75 45 75 55 Q75 65 65 65 L40 65 Q25 65 25 60" fill="#fff" /><path d="M25 55 L15 45 L30 55 Z" fill="#fff" /><path d="M60 45 L60 25 Q60 18 68 18 Q75 18 75 25 L75 35 L68 35 L68 35 L68 45 Z" fill="#fff" /><circle cx="70" cy="23" r="2" fill="#000" /><path d="M75 29 L88 32 L75 35 Z" fill="#f97316" /><path d="M45 65 L40 78 L52 78 Z M58 65 L53 78 L65 78 Z" fill="#f97316" /></g>
        <g id="def-portal"><circle cx="50" cy="50" r="30" fill="none" stroke="currentColor" stroke-width="10" stroke-dasharray="10, 8" /><circle cx="50" cy="50" r="20" fill="currentColor" opacity="0.15" /></g>
        <g id="def-mustpass"><g transform="translate(50, 75) rotate(-15) scale(2.4)"><path d="M-1 0 L1 0 L1.5 -12 L-1.5 -12 Z" fill="#94a3b8" /><circle cx="0" cy="-18" r="7" fill="currentColor" /></g></g>
        <g id="def-filterH"><rect x="10" y="25" width="80" height="15" fill="currentColor" opacity="0.3" /><rect x="10" y="60" width="80" height="15" fill="currentColor" opacity="0.3" /></g>
        <g id="def-filterV"><rect x="25" y="10" width="15" height="80" fill="currentColor" opacity="0.3" /><rect x="60" y="10" width="15" height="80" fill="currentColor" opacity="0.3" /></g>
        <g id="def-flipH"><use href="#def-filterH"/><text x="50" y="55" font-size="45" font-weight="900" font-family="sans-serif" text-anchor="middle" fill="currentColor">↺</text></g>
        <g id="def-flipV"><use href="#def-filterV"/><text x="50" y="55" font-size="45" font-weight="900" font-family="sans-serif" text-anchor="middle" fill="currentColor">↺</text></g>
        <g id="def-close"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></g>
        <g id="def-completion">
            <path d="M88.558,49.96c0-0.885-0.435-1.663-1.097-2.151l0.014-0.024l-9.324-5.383l5.367-9.296l-0.018-0.011c0.328-0.752,0.315-1.643-0.127-2.408c-0.443-0.766-1.208-1.223-2.025-1.314v-0.026H70.58V18.61h-0.022c-0.092-0.816-0.549-1.58-1.314-2.022c-0.767-0.443-1.658-0.456-2.412-0.125l-0.013-0.023l-9.481,5.474l-5.25-9.094l-0.019,0.011c-0.488-0.66-1.265-1.094-2.149-1.094c-0.885,0-1.664,0.435-2.151,1.097l-0.024-0.014l-5.337,9.244l-9.19-5.306l-0.011,0.019c-0.753-0.328-1.643-0.315-2.408,0.127c-0.767,0.442-1.223,1.208-1.315,2.025h-0.027v10.674H18.845v0.021c-0.816,0.092-1.58,0.549-2.022,1.314c-0.442,0.766-0.455,1.657-0.126,2.41l-0.023,0.014l5.246,9.087l-9.394,5.424l0.011,0.019c-0.66,0.488-1.094,1.265-1.094,2.149c0,0.885,0.435,1.664,1.097,2.151l-0.014,0.024l9.324,5.383l-5.367,9.296l0.019,0.011c-0.328,0.753-0.315,1.643,0.127,2.408c0.443,0.766,1.208,1.223,2.025,1.314v0.027H29.42V81.39h0.022c0.092,0.816,0.549,1.58,1.314,2.022c0.767,0.443,1.658,0.455,2.412,0.125l0.013,0.023l9.481-5.474l5.25,9.094l0.019-0.011c0.488,0.66,1.265,1.094,2.149,1.094c0.885,0,1.664-0.435,2.151-1.096l0.023,0.013l5.337-9.244l9.191,5.306l0.011-0.019c0.753,0.328,1.643,0.315,2.408-0.127c0.767-0.442,1.223-1.208,1.315-2.025h0.027V70.398h10.613v-0.021c0.816-0.092,1.58-0.549,2.022-1.314c0.442-0.766,0.455-1.658,0.126-2.411l0.023-0.013l-5.246-9.087l9.394-5.424l-0.011-0.019C88.124,51.622,88.558,50.844,88.558,49.96z" fill="var(--theme-burst)"/>
            <path d="M35 48 L45 58 L65 38" fill="none" stroke="var(--theme-check)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
        </g>
    </defs>
</svg>

<div id="dragGhost" class="flex items-center justify-center bg-white rounded-lg border-2 border-sky-500 border-dashed"></div>

<div id="loadingOverlay" class="fixed inset-0 z-[100] bg-slate-900/60 backdrop-blur-sm flex items-center justify-center p-8 transition-opacity duration-500">
    <div class="w-full max-w-xs bg-slate-900 p-6 rounded-2xl border border-slate-700 shadow-2xl">
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-white font-black text-xl tracking-tighter uppercase leading-none">Pathfinder</h1>
                <p id="loadStatusLabel" class="text-sky-400 text-[0.6rem] font-bold uppercase tracking-widest mt-1">Initing Systems...</p>
            </div>
            <p id="loadPercent" class="text-white font-mono text-sm">0%</p>
        </div>
        <div class="w-full h-1.5 bg-slate-800 rounded-full overflow-hidden"><div id="loadProgressBar" class="h-full bg-sky-500 w-0 transition-all duration-200"></div></div>
        <p id="loadErrorMessage" class="mt-4 text-sky-300 text-[0.6rem] font-medium hidden text-center italic leading-relaxed">Remote resource unavailable. Engaging local fallback array.</p>
    </div>
</div>

<div id="appLayout" class="app-layout mx-auto stack h-full w-full justify-start relative gap-[var(--ui-gap)] pb-[var(--ui-gap)]">
    <div id="gamePane" class="layout-right-pane">
    <div class="bg-white rounded-2xl overflow-hidden shadow-2xl border border-slate-300 flex flex-col shrink-0">
        <div id="headerBar" class="flex h-20 border-b border-slate-200">
            <div id="headerLeft" class="flex-shrink-0 flex items-center justify-center border-r border-slate-200 transition-colors duration-300 bg-[var(--theme-logo-bg)] aspect-square">
                <svg viewBox="0 0 9 9" class="h-full w-auto p-[var(--ui-pad)]">
                    <rect width="9" height="9" fill="var(--theme-logo-bg)"/>
                    <g stroke="var(--theme-logo-grid)" stroke-width="0.05">
                        <line x1="0" y1="0" x2="9" y2="0"/><line x1="0" y1="2" x2="9" y2="2"/><line x1="0" y1="4" x2="9" y2="4"/><line x1="0" y1="6" x2="9" y2="6"/><line x1="0" y1="8" x2="9" y2="8"/>
                        <line x1="0" y1="0" x2="0" y2="9"/><line x1="2" y1="0" x2="2" y2="9"/><line x1="4" y1="0" x2="4" y2="9"/><line x1="6" y1="0" x2="6" y2="9"/><line x1="8" y1="0" x2="8" y2="9"/>
                    </g>
                    <path d="M2.5 5H6.5V2H3.5V7" fill="none" stroke="var(--theme-logo-path)" stroke-width="0.9" stroke-linecap="round" stroke-linejoin="round"/>
                    <circle cx="2.5" cy="5" r="0.525" fill="var(--theme-logo-gate)"/>
                    <circle cx="3.5" cy="7" r="0.525" fill="var(--theme-logo-goal)"/>
                </svg>
            </div>
            <div id="headerMiddle" class="flex-shrink-0 bg-red-700 flex items-center transition-colors duration-300 relative border-r border-slate-200/20">
                <div id="headerMiddleContent">
                    <div id="headerMiddleColLeft" class="header-middle-col">
                        <svg id="completionBurst" viewBox="0 0 100 100" class="w-8 h-8 hidden shrink-0"><use href="#def-completion"/></svg>
                    </div>
                    <div id="headerMiddleColCenter" class="header-middle-col">
                        <div id="levelInfoWrap" class="min-w-0">
                            <span id="levelLabelText" class="text-[0.6rem] font-black text-red-100/60 uppercase tracking-widest leading-none mb-1">Level</span>
                            <p id="levelTitle" class="text-white font-black text-4xl uppercase cursor-pointer select-none tracking-tighter leading-none">1</p>
                        </div>
                    </div>
                    <div id="headerMiddleColRight" class="header-middle-col">
                        <div id="levelNavigator">
                            <button id="prevLevelBtn" class="bg-white/20 text-white w-6 h-6 rounded flex items-center justify-center hover:bg-white/30 transition shadow-sm text-[0.6rem]">◄</button>
                            <button id="nextLevelBtn" class="bg-white/20 text-white w-6 h-6 rounded flex items-center justify-center hover:bg-white/30 transition shadow-sm text-[0.6rem]">►</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="headerRight" class="bg-blue-700 flex items-center justify-center transition-colors duration-300">
                <div id="playMetrics" class="flex gap-6 items-center justify-center w-full">
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Length</p><p id="lengthInfo" class="text-2xl font-black text-white tabular-nums leading-none">0/0</p></div>
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Crosses</p><p id="intersectionInfo" class="text-2xl font-black text-white tabular-nums leading-none">0/0</p></div>
                </div>
                <div id="editorMetrics" class="hidden flex gap-6 items-center justify-center w-full">
                     <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Length</p><input id="editReqLen" type="number" class="editor-input" value="0"></div>
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Crosses</p><input id="editReqInt" type="number" class="editor-input" value="0"></div>
                </div>
            </div>
        </div>

        <div id="canvasContainer" class="relative overflow-hidden bg-white">
            <canvas id="gameCanvas" width="800" height="800"></canvas>
            <div id="gooseJumpScare" class="absolute inset-0 z-40 hidden flex-col items-center justify-center bg-black/40 backdrop-blur-sm overflow-hidden pointer-events-none">
                <div class="relative w-full h-full flex flex-col items-center justify-center">
                    <div class="absolute top-[15%] z-50 transform rotate-[-25deg] -translate-x-4"><p class="hand-drawn text-white text-4xl mb-2">YOU RAN INTO</p></div>
                    <div id="scaryGoose" class="w-[75%] aspect-square shake z-40 drop-shadow-2xl"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-goose"/></svg></div>
                    <div class="absolute bottom-[15%] z-50 transform -rotate-[-25deg] translate-x-4"><p class="hand-drawn text-white text-5xl font-bold italic">A GOOSE</p></div>
                </div>
            </div>
            <div id="bombJumpScare" class="absolute inset-0 z-40 hidden flex-col items-center justify-center bg-black/60 backdrop-blur-md overflow-hidden pointer-events-none">
                <div class="relative w-full h-full flex flex-col items-center justify-center">
                    <div class="absolute top-[15%] z-50 transform rotate-[15deg] -translate-x-2"><p class="hand-drawn text-yellow-400 text-5xl mb-2 drop-shadow-lg">Bamboozled!</p></div>
                    <div id="scaryBomb" class="w-[65%] aspect-square shake z-40 drop-shadow-2xl"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-falsegoal"/></svg></div>
                    <div class="absolute bottom-[15%] z-50 transform -rotate-[10deg] translate-x-2"><p class="hand-drawn text-orange-500 text-6xl font-bold drop-shadow-xl">BOOBY TRAP</p></div>
                </div>
            </div>
            <div id="searchIndicator" class="absolute inset-0 flex items-center justify-center bg-slate-900/90 backdrop-blur-sm hidden z-20">
                <div class="flex flex-col items-center gap-4 w-full px-8">
                    <div id="megaStatus" class="hidden text-fuchsia-300 font-bold text-sm text-center animate-pulse whitespace-pre-line mb-2 tracking-widest border-b border-fuchsia-500/30 pb-2 w-full"></div>
                    <div class="flex flex-col items-center gap-3">
                        <span id="searchLabel" class="text-sm font-black uppercase tracking-widest text-center text-sky-300">Finding Solutions...</span>
                        <div class="flex gap-1"><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0s"></div><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0.2s"></div><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0.4s"></div></div>
                    </div>
                    <div id="solverTimer" class="text-5xl font-mono text-white font-bold tracking-tighter tabular-nums">0.0s</div>
                    <button id="solverCloseBtn" class="absolute top-4 right-4 text-white/40 hover:text-white hover:scale-110 transition p-2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
            </div>
            <div id="guideModal" class="screen-modal hidden flex flex-col modal-content">
                <div class="flex justify-between items-start panel-pad shrink-0">
                    <div class="flex-grow text-center pr-2"><p class="serif-desc text-[1.1rem] font-bold leading-tight text-[var(--theme-modal-accent)]">Please draw a line from a Gate to a Goal that's precisely as long and as twisty as specified.</p></div>
                    <button id="closeGuideX" class="transition p-1 rounded-full shrink-0 text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
                <div class="flex-grow overflow-y-auto px-[var(--ui-panel-pad)] pb-[var(--ui-gap-tight)]">
                    <div class="flex flex-wrap justify-center gap-4 mb-6">
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-gate)"><use href="#def-gate"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Gate</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Start point.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-goal)"><use href="#def-goal"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Goal</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Destination.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-block)"><use href="#def-block"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Block</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Obstacle.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full drop-shadow-sm" style="color: var(--theme-pin)"><use href="#def-mustpass"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Req.</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Visit cell.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-filter)"><use href="#def-filterH"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Filter</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">One-way street.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-portal)"><use href="#def-portal"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Portal</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Teleport.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-cross)"><use href="#def-mustcross"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Cross</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Visit cell twice.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0" id="legendGooseContainer"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-goose"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Goose</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Danger!</p></div></div>
                    </div>
                    <div class="pb-4 border-t border-[var(--theme-modal-border)] pt-3"><p id="devToggleBtn" class="text-center text-[0.8rem] uppercase font-black text-[var(--theme-modal-muted)] tracking-wider cursor-pointer select-none hover:text-[var(--theme-modal-accent)] transition">PATHFINDER GAME BY IAN WALLACE, GEMINI AND CHATGPT. &copy;2025</p></div>
                </div>
            </div>
            <div id="themeModal" class="screen-modal screen-modal-top hidden flex flex-col h-full min-h-0 modal-content">
                <div id="themeModalPanel" class="screen-modal-panel panel w-full h-full min-h-0 flex flex-col modal-content transition-all duration-300 overflow-hidden">
                    <div id="themeSelectView" class="flex flex-col w-full h-full min-h-0">
                        <div class="flex justify-between items-center mb-4 shrink-0 px-2">
                            <h2 class="text-lg font-black text-[var(--theme-modal-accent)] uppercase tracking-widest">Select Theme</h2>
                            <button id="closeThemeModalBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-1 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                        </div>
                        <div id="themeGrid" class="flex-grow overflow-y-auto grid grid-cols-3 gap-4 px-2 pb-4 content-start min-h-0"></div>
                        <div id="themeSelectFooter" class="pt-4 border-t border-[var(--theme-modal-border)] flex justify-center gap-2 shrink-0">
                            <button id="openThemeEditorBtn" class="hidden text-[0.75rem] font-black uppercase tracking-widest text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] transition bg-black/5 px-4 py-2 rounded-lg hover:bg-black/10">Modify Themes</button>
                            <button id="dismissThemeModalBtn" class="text-[0.75rem] font-black uppercase tracking-widest text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] transition bg-black/5 px-4 py-2 rounded-lg hover:bg-black/10">Dismiss</button>
                        </div>
                    </div>
                    <div id="themeEditView" class="hidden flex-col w-full h-full min-h-0">
                        <div class="flex justify-between items-center mb-4 shrink-0 px-2">
                            <h2 class="text-lg font-black text-[var(--theme-modal-accent)] uppercase tracking-widest">Modify Themes</h2>
                            <button id="backToThemeSelectBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-1 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                            </button>
                        </div>
                        <div id="themeEditList" class="flex-grow overflow-y-auto flex flex-col gap-6 px-1 sm:px-2 pb-4 min-h-0"></div>
                        <div class="pt-4 border-t border-[var(--theme-modal-border)] flex justify-end shrink-0">
                            <button id="doneThemeEditBtn" class="bg-[var(--theme-modal-accent)] text-[var(--theme-modal-panel)] px-6 py-2 rounded-lg font-black tracking-widest shadow-md hover:brightness-110 transition text-xs uppercase">Done</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="megaModal" class="screen-modal screen-modal-top hidden flex flex-col h-full min-h-0 modal-content">
                <div id="megaModalContent" class="screen-modal-panel panel w-full h-full min-h-0 flex flex-col overflow-hidden modal-content">
                    <div class="flex justify-between items-center mb-3 shrink-0">
                        <div><h2 id="megaModalTitle" class="text-2xl font-black uppercase tracking-tighter text-[var(--theme-modal-accent)]">Mega Solver Results</h2><p id="megaModalSub" class="text-xs font-bold uppercase tracking-widest text-[var(--theme-modal-muted)]">Bulk Solution Generation</p></div>
                        <button id="closeMegaModalBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-2 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                    </div>
                    <div class="flex-grow min-h-0 overflow-y-auto pr-1">
                        <div id="megaSummary" class="text-xs font-bold uppercase tracking-widest text-[var(--theme-mega-desc-text)] mb-2">No run yet.</div>
                        <div class="flex gap-2 items-stretch w-full mb-3">
                            <textarea id="megaOutput" readonly class="flex-grow min-h-[8rem] h-[11rem] p-3 rounded-xl border text-[0.6rem] font-mono leading-tight resize-none" placeholder="Mega solver results will appear here..."></textarea>
                            <button id="copyMegaDataBtn" class="w-24 shrink-0 rounded-lg border font-black text-[0.55rem] transition uppercase px-1 leading-none">Copy</button>
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                            <div class="rounded-xl border p-2 border-[var(--theme-mega-primary-border)]/40"><button id="megaRetry30Btn" class="w-full text-left border px-3 py-2 rounded-lg font-black text-[0.68rem] uppercase tracking-wider transition">Quick Retry</button><p class="mt-1 text-[0.62rem] leading-tight text-[var(--theme-mega-desc-text)]">30s per failed level. Same stage order.</p></div>
                            <div class="rounded-xl border p-2 border-[var(--theme-mega-primary-border)]/40"><button id="megaRetry60Btn" class="w-full text-left border px-3 py-2 rounded-lg font-black text-[0.68rem] uppercase tracking-wider transition">Standard Retry</button><p class="mt-1 text-[0.62rem] leading-tight text-[var(--theme-mega-desc-text)]">60s per failed level. Same strategy.</p></div>
                            <div class="rounded-xl border p-2 border-[var(--theme-mega-primary-border)]/40"><button id="megaRetry120Btn" class="w-full text-left border px-3 py-2 rounded-lg font-black text-[0.68rem] uppercase tracking-wider transition">Deep Retry</button><p class="mt-1 text-[0.62rem] leading-tight text-[var(--theme-mega-desc-text)]">120s per failed level for stubborn puzzles.</p></div>
                            <div class="rounded-xl border p-2 border-[var(--theme-mega-secondary-border)]/40"><button id="megaRetryAltBtn" class="w-full text-left border px-3 py-2 rounded-lg font-black text-[0.68rem] uppercase tracking-wider transition">Alternate Order</button><p class="mt-1 text-[0.62rem] leading-tight text-[var(--theme-mega-desc-text)]">60s with a different stage order.</p></div>
                            <div class="sm:col-span-2 rounded-xl border p-2 border-[var(--theme-mega-gemini-border)]/40"><button id="megaGeminiRetryBtn" class="w-full text-left border px-3 py-2 rounded-lg font-black text-[0.68rem] uppercase tracking-wider transition">Ask Gemini + Validate</button><p class="mt-1 text-[0.62rem] leading-tight text-[var(--theme-mega-desc-text)]">Gemini suggests paths only for unresolved levels, then Pathfinder verifies puzzle legality.</p></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="editorHelpModal" class="screen-modal hidden flex flex-col modal-content">
                <div class="flex justify-between items-start p-4 shrink-0">
                     <div class="flex-grow pr-2"><h3 class="serif-desc text-[1.1rem] font-bold leading-tight text-[var(--theme-modal-accent)] text-left w-full">Editor Guide</h3></div>
                    <button id="closeEditorHelpX" class="transition p-1 rounded-full shrink-0 text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
                <div class="flex-grow overflow-y-auto px-4 pb-4 space-y-4 pt-2 text-left">
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Building & Testing</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Pick a tool from the palette to start building! You can tap the grid to place objects or even drag them directly into position. Use the <strong>Pencil</strong> to sketch out paths and see how your level plays. Dragging items off the grid will remove them.</p></section>
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Solving</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Click <strong>Solve Logic</strong> to automatically find valid solutions. It requires target metrics (Length/Crosses) to be properly set beforehand.</p></section>
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Exporting Level Data</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Once you've built something great, click <strong>Generate</strong> to export your level data. If you've drawn a valid solution or used the solver, it will automatically include that as a helpful hint for players! You can also use <strong>Copy Path</strong> to grab the raw coordinate array anytime.</p></section>
                </div>
            </div>
            <div id="winModal" class="screen-modal hidden flex flex-col items-center justify-center modal-content">
                <div id="winModalContent" class="w-full h-full flex flex-col justify-center gap-3">
                    <div id="winCircle" class="bg-[var(--theme-win-bg)] flex-1 flex flex-col items-center justify-center text-center p-6 transition-all duration-300">
                        <h2 class="text-3xl font-black tracking-tighter uppercase leading-none mb-2 text-[var(--theme-win-accent)]">PATH FOUND</h2>
                        <p id="winSubMessage" class="text-4xl mb-4 text-[var(--theme-win-text)]">well done</p>
                        <div class="flex flex-col items-center gap-1 w-full">
                            <button id="nextLevelModalBtn" class="font-black text-2xl uppercase transition leading-none text-[var(--theme-win-accent)] hover:brightness-125">Next Level</button>
                            <span class="text-[0.675rem] font-black uppercase text-[var(--theme-win-text)]">- or -</span>
                            <button id="dismissWinModalBtn" class="font-black text-2xl uppercase transition leading-none text-[var(--theme-win-accent)] hover:brightness-125">Rest Here</button>
                        </div>
                    </div>
                    <div id="winExportArea" class="bg-[var(--theme-modal-panel)] panel-pad w-full hidden">
                        <div class="flex justify-between items-center mb-2"><label class="text-[0.65rem] uppercase font-black tracking-widest text-[var(--theme-modal-accent)]">Winning Path Data</label><button id="copyWinDataBtn" class="text-[0.65rem] bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] px-3 py-1 rounded-full font-black transition active:scale-95 hover:brightness-90">COPY ARRAY</button></div>
                        <textarea id="winSolutionOutput" readonly class="w-full h-20 p-3 rounded-xl border border-slate-700 text-[0.65rem] font-mono leading-relaxed" placeholder="Solution data..."></textarea>
                    </div>
                </div>
            </div>
            <div id="unsavedModal" class="screen-modal hidden flex flex-col items-center justify-center modal-content">
                <div class="panel panel-pad shadow-2xl w-full max-w-sm stack text-center">
                    <h2 class="text-xl font-black uppercase tracking-widest mb-2 text-[var(--theme-modal-accent)]">Unsaved Changes</h2>
                    <p class="mb-6 font-medium text-[var(--theme-modal-text)]">Do you need to export this level?</p>
                    <div class="flex justify-center gap-4">
                        <button id="unsavedStayBtn" class="font-bold uppercase tracking-widest transition px-4 py-2 rounded-lg bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] hover:brightness-95">Stay</button>
                        <button id="unsavedLeaveBtn" class="px-6 py-2 rounded-lg font-black transition uppercase tracking-widest shadow-md border bg-[var(--theme-leave-bg)] text-[var(--theme-leave-text)] border-[var(--theme-leave-border)] hover:bg-[var(--theme-leave-hover)]">Leave</button>
                    </div>
                </div>
            </div>
    </div>

        </div>
    </div>

    <div id="editorPalette" class="hidden w-full panel panel-pad bg-white shadow-xl border-slate-200 shrink-0 transition-all">
        <div id="editorPaletteLayout" class="stack">
            <div id="editorItemPalettePanel" class="row-tight items-stretch">
                <div class="palette-grid flex-grow">
                    <div class="palette-item" data-type="gate" title="Gate"><svg viewBox="0 0 100 100" style="color: var(--theme-gate)"><use href="#def-gate"/></svg></div>
                    <div class="palette-item" data-type="goal" title="Goal"><svg viewBox="0 0 100 100" style="color: var(--theme-goal)"><use href="#def-goal"/></svg></div>
                    <div class="palette-item" data-type="falseGoal" title="Bomb"><svg viewBox="0 0 100 100"><use href="#def-falsegoal"/></svg></div>
                    <div class="palette-item" data-type="block" title="Block"><svg viewBox="0 0 100 100" style="color: var(--theme-block)"><use href="#def-block"/></svg></div>
                    <div class="palette-item" data-type="mustCross" title="Must Cross"><svg viewBox="0 0 100 100" style="color: var(--theme-cross)"><use href="#def-mustcross"/></svg></div>
                    <div class="palette-item" data-type="goose" title="Goose"><svg viewBox="0 0 100 100"><use href="#def-goose"/></svg></div>
                    <div class="palette-item" data-type="portal" title="Portal"><svg viewBox="0 0 100 100" style="color: var(--theme-portal)"><use href="#def-portal"/></svg></div>
                    <div class="palette-item" data-type="mustPass" title="Required"><svg viewBox="0 0 100 100" style="color: var(--theme-pin)"><use href="#def-mustpass"/></svg></div>
                    <div class="palette-item" data-type="filterH" title="H-Filter"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-filterH"/></svg></div>
                    <div class="palette-item" data-type="filterV" title="V-Filter"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-filterV"/></svg></div>
                    <div class="palette-item" data-type="flipH" title="Flip-H"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-flipH"/></svg></div>
                    <div class="palette-item" data-type="flipV" title="Flip-V"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-flipV"/></svg></div>
                </div>
                <div class="w-12 flex-shrink-0 flex items-center justify-center">
                    <div id="editUndoGridBtn" class="palette-item palette-tool" title="Undo Grid Action"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg></div>
                </div>
            </div>
            <div id="editorLineGridPanel" class="flex items-center justify-center pt-3 border-t border-slate-100 gap-1.5">
                <div id="lineGridTools" class="flex gap-1">
                    <div id="lineToolRow" class="flex gap-1">
                    <div id="editPencilBtn" class="palette-item palette-tool !w-10 !h-10" title="Pencil"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg></div>
                    <div id="editEraserBtn" class="palette-item palette-tool !w-10 !h-10" title="Undo Step"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg></div>
                    </div>
                    <div id="lineSetRow" class="flex">
                    <div id="editCopyMetrics" class="bg-red-700 text-white px-4 h-10 flex items-center justify-center rounded-lg text-[0.65rem] font-bold uppercase tracking-wider cursor-pointer hover:brightness-110 active:scale-95 transition-all whitespace-nowrap min-w-[6rem]">Set (0/0)</div>
                    </div>
                </div>
                <div id="gridControlArea" class="flex items-center gap-1.5 p-1 rounded-xl border border-slate-200 bg-slate-50 flex-grow max-w-[200px] justify-center">
                    <div id="gridLabelRow" class="flex items-center px-1.5"><span id="gridSizeLabel" class="text-[0.6rem] font-black uppercase tracking-widest text-slate-400 mr-1.5">GRID:</span></div>
                    <div id="gridSizeButtonsRow" class="flex items-center px-1.5">
                        <button id="gridSizeMinusBtn" class="w-8 h-8 rounded-lg font-black transition flex items-center justify-center border border-slate-200">-</button>
                        <button id="gridSizePlusBtn" class="w-8 h-8 rounded-lg font-black transition flex items-center justify-center border border-slate-200 ml-1">+</button>
                    </div>
                    <div id="gridRotateMirrorRow" class="flex gap-1 pr-1">
                        <button id="gridRotateBtn" class="w-8 h-8 rounded-lg transition flex items-center justify-center border border-slate-200"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path></svg></button>
                        <button id="gridMirrorBtn" class="w-8 h-8 rounded-lg transition flex items-center justify-center border border-slate-200"><svg id="mirrorIconSvg" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(90deg)"><polyline points="8 18 3 12 8 6"></polyline><polyline points="16 6 21 12 16 18"></polyline><line x1="3" y1="12" x2="21" y2="12"></line></svg></button>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <div id="controlsPane" class="layout-left-pane">
    <div id="playControls" class="bg-white p-3 rounded-2xl shadow-xl border border-slate-200 relative">
        <div class="relative">
            <div id="gameButtonGrid" class="flex gap-1.5">
                <div id="hintBtn" class="flex-1 h-10 bg-orange-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 text-[0.65rem] uppercase tracking-wider flex flex-col z-20 overflow-hidden cursor-pointer relative">
                    <div id="hintTopHalf" class="flex-1 w-full items-center justify-center border-b border-white/20 hidden hover:bg-black/10 transition-colors text-[0.65rem] text-center">New Hint</div>
                    <div id="hintBottomHalf" class="flex-1 w-full items-center justify-center flex hover:bg-black/10 transition-colors text-center"><span id="hintMainLabel" class="w-full text-center">Hint</span></div>
                </div>
                <button id="resetBtn" class="flex-1 h-10 bg-red-500 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Reset</button>
                <button id="undoBtn" class="flex-1 h-10 bg-slate-600 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Undo</button>
                <button id="whoaBtn" class="flex-1 h-10 bg-blue-500 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Whoa</button>
                <button id="guideBtn" class="flex-1 h-10 bg-purple-600 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Guide</button>
                <button id="megaSolverBtn" class="hidden flex-1 h-10 bg-fuchsia-600 text-white font-black rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Mega</button>
                <button id="modeToggleBtn" class="flex-1 h-10 bg-slate-900 text-white font-black rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Edit</button>
            </div>
            <div id="editorButtonGrid" class="hidden flex gap-1.5">
                <button id="editResetGrid" class="flex-1 h-10 bg-red-600 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">Clear</button>
                <button id="editNewLevel" class="flex-1 h-10 bg-emerald-600 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">New</button>
                <button id="editMegaSolver" class="flex-1 h-10 bg-fuchsia-600 text-white font-black rounded-lg text-[0.65rem] uppercase tracking-wider">Solve</button>
                <button id="editTrapSpotsBtn" class="flex-1 h-10 bg-orange-500 text-white font-black rounded-lg text-[0.65rem] uppercase tracking-wider">BOMBS?</button>
                <button id="editHelpBtn" class="flex-1 h-10 bg-slate-500 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">Guide</button>
                <button id="editModeToggleBtn" class="flex-1 h-10 bg-slate-900 text-white font-black rounded-lg shadow-md text-[0.65rem] uppercase tracking-wider">Play</button>
            </div>
            <div id="alertOverlay" class="absolute inset-0 z-[60] bg-[var(--theme-alert-bg)] border-2 border-white/20 rounded-lg flex items-center justify-center text-center px-4 shadow-2xl opacity-0 pointer-events-none">
                <p id="message" class="font-black text-[0.9rem] uppercase tracking-tighter architectural-tight leading-tight drop-shadow-lg"></p>
            </div>
        </div>
        <div class="flex flex-col gap-2 hidden mt-3 pt-3 border-t border-slate-100" id="exportArea">
            <div class="flex justify-between items-center px-1"><label id="exportLabel" class="text-[0.6rem] uppercase font-black text-slate-400 tracking-widest">Level Data Export</label></div>
            <div class="flex gap-2 items-stretch w-full">
                <textarea id="solutionOutput" readonly class="flex-grow h-[5rem] p-3 bg-slate-900 text-sky-300 rounded-xl border border-slate-700 text-[0.6rem] font-mono leading-tight" placeholder="Solution data..."></textarea>
                <div id="exportBtnStack" class="flex flex-col gap-1 w-24 shrink-0">
                    <button id="devCopyBtn" class="flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.55rem] hover:bg-slate-300 transition uppercase px-1 leading-none">Copy Path</button>
                    <button id="devGenBtn" class="flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.6rem] hover:bg-slate-300 transition uppercase">Copy Hints</button>
                    <button id="editCopyBtn" class="hidden flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.55rem] transition uppercase px-1 leading-none">Copy Path</button>
                    <button id="editGenBtn" class="hidden flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.6rem] transition uppercase">Generate</button>
                </div>
            </div>
        </div>
    </div>

    <div class="flex w-full items-center justify-end gap-1.5 shrink-0 pt-2 landscape-editor-tools">
        <button id="orientationToggleBtn" class="px-3 bg-slate-300/60 backdrop-blur-md rounded-lg h-10 border border-white/20 shadow-md text-slate-700 font-black uppercase tracking-wider hover:bg-slate-400/60 transition text-[0.65rem] flex items-center justify-center min-w-[5.25rem]">Landscape</button>
        <button id="openThemeModalBtn" class="px-3 bg-slate-300/60 backdrop-blur-md rounded-lg h-10 border border-white/20 shadow-md text-slate-700 font-black uppercase tracking-wider hover:bg-slate-400/60 transition text-[0.65rem] flex items-center justify-center min-w-[4.75rem]">Themes</button>
        <button id="muteBtn" class="bg-white/50 backdrop-blur-md text-slate-500 w-10 h-10 rounded-lg flex items-center justify-center hover:bg-white/80 transition shrink-0 shadow-md border border-white/20">
            <svg id="muteIcon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v1a7 7 0 0 1-14 0v-1"></path><line x1="12" y1="19" x2="12" y2="22"></line><line id="muteSlash" x1="2" y1="2" x2="22" y2="22"></line></svg>
        </button>
    </div>
    </div>
</div>

<script type="module">
    const APP = {};

    // ======================================================
    // A) Core / ConstantsAndUtils
    // Purpose: shared constants and tiny cross-module helpers.
    // Owns:
    // - DOM id helper
    // - mode/status enums
    // - overlay enum constants
    // Public API: $, AXIS/H/V/NONE, DEV, MODES/PLAY/EDITOR, LogicStatus constants, OverlayStatus constants.
    // ======================================================
    APP.Core = (() => {
        const $ = id => document.getElementById(id);
        const AXIS = { NONE: 0, H: 1, V: 2 };
        const { H, V, NONE } = AXIS;
        const DEV = false;
        const MODES = { PLAY: 0, EDITOR: 1 };
        const { PLAY, EDITOR } = MODES;

        const LogicStatus = {
            IDLE: "IDLE",
            DRAGGING: "DRAGGING",
            PORTAL_PAUSE: "PORTAL_PAUSE",
            RESOLVED: "RESOLVED",
            HAZARD_TRIGGERED: "HAZARD_TRIGGERED",
            EDIT_DRAG: "EDIT_DRAG",
            THEME_DRAG: "THEME_DRAG"
        };
        const { IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG } = LogicStatus;

        const OverlayStatus = {
            NONE: "NONE",
            HINT_ANIMATING: "HINT_ANIMATING",
            FALSE_GOAL_ANIMATING: "FALSE_GOAL_ANIMATING",
            GOOSE_OVERLAY: "GOOSE_OVERLAY",
            SOLVER_RUNNING: "SOLVER_RUNNING"
        };
        const { NONE: OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING } = OverlayStatus;

        return { $, AXIS, H, V, NONE, DEV, MODES, PLAY, EDITOR, LogicStatus, IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG, OverlayStatus, OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING };
    })();

    const { $, AXIS, H, V, NONE, DEV, MODES, PLAY, EDITOR, LogicStatus, IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG, OverlayStatus, OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING } = APP.Core;
    if (DEV) window.AXIS = AXIS;

    // Purpose: sole DOM mutation boundary for non-canvas UI.
    // Owns:
    // - cached UI element refs
    // - modal/overlay visibility
    // - shared status/progress copy
    // - button and class/style toggles
    // - solver/theme-editor chrome updates
    // Public API:
    // - initDom, getEl
    // - setStatus, setProgress, flashMessage, reportError
    // - showOverlay, hideOverlay, setOverlayOpacity, applyOverlayState
    // - openModal, closeModal, toggleModal, isModalOpen, setModalContent
    // - setButtonState, setSearchIndicatorVisible, setSolverControlsEnabled, setSolverTimerText
    // - setClassState, clearClass, setInlineStyle, setTextContent, setInputValue, getValue, getChecked, getNumber
    // - setCompletionBurstVisible, showGooseJumpScare, hideGooseJumpScare, showBombDetonation, hideBombDetonation, ThemeEditor
    // APP.UI Public API:
    // - initDom(): cache shared UI DOM refs once at boot.
    // - getEl(key): read cached element by key.
    // - setStatus(text, severity, className): update shared alert/status message copy/styling.
    // - setProgress({ phase, current, total, pct, detail, mode }): update loader/solver progress labels and bars.
    // - showOverlay(key)/hideOverlay(key): shared overlay visibility controls.
    // - openModal(id)/closeModal(id)/toggleModal(id, force): centralized modal visibility.
    // - setModalContent(id, value, mode): safe modal region text/html updates.
    // - setButtonState(id, opts): shared button disabled/active/label state updates.
    // - flashMessage(text, className): shared transient message banner helper.
    // - showMessage(text, className), closeAllModals(): compatibility wrappers for legacy UI helper calls.
    // - reportError(kind, payload): centralized startup/runtime user-visible error handling.
    // Owns shared UI concerns: overlays, modal visibility, status/progress text, and common button state updates.
    APP.UI = (() => {
        const dom = {};
        let messageTimer = null;
        let solverAbortRequested = false;

        const addClass = (el, cls) => { if (el && cls) el.classList.add(cls); };
        const removeClass = (el, cls) => { if (el && cls) el.classList.remove(cls); };
        const toggleClass = (el, cls, force) => { if (el && cls) el.classList.toggle(cls, force); };
        const setText = (el, value = '') => { if (el) el.textContent = `${value}`; };
        const setHTML = (el, value = '') => { if (el) el.innerHTML = `${value}`; };
        const setStyle = (el, key, value) => { if (el) el.style[key] = value; };
        const safeEnable = (el, enabled = true) => { if (el) el.disabled = !enabled; };
        const show = (el, displayClass = 'flex') => { if (!el) return; removeClass(el, 'hidden'); if (displayClass) addClass(el, displayClass); };
        const hide = (el, displayClass = 'flex') => { if (!el) return; addClass(el, 'hidden'); if (displayClass) removeClass(el, displayClass); };

        const initDom = () => {
            if (dom.__inited) return;
            dom.__inited = true;
            [
                'loadingOverlay','loadPercent','loadProgressBar','loadStatusLabel','loadErrorMessage',
                'message','searchIndicator','searchLabel','solverCloseBtn','solverTimer',
                'megaStatus','megaSummary','megaOutput','megaModal','megaSolverBtn',
                'guideModal','editorHelpModal','winModal','themeModal','unsavedModal',
                'gooseJumpScare','bombJumpScare','alertOverlay','hintBtn','solutionOutput','completionBurst',
                'themeEditList','themeSelectView','themeEditView','dragGhost'
            ].forEach(id => { dom[id] = document.getElementById(id); });
        };

        const resolveEl = (idOrEl) => {
            if (!idOrEl) return null;
            if (typeof idOrEl !== 'string') return idOrEl;
            if (dom[idOrEl]) return dom[idOrEl];
            const found = document.getElementById(idOrEl);
            if (found) dom[idOrEl] = found;
            return found;
        };
        const getEl = (key) => resolveEl(key);

        const setStatus = (text = '', severity = 'info', className = '') => {
            const el = getEl('message');
            if (!el) return;
            el.className = `font-black text-[0.9rem] uppercase tracking-tighter architectural-tight leading-tight drop-shadow-lg ${className}`.trim();
            el.dataset.severity = severity;
            setText(el, text);
        };

        const setProgress = ({ phase = '', current = null, total = null, pct = null, detail = '', mode = '' } = {}) => {
            if (pct !== null && pct !== undefined) {
                const clamped = Math.max(0, Math.min(100, Number(pct)));
                setText(getEl('loadPercent'), `${Math.round(clamped)}%`);
                setStyle(getEl('loadProgressBar'), 'width', `${clamped}%`);
            }
            const parts = [];
            if (phase) parts.push(phase);
            if (current !== null && total !== null) parts.push(`${current}/${total}`);
            if (detail) parts.push(detail);
            if (mode) parts.push(mode);
            if (parts.length) setText(getEl('loadStatusLabel'), parts.join(' • '));
        };

        const showOverlay = (key) => show(getEl(key));
        const hideOverlay = (key) => hide(getEl(key));
        const setOverlayOpacity = (key, value) => setStyle(getEl(key), 'opacity', value);

        const openModal = (id) => removeClass(resolveEl(id), 'hidden');
        const closeModal = (id) => addClass(resolveEl(id), 'hidden');
        const isModalOpen = (id) => {
            const el = resolveEl(id);
            return !!el && !el.classList.contains('hidden');
        };

        const toggleModal = (id, force = null) => {
            const el = resolveEl(id);
            if (!el) return false;
            const next = (force === null) ? el.classList.contains('hidden') : force;
            toggleClass(el, 'hidden', !next);
            return next;
        };

        const setModalContent = (id, value, mode = 'text') => {
            const el = resolveEl(id);
            if (!el) return;
            if (mode === 'html') setHTML(el, value);
            else setText(el, value);
        };

        const setFieldValue = (id, value = '') => {
            const el = resolveEl(id);
            if (!el) return;
            el.value = `${value}`;
        };

        const appendFieldLine = (id, line = '') => {
            const el = resolveEl(id);
            if (!el) return;
            el.value += `${line}\n`;
            el.scrollTop = el.scrollHeight;
        };

        const clearElement = (id) => {
            const el = resolveEl(id);
            if (!el) return;
            setHTML(el, '');
        };

        const setButtonLabel = (idOrEl, label = "") => {
            const el = resolveEl(idOrEl);
            if (!el) return;
            setText(el, label);
        };

        const setButtonState = (id, { enabled = true, active = null, label = null, className = null } = {}) => {
            const el = resolveEl(id);
            if (!el) return;
            safeEnable(el, enabled);
            if (active !== null) toggleClass(el, 'selected', !!active);
            if (label !== null) setText(el, label);
            if (className !== null) el.className = className;
        };

        const setClassState = (idOrEl, cls, on) => {
            const el = resolveEl(idOrEl);
            if (!el) return;
            toggleClass(el, cls, !!on);
        };
        const clearClass = (selector, cls) => {
            document.querySelectorAll(selector).forEach(el => removeClass(el, cls));
        };
        const queryAll = (selector) => Array.from(document.querySelectorAll(selector));
        const bindAll = (selector, eventName, handler) => {
            queryAll(selector).forEach(el => el.addEventListener(eventName, (e) => handler(e, el)));
        };
        const addClasses = (el, classes = []) => { if (!el) return; classes.forEach(cls => addClass(el, cls)); };
        const removeClasses = (el, classes = []) => { if (!el) return; classes.forEach(cls => removeClass(el, cls)); };
        const setInlineStyle = (idOrEl, key, value) => {
            const el = resolveEl(idOrEl);
            setStyle(el, key, value);
        };
        const setTextContent = (idOrEl, value = '') => {
            const el = resolveEl(idOrEl);
            setText(el, value);
        };
        const setInputValue = (idOrEl, value = '') => {
            const el = resolveEl(idOrEl);
            if (el) el.value = value;
        };
        const setSolutionOutput = (value = '') => setFieldValue('solutionOutput', value);
        const setMegaOutput = (value = '') => {
            setFieldValue('megaOutput', value);
            const el = resolveEl('megaOutput');
            if (el) el.scrollTop = el.scrollHeight;
        };
        const appendMegaOutputLine = (line = '') => appendFieldLine('megaOutput', line);
        const getMegaOutputText = () => getValue('megaOutput');
        const updateLevelDisplay = (index, isComplete = false) => {
            const lvlStr = `${index + 1}`;
            setModalContent('levelTitle', lvlStr, 'text');
            setInlineStyle('levelTitle', 'fontSize', lvlStr.length >= 3 ? '2.5rem' : '');
            setCompletionBurstVisible(!!isComplete);
        };
        const getValue = (idOrEl, fallback = '') => {
            const el = resolveEl(idOrEl);
            return el ? el.value : fallback;
        };
        const getChecked = (idOrEl, fallback = false) => {
            const el = resolveEl(idOrEl);
            return el ? !!el.checked : fallback;
        };
        const getNumber = (idOrEl, fallback = 0) => {
            const v = parseInt(getValue(idOrEl, `${fallback}`), 10);
            return Number.isNaN(v) ? fallback : v;
        };

        const clearPaletteSelection = () => {
            queryAll('.palette-item.selected').forEach(x => removeClass(x, 'selected'));
        };
        const setPaletteSelectedByType = (type, selected) => {
            const el = queryAll('.palette-item[data-type]').find(node => node.dataset.type === type);
            if (el) toggleClass(el, 'selected', !!selected);
        };

        const setRootCssVar = (name, value) => {
            document.documentElement.style.setProperty(name, value);
        };
        const setBodyStyle = (key, value) => setStyle(document.body, key, value);
        const queryOne = (idOrEl, selector) => {
            const el = resolveEl(idOrEl);
            return el ? el.querySelector(selector) : null;
        };

        const showGooseJumpScare = () => {
            const overlay = getEl('gooseJumpScare');
            show(overlay);
        };

        const hideGooseJumpScare = () => {
            const overlay = getEl('gooseJumpScare');
            hide(overlay);
        };

        const showBombDetonation = ({ explodedMarkup } = {}) => {
            const overlay = getEl('bombJumpScare');
            show(overlay);
            if (explodedMarkup) {
                const bomb = overlay ? overlay.querySelector('#scaryBomb') : null;
                setHTML(bomb, explodedMarkup);
            }
        };

        const hideBombDetonation = ({ resetMarkup } = {}) => {
            const overlay = getEl('bombJumpScare');
            hide(overlay);
            if (resetMarkup) {
                const bomb = overlay ? overlay.querySelector('#scaryBomb') : null;
                setHTML(bomb, resetMarkup);
            }
        };

        // Overlay boundary: state decisions live outside APP.UI; APP.UI owns all related DOM rendering/mutations.
        const setSearchIndicatorVisible = (visible) => {
            if (visible) showOverlay('searchIndicator');
            else hideOverlay('searchIndicator');
        };

        const setSolverControlsEnabled = (enabled) => {
            setButtonState('editMegaSolver', { enabled });
            setButtonState('editTrapSpotsBtn', { enabled });
            const hintEl = resolveEl('hintBtn');
            if (!hintEl) return;
            setStyle(hintEl, 'pointerEvents', enabled ? 'auto' : 'none');
            setStyle(hintEl, 'opacity', enabled ? '1' : '0.5');
        };

        const setSolverTimerText = (text) => setModalContent('solverTimer', text, 'text');

        // setOverlayState updates state only; APP.UI.applyOverlayState renders it.
        const applyOverlayState = (state) => {
            if (state === SOLVER_RUNNING) {
                setSearchIndicatorVisible(true);
                setButtonState('solverCloseBtn', { enabled: true });
                if (!solverAbortRequested) setModalContent('searchLabel', 'Finding Solutions...', 'text');
                setSolverControlsEnabled(false);
                return;
            }
            setSearchIndicatorVisible(false);
            setButtonState('solverCloseBtn', { enabled: true });
            setSolverControlsEnabled(true);
        };

        const setCompletionBurstVisible = (isVisible) => {
            const burst = resolveEl('completionBurst');
            toggleClass(burst, 'hidden', !isVisible);
        };

        const flashMessage = (text = '', className = '', duration = 1200) => {
            const overlay = getEl('alertOverlay');
            setStatus(text, 'info', className);
            if (!overlay) return;
            removeClass(overlay, 'pointer-events-none');
            setStyle(overlay, 'opacity', text ? '1' : '0');
            if (!text) {
                addClass(overlay, 'pointer-events-none');
                return;
            }
            setTimeout(() => {
                setStyle(overlay, 'opacity', '0');
                addClass(overlay, 'pointer-events-none');
            }, duration);
        };

        const showMessage = (text = '', className = '') => {
            setStatus(text, 'info', className || '');
            const overlay = getEl('alertOverlay');
            if (!overlay) return;
            if (text === '') { setInlineStyle(overlay, 'opacity', '0'); return; }
            setInlineStyle(overlay, 'opacity', '1');
            if (messageTimer) clearTimeout(messageTimer);
            messageTimer = setTimeout(() => { setInlineStyle(overlay, 'opacity', '0'); }, 2000);
        };


        const setSolverAbortRequested = (requested) => {
            solverAbortRequested = !!requested;
        };

        const copyText = async (text, opts = {}) => {
            const value = `${text ?? ''}`;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(value);
                    return true;
                } catch (_) {}
            }
            const fallbackEl = opts.fallbackEl || (opts.fallbackElId ? resolveEl(opts.fallbackElId) : null);
            if (!fallbackEl) return false;
            if ('value' in fallbackEl) fallbackEl.value = value;
            else fallbackEl.textContent = value;
            if (typeof fallbackEl.select === 'function') fallbackEl.select();
            try {
                return document.execCommand('copy');
            } catch (_) {
                return false;
            }
        };

        const applyTheme = (t, opts = {}) => {
            const { themeName = '' } = opts;
            const root = document.documentElement;
            root.style.setProperty('--theme-gate', t.colors.gate); root.style.setProperty('--theme-goal', t.colors.goal); root.style.setProperty('--theme-block', t.colors.block); root.style.setProperty('--theme-block-dot', t.grid); root.style.setProperty('--theme-pin', t.colors.pin); root.style.setProperty('--theme-portal', t.colors.portal); root.style.setProperty('--theme-filter', t.colors.filter); root.style.setProperty('--theme-cross', t.colors.cross); root.style.setProperty('--theme-modal-bg', t.modal.bg); root.style.setProperty('--theme-modal-panel', t.modal.panelBg); root.style.setProperty('--theme-modal-border', t.modal.border); root.style.setProperty('--theme-modal-text', t.modal.text); root.style.setProperty('--theme-modal-muted', t.modal.textMuted); root.style.setProperty('--theme-modal-accent', t.modal.accent); root.style.setProperty('--theme-win-bg', t.win.bg); root.style.setProperty('--theme-win-border', t.win.border); root.style.setProperty('--theme-win-text', t.win.text); root.style.setProperty('--theme-win-accent', t.win.accent); root.style.setProperty('--theme-alert-bg', t.alert?.bg || '#1e40af'); root.style.setProperty('--theme-alert-stroke', t.alert?.stroke || '#93c5fd');
            const alertBg = (t.alert?.bg || '#1e40af');
            const hex = alertBg.replace('#','');
            let r = 30, g = 64, b = 175;
            if (/^[0-9a-fA-F]{6}$/.test(hex)) { r = parseInt(hex.slice(0,2),16); g = parseInt(hex.slice(2,4),16); b = parseInt(hex.slice(4,6),16); }
            const luminance = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
            const alertText = themeName === 'classic' ? '#ffffff' : (luminance > 0.55 ? '#0f172a' : '#ffffff');
            root.style.setProperty('--theme-alert-text', alertText);
            root.style.setProperty('--theme-logo-bg', t.canvasBg); root.style.setProperty('--theme-logo-grid', t.grid); root.style.setProperty('--theme-logo-path', t.path === 'rainbow' ? '#3b82f6' : t.path); root.style.setProperty('--theme-logo-gate', t.colors.gate); root.style.setProperty('--theme-logo-goal', t.colors.goal);
            root.style.setProperty('--theme-burst', t.burst || '#fef9c3'); root.style.setProperty('--theme-check', t.check || '#1e293b');
            root.style.setProperty('--theme-mega-output-bg', t.mega.outputBg); root.style.setProperty('--theme-mega-output-text', t.text.megaOutput); root.style.setProperty('--theme-mega-output-border', t.mega.outputBorder);
            root.style.setProperty('--theme-mega-primary-bg', t.mega.primaryBg); root.style.setProperty('--theme-mega-primary-text', t.text.megaPrimary); root.style.setProperty('--theme-mega-primary-border', t.mega.primaryBorder);
            root.style.setProperty('--theme-mega-secondary-bg', t.mega.secondaryBg); root.style.setProperty('--theme-mega-secondary-text', t.text.megaSecondary); root.style.setProperty('--theme-mega-secondary-border', t.mega.secondaryBorder);
            root.style.setProperty('--theme-mega-gemini-bg', t.mega.geminiBg); root.style.setProperty('--theme-mega-gemini-text', t.text.megaGemini); root.style.setProperty('--theme-mega-gemini-border', t.mega.geminiBorder);
            root.style.setProperty('--theme-mega-copy-bg', t.mega.copyBg); root.style.setProperty('--theme-mega-copy-text', t.text.megaCopy); root.style.setProperty('--theme-mega-copy-border', t.mega.copyBorder);
            root.style.setProperty('--theme-mega-desc-text', t.text.megaDesc);
            const leave = APP.Themes.getLeaveThemeColors(t, themeName === 'classic');
            root.style.setProperty('--theme-leave-bg', leave.bg); root.style.setProperty('--theme-leave-hover', leave.hover); root.style.setProperty('--theme-leave-text', leave.text); root.style.setProperty('--theme-leave-border', leave.border);

            document.body.style.backgroundColor = t.bodyBg; APP.Renderer.getCanvas().style.backgroundColor = t.canvasBg;
            getEl('headerLeft').style.backgroundColor = t.canvasBg;
            getEl('headerMiddle').style.backgroundColor = t.headerLeft;
            getEl('headerRight').style.backgroundColor = t.headerRight;
            getEl('headerBar').style.borderColor = t.grid;
            getEl('levelTitle').style.color = t.text.headerMain;
            getEl('levelLabelText').style.color = t.text.headerSub;
            const ghost = getEl('dragGhost'); ghost.style.backgroundColor = t.ghostBg; ghost.style.borderColor = t.ghostBorder; const pal = getEl('editorPalette'); pal.style.backgroundColor = t.palette.bg; pal.style.borderColor = t.palette.border; queryAll('.palette-item').forEach(item => { item.style.backgroundColor = t.palette.itemBg; item.style.borderColor = t.palette.itemBorder; }); getEl('editCopyMetrics').style.backgroundColor = t.headerLeft; getEl('editCopyMetrics').style.borderColor = t.palette.itemBorder; const pc = getEl('playControls'); pc.style.backgroundColor = t.controls; pc.style.borderColor = t.grid; getEl('undoBtn').style.backgroundColor = t.btns.undo; getEl('resetBtn').style.backgroundColor = t.btns.reset; getEl('guideBtn').style.backgroundColor = t.btns.guide; getEl('whoaBtn').style.backgroundColor = t.btns.whoa;

            const isDark = (t.bodyBg === '#020617' || t.bodyBg === '#000000');
            const neutralBtn = isDark ? '#334155' : '#e2e8f0';
            const neutralText = isDark ? '#f8fafc' : '#475569';

            getEl('openThemeModalBtn').style.backgroundColor = neutralBtn;
            getEl('openThemeModalBtn').style.color = neutralText;
            getEl('openThemeModalBtn').style.borderColor = t.modal.border;
            getEl('orientationToggleBtn').style.backgroundColor = t.btns.orient || t.btns.modeToggle || t.headerRight || '#1e293b';
            getEl('orientationToggleBtn').style.color = '#ffffff';
            getEl('orientationToggleBtn').style.borderColor = t.grid;

            getEl('megaSolverBtn').style.backgroundColor = t.btns.mega || t.btns.solve || '#c026d3'; getEl('editResetGrid').style.backgroundColor = t.btns.editClear || t.btns.reset || '#dc2626'; getEl('editNewLevel').style.backgroundColor = t.btns.editNew || t.btns.saved || '#0a8a65'; getEl('editHelpBtn').style.backgroundColor = t.btns.guide; getEl('editMegaSolver').style.backgroundColor = t.btns.solve || t.headerRight || '#c026d3'; getEl('editTrapSpotsBtn').style.backgroundColor = t.btns.editBombs || t.colors.goal || '#ef4444'; getEl('modeToggleBtn').style.backgroundColor = t.btns.modeToggle || t.headerRight || '#1e293b'; getEl('editModeToggleBtn').style.backgroundColor = t.btns.modeToggle || t.headerRight || '#1e293b'; const muteBtn = getEl('muteBtn'); muteBtn.style.backgroundColor = neutralBtn; muteBtn.style.color = neutralText; muteBtn.style.borderColor = t.modal.border; getEl('muteIcon').style.color = neutralText; getEl('muteSlash').style.color = neutralText; getEl('devCopyBtn').style.backgroundColor = t.btns.copy; getEl('editCopyBtn').style.backgroundColor = t.btns.copy; getEl('devGenBtn').style.backgroundColor = t.btns.gen; getEl('editGenBtn').style.backgroundColor = t.btns.gen; getEl('devCopyBtn').style.color = t.btns.muteIcon; getEl('editCopyBtn').style.color = t.btns.muteIcon; getEl('devGenBtn').style.color = t.btns.muteIcon; getEl('editGenBtn').style.color = t.btns.muteIcon; getEl('exportLabel').style.color = t.text.metric; queryAll('.metric-label').forEach(el => el.style.color = t.text.metric); getEl('solutionOutput').style.backgroundColor = t.output?.bg || '#0f172a'; getEl('solutionOutput').style.color = t.text.output; getEl('solutionOutput').style.borderColor = t.modal.border; getEl('winSolutionOutput').style.backgroundColor = t.output?.bg || '#0f172a'; getEl('winSolutionOutput').style.color = t.text.output; getEl('winSolutionOutput').style.borderColor = t.modal.border; getEl('megaOutput').style.backgroundColor = t.mega.outputBg; getEl('megaOutput').style.color = t.text.megaOutput; getEl('megaOutput').style.borderColor = t.mega.outputBorder; getEl('copyMegaDataBtn').style.backgroundColor = t.mega.copyBg; getEl('copyMegaDataBtn').style.color = t.text.megaCopy; getEl('copyMegaDataBtn').style.borderColor = t.mega.copyBorder; [['megaRetry30Btn','primary'],['megaRetry60Btn','primary'],['megaRetry120Btn','primary'],['megaRetryAltBtn','secondary'],['megaGeminiRetryBtn','gemini']].forEach(([id,type]) => { const el = getEl(id); if (!el) return; el.style.backgroundColor = t.mega[`${type}Bg`]; el.style.color = t.text[`mega${type.charAt(0).toUpperCase()+type.slice(1)}`]; el.style.borderColor = t.mega[`${type}Border`]; }); getEl('gridSizeMinusBtn').style.backgroundColor = t.btns.copy; getEl('gridSizeMinusBtn').style.color = t.btns.muteIcon; getEl('gridSizeMinusBtn').style.borderColor = t.palette.itemBorder; getEl('gridSizePlusBtn').style.backgroundColor = t.btns.copy; getEl('gridSizePlusBtn').style.color = t.btns.muteIcon; getEl('gridSizePlusBtn').style.borderColor = t.palette.itemBorder; getEl('gridRotateBtn').style.backgroundColor = t.btns.copy; getEl('gridRotateBtn').style.color = t.btns.muteIcon; getEl('gridRotateBtn').style.borderColor = t.palette.itemBorder; getEl('gridMirrorBtn').style.backgroundColor = t.btns.copy; getEl('gridMirrorBtn').style.color = t.btns.muteIcon; getEl('gridMirrorBtn').style.borderColor = t.palette.itemBorder; getEl('gridSizeLabel').style.color = t.btns.muteIcon;
            const gArea = getEl('gridControlArea'); if(gArea) { gArea.style.backgroundColor = t.ctrlArea?.bg || '#f8fafc'; gArea.style.borderColor = t.ctrlArea?.border || '#cbd5e1'; }
            const winModalContent = getEl('winModalContent'); getEl('winCircle').style.backgroundColor = t.win.bg; getEl('winCircle').style.borderColor = t.win.border; winModalContent.querySelector('h2').style.color = t.text.winAccent; winModalContent.querySelector('p').style.color = t.text.win; getEl('nextLevelModalBtn').style.color = t.text.winAccent; getEl('dismissWinModalBtn').style.color = t.text.winAccent;
        };

        const closeAllModals = () => {
            ['guideModal', 'editorHelpModal', 'winModal', 'megaModal', 'themeModal', 'unsavedModal'].forEach(id => closeModal(id));
        };
        const showMessageCompat = (text = '', className = '') => showMessage(text, className);

        const reportError = (kind, payload) => {
            const details = payload?.message || payload?.reason || 'Unknown initialization failure.';
            setModalContent('loadErrorMessage', `Startup error (${kind}): ${details}`, 'text');
            removeClass(getEl('loadErrorMessage'), 'hidden');
            setStatus(`Startup error (${kind})`, 'error', 'text-red-200');
        };

        // Purpose: theme customization UI state + drag interactions.
        // Owns:
        // - theme editor DOM refs
        // - swatch selection/drag ghost
        // - editor list rendering
        // - edit/select view switching
        // Public API: init, renderAll, renderThemeKey, setSwatchSelected, setDragGhost, openEditorView, closeEditorView.
        // APP.UI.ThemeEditor Public API:
        // - init(): cache theme editor refs used for rendering and view toggles.
        // - renderAll(): render every editable theme block.
        // - renderThemeKey(key): build one theme editor block.
        // - setSwatchSelected(elOrNull): maintain single selected swatch visual state.
        // - setDragGhost({ visible, color, x, y }): render theme drag ghost appearance/position.
        const ThemeEditor = (() => {
            const selectedClasses = ['ring-4', 'ring-[var(--theme-modal-accent)]', 'theme-swatch-selected', 'z-10', 'scale-110'];
            const teDom = { inited: false, list: null, selectView: null, editView: null, ghost: null };
            const ensureInit = () => {
                if (teDom.inited) return;
                teDom.inited = true;
                teDom.list = resolveEl('themeEditList');
                teDom.selectView = resolveEl('themeSelectView');
                teDom.editView = resolveEl('themeEditView');
                teDom.ghost = resolveEl('dragGhost');
            };
            const dragState = { color: null, theme: null, category: null, tapColor: null, tapTheme: null, tapCategory: null };
                        const setSwatchSelected = (elOrNull) => {
                document.querySelectorAll('.theme-swatch-selected').forEach(el => el.classList.remove(...selectedClasses));
                if (elOrNull) elOrNull.classList.add(...selectedClasses);
            };
            const setDragGhost = ({ visible = false, color = null, x = null, y = null } = {}) => {
                ensureInit();
                const ghost = teDom.ghost;
                if (!ghost) return;
                if (!visible) {
                    ghost.style.display = 'none';
                    ghost.innerHTML = '';
                    return;
                }
                ghost.style.width = '32px';
                ghost.style.height = '32px';
                if (color) ghost.style.backgroundColor = color;
                ghost.style.borderColor = '#000';
                ghost.className = 'flex items-center justify-center rounded shadow-lg border-2 border-black border-dashed fixed pointer-events-none z-[1000]';
                ghost.innerHTML = '';
                ghost.style.display = 'flex';
                if (x !== null) ghost.style.left = `${x}px`;
                if (y !== null) ghost.style.top = `${y}px`;
            };

            const renderThemeKey = (themeKey) => {
                const container = document.createElement('div');
                container.className = "flex flex-col gap-2";
                const header = document.createElement('h4');
                header.className = "font-black text-[var(--theme-modal-accent)] uppercase tracking-widest text-sm";
                header.innerText = themeKey.replace('_', ' ');
                container.appendChild(header);
                const t = APP.Themes.THEMES[themeKey] || {};
                const toColorSet = (arr) => new Set(arr.filter(c => c && typeof c === 'string' && c !== 'rainbow'));
                const lineColors = toColorSet([t.modal?.border, t.palette?.border, t.palette?.itemBorder, t.win?.border, t.alert?.stroke, t.ctrlArea?.border, t.mega?.outputBorder, t.mega?.primaryBorder, t.mega?.secondaryBorder, t.mega?.geminiBorder, t.mega?.copyBorder, t.ghostBorder, t.leave?.border]);
                const btnColors = toColorSet([...Object.values(t.btns || {}), t.leave?.bg, t.leave?.hover]);
                const gridColors = toColorSet([t.colors?.gate, t.colors?.goal, t.colors?.block, t.colors?.pin, t.colors?.pinUnflipped, t.colors?.filter, t.colors?.portal, t.colors?.cross, t.path, t.grid]);
                const miscColors = toColorSet([t.bodyBg, t.canvasBg, t.headerLeft, t.headerRight, t.controls, t.ghostBg, t.modal?.bg, t.modal?.panelBg, t.output?.bg, t.palette?.bg, t.palette?.itemBg, t.palette?.toolBg, t.win?.bg, t.alert?.bg, t.ctrlArea?.bg, t.mega?.outputBg, t.mega?.primaryBg, t.mega?.secondaryBg, t.mega?.geminiBg, t.mega?.copyBg, t.burst, t.check]);
                const textColors = toColorSet([t.metricText, t.headerLeftText, t.headerLeftLabel, t.modal?.text, t.modal?.textMuted, t.modal?.accent, t.output?.text, t.win?.text, t.win?.accent, t.text?.modal, t.text?.modalMuted, t.text?.modalAccent, t.text?.output, t.text?.metric, t.text?.headerMain, t.text?.headerSub, t.text?.win, t.text?.winAccent, t.text?.megaDesc, t.text?.megaOutput, t.text?.megaPrimary, t.text?.megaSecondary, t.text?.megaGemini, t.text?.megaCopy, t.leave?.text]);
                const buildSwatch = (c, category) => {
                    const swatch = document.createElement('div');
                    swatch.className = "w-9 h-9 md:w-10 md:h-10 rounded shadow-sm border cursor-pointer hover:scale-110 transition-transform box-border shrink-0";
                    swatch.style.backgroundColor = c;
                    swatch.style.pointerEvents = 'auto';
                    swatch.classList.add('border-slate-300');
                    swatch.draggable = false;
                    swatch.dataset.themeColor = c;
                    swatch.dataset.themeKey = themeKey;
                    swatch.dataset.category = category;
                    swatch.style.touchAction = 'none';
                    swatch.onpointerdown = e => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (dragState.tapColor && dragState.tapTheme === themeKey) {
                            const sourceColor = dragState.tapColor;
                            const targetColor = c;
                            const sourceCategory = dragState.tapCategory;
                            const targetCategory = swatch.dataset.category;
                            if (sourceColor !== targetColor && sourceCategory === targetCategory) replaceThemeColor(themeKey, targetColor, sourceColor, targetCategory);
                            dragState.tapColor = null;
                            dragState.tapTheme = null;
                            dragState.tapCategory = null;
                            setSwatchSelected(null);
                            APP.Engine.setLogicState(IDLE);
                            setDragGhost({ visible: false });
                            return;
                        }
                        dragState.tapColor = c;
                        dragState.tapTheme = themeKey;
                        dragState.tapCategory = category;
                        setSwatchSelected(swatch);
                        dragState.color = c;
                        dragState.theme = themeKey;
                        dragState.category = category;
                        APP.Engine.setLogicState(THEME_DRAG);
                        setDragGhost({ visible: true, color: c, x: e.clientX, y: e.clientY });
                    };
                    return swatch;
                };
                const buildSection = (title, colorArr) => {
                    const section = document.createElement('div');
                    section.className = "flex flex-col items-center p-1 rounded bg-black/5 min-h-[6.5rem]";
                    const ctitle = document.createElement('div');
                    ctitle.className = "text-[0.6rem] font-black uppercase text-[var(--theme-modal-muted)] mb-1.5 tracking-widest text-center";
                    ctitle.innerText = title;
                    section.appendChild(ctitle);
                    const grid = document.createElement('div');
                    grid.className = "grid grid-cols-4 gap-0.5 w-full justify-items-center";
                    colorArr.forEach(c => grid.appendChild(buildSwatch(c, title)));
                    section.appendChild(grid);
                    return section;
                };
                const sectionsContainer = document.createElement('div');
                sectionsContainer.className = "grid grid-cols-2 gap-2 mb-1";
                sectionsContainer.appendChild(buildSection("Buttons", Array.from(btnColors)));
                sectionsContainer.appendChild(buildSection("Grid Items", Array.from(gridColors)));
                sectionsContainer.appendChild(buildSection("Misc", Array.from(miscColors)));
                sectionsContainer.appendChild(buildSection("Lines", Array.from(lineColors)));
                const textRow = document.createElement('div');
                textRow.className = "mb-1";
                textRow.appendChild(buildSection("Text", Array.from(textColors)));
                container.appendChild(sectionsContainer);
                container.appendChild(textRow);
                const aiColorsContainer = document.createElement('div');
                aiColorsContainer.className = "flex flex-col items-center w-full mt-1 bg-black/5 rounded p-1.5";
                const aiTitle = document.createElement('div');
                aiTitle.className = "text-[0.55rem] font-black uppercase text-[var(--theme-modal-accent)] mb-1 tracking-widest";
                aiTitle.innerText = "Complementary Palette (AI)";
                aiColorsContainer.appendChild(aiTitle);
                const aiGrid = document.createElement('div');
                aiGrid.className = "flex justify-center gap-1.5 w-full min-h-[2.5rem] flex-wrap items-center";
                aiColorsContainer.appendChild(aiGrid);
                const handleAiGeneration = async () => {
                    aiGrid.innerHTML = '<span class="text-[0.55rem] font-bold text-[var(--theme-modal-muted)] animate-pulse uppercase tracking-widest">Calling Specialist...</span>';
                    const { colors, error } = await APP.Themes.fetchGeminiThemeColors(themeKey, t);
                    if (colors && colors.length >= 6) {
                        if (!window.THEME_AI_COLORS) window.THEME_AI_COLORS = {};
                        window.THEME_AI_COLORS[themeKey] = colors.slice(0, 6);
                        aiGrid.innerHTML = '';
                        window.THEME_AI_COLORS[themeKey].forEach(c => aiGrid.appendChild(buildSwatch(c, "Misc")));
                    } else {
                        aiGrid.innerHTML = '';
                        const failWrap = document.createElement('div');
                        failWrap.className = "flex flex-col items-center gap-1";
                        const failBtn = document.createElement('button');
                        failBtn.className = "text-[0.55rem] text-red-500 font-bold uppercase tracking-widest hover:scale-105 transition-transform";
                        failBtn.innerText = "Generation Failed - Retry?";
                        failBtn.onclick = handleAiGeneration;
                        const detail = document.createElement('div');
                        detail.className = "text-[0.5rem] text-[var(--theme-modal-muted)] max-w-[16rem] text-center leading-tight";
                        detail.innerText = error || "Unknown Gemini error.";
                        failWrap.appendChild(failBtn);
                        failWrap.appendChild(detail);
                        aiGrid.appendChild(failWrap);
                    }
                };
                if (!window.THEME_AI_COLORS) window.THEME_AI_COLORS = {};
                if (window.THEME_AI_COLORS[themeKey]) window.THEME_AI_COLORS[themeKey].forEach(c => aiGrid.appendChild(buildSwatch(c, "Misc")));
                else {
                    const genBtn = document.createElement('button');
                    genBtn.className = "bg-[var(--theme-modal-panel)] border border-[var(--theme-modal-border)] text-[var(--theme-modal-text)] px-4 py-2 rounded-lg font-black text-[0.6rem] uppercase tracking-widest shadow-sm hover:brightness-95 transition active:scale-95";
                    genBtn.innerText = "Generate Suggestions";
                    genBtn.onclick = handleAiGeneration;
                    aiGrid.appendChild(genBtn);
                }
                container.appendChild(aiColorsContainer);
                const controlsRow = document.createElement('div');
                controlsRow.className = "flex gap-2 items-center mt-2";
                const textarea = document.createElement('textarea');
                textarea.className = "flex-grow h-8 bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] rounded px-2 py-1.5 text-[0.6rem] font-mono no-scrollbar whitespace-nowrap overflow-x-auto resize-none leading-tight";
                textarea.readOnly = true;
                textarea.placeholder = "Export code will appear here...";
                const exportBtn = document.createElement('button');
                exportBtn.className = "bg-[var(--theme-modal-panel)] border border-[var(--theme-modal-border)] text-[var(--theme-modal-text)] px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:brightness-95 transition shrink-0";
                exportBtn.innerText = "Export";
                exportBtn.onclick = () => {
                    const code = `${themeKey}: ${JSON.stringify(APP.Themes.THEMES[themeKey])},`;
                    textarea.value = code;
                    copyText(code, { fallbackEl: textarea, fallbackElId: 'solutionOutput' });
                    const origText = exportBtn.innerText;
                    exportBtn.innerText = "Copied!";
                    setTimeout(() => exportBtn.innerText = origText, 1500);
                };
                const undoBtn = document.createElement('button');
                undoBtn.className = "bg-slate-500 text-white px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:bg-slate-600 transition shadow-sm shrink-0";
                undoBtn.innerText = "Undo";
                const canUndo = window.THEME_UNDO_STACKS && window.THEME_UNDO_STACKS[themeKey] && window.THEME_UNDO_STACKS[themeKey].length > 0;
                if (!canUndo) { undoBtn.disabled = true; undoBtn.classList.add('opacity-50', 'cursor-not-allowed'); }
                undoBtn.onclick = () => {
                    if (canUndo) {
                        const prev = window.THEME_UNDO_STACKS[themeKey].pop();
                        APP.Themes.THEMES[themeKey] = JSON.parse(JSON.stringify(prev));
                        renderAll();
                        APP.Themes.populateThemes();
                    }
                };
                const resetBtn = document.createElement('button');
                resetBtn.className = "bg-red-600 text-white px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:bg-red-700 transition shadow-sm shrink-0";
                resetBtn.innerText = "Reset";
                resetBtn.onclick = () => {
                    if (window.ORIGINAL_THEMES && window.ORIGINAL_THEMES[themeKey]) {
                        APP.Themes.THEMES[themeKey] = JSON.parse(JSON.stringify(window.ORIGINAL_THEMES[themeKey]));
                        if (!window.THEME_UNDO_STACKS) window.THEME_UNDO_STACKS = {};
                        window.THEME_UNDO_STACKS[themeKey] = [];
                        renderAll();
                        APP.Themes.populateThemes();
                    }
                };
                controlsRow.appendChild(textarea);
                controlsRow.appendChild(exportBtn);
                controlsRow.appendChild(undoBtn);
                controlsRow.appendChild(resetBtn);
                container.appendChild(controlsRow);
                return container;
            };

            const renderAll = () => {
                ensureInit();
                if (!teDom.list || !window.ORIGINAL_THEMES) return;
                teDom.list.innerHTML = '';
                const keys = Object.keys(window.ORIGINAL_THEMES).filter(k => k !== 'classic');
                keys.forEach((key, idx) => {
                    teDom.list.appendChild(renderThemeKey(key));
                    if (idx < keys.length - 1) {
                        const hr = document.createElement('hr');
                        hr.className = "border-[var(--theme-modal-border)] opacity-30 my-4";
                        teDom.list.appendChild(hr);
                    }
                });
            };

            const openEditorView = () => {
                ensureInit();
                if (teDom.selectView) teDom.selectView.classList.add('hidden');
                if (teDom.editView) {
                    teDom.editView.classList.remove('hidden');
                    teDom.editView.classList.add('flex');
                }
                renderAll();
            };

            const closeEditorView = () => {
                ensureInit();
                if (teDom.editView) {
                    teDom.editView.classList.add('hidden');
                    teDom.editView.classList.remove('flex');
                }
                if (teDom.selectView) teDom.selectView.classList.remove('hidden');
                setSwatchSelected(null);
                dragState.color = null; dragState.theme = null; dragState.category = null; dragState.tapColor = null; dragState.tapTheme = null; dragState.tapCategory = null;
                setDragGhost({ visible: false });
            };

            return { init: ensureInit, renderAll, renderThemeKey, setSwatchSelected, setDragGhost, openEditorView, closeEditorView, getDragState: () => ({ ...dragState }), clearDragState: () => { dragState.color = null; dragState.theme = null; dragState.category = null; }, hasTapSelection: () => !!dragState.tapColor };
        })();

        const EditorDragGhost = (() => {
            const getPaletteIconSVG = (type) => {
                if (!type) return '';
                const icon = document.querySelector(`.palette-item[data-type="${type}"] svg`);
                return icon ? icon.outerHTML : '';
            };

            const isPointerOverPalette = (x, y) => {
                const palEl = getEl('editorPalette');
                if (!palEl || palEl.classList.contains('hidden')) return false;
                const palRect = palEl.getBoundingClientRect();
                return x >= palRect.left && x <= palRect.right && y >= palRect.top && y <= palRect.bottom;
            };

            const update = ({ visible = false, x = 0, y = 0, cellSize = 0, type = '', isOverPalette = false } = {}) => {
                const ghostEl = getEl('dragGhost');
                if (!ghostEl) return;
                if (!visible || isOverPalette) {
                    setInlineStyle(ghostEl, 'display', 'none');
                    setModalContent(ghostEl, '', 'html');
                    return;
                }
                const ghostSize = cellSize * 1.15;
                setInlineStyle(ghostEl, 'width', `${ghostSize}px`);
                setInlineStyle(ghostEl, 'height', `${ghostSize}px`);
                setInlineStyle(ghostEl, 'left', `${x}px`);
                setInlineStyle(ghostEl, 'top', `${y}px`);
                if (!getEl('dragGhost').innerHTML) setModalContent(ghostEl, getPaletteIconSVG(type), 'html');
                setInlineStyle(ghostEl, 'display', 'flex');
            };

            return { update, getPaletteIconSVG, isPointerOverPalette };
        })();

        return { initDom, setStatus, setProgress, showOverlay, hideOverlay, setOverlayOpacity, openModal, closeModal, toggleModal, isModalOpen, setModalContent, setFieldValue, appendFieldLine, setSolutionOutput, setMegaOutput, appendMegaOutputLine, getMegaOutputText, updateLevelDisplay, clearElement, setButtonLabel, setButtonState, setSearchIndicatorVisible, setSolverControlsEnabled, setSolverTimerText, applyOverlayState, setClassState, clearClass, bindAll, addClasses, removeClasses, setInlineStyle, setRootCssVar, setBodyStyle, setTextContent, setInputValue, getValue, getChecked, getNumber, clearPaletteSelection, setPaletteSelectedByType, showGooseJumpScare, hideGooseJumpScare, showBombDetonation, hideBombDetonation, setCompletionBurstVisible, flashMessage, closeAllModals, showMessage: showMessageCompat, reportError, setSolverAbortRequested, copyText, applyTheme, ThemeEditor, EditorDragGhost };
    })();

    // ======================================================
    // I) APP.Solver
    // Purpose: async hint/solve orchestration and run lifecycle state.
    // Owns:
    // - active run timer/labels
    // - solver status flags
    // - solution application + output text
    // - mega solver coordination
    // Public API: isRunning, stop, runGameSolver, runMegaSolver, findTrapSpots.
    // ======================================================
    APP.Solver = (() => {
        let timerTick = null;
        let runStart = 0;
        let status = { running: false, mode: null, startedAt: 0 };

        const SolverCore = {
                _isMoveValid(key, path, counts, usage, ints, jumpSet, l, flipCount, crossedSet, options = {}) {
                    return isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, {
                        mode: PLAY,
                        flipCount,
                        crossedSet,
                        hazardPolicy: options.hazardPolicy || 'forbid'
                    });
                },
                _buildOptimisticDistMap(l, sourceKeys) {
                    const { w, h } = l.grid;
                    const map = new Map();
                    const left = [];
                    const right = [];
                    const pushFront = (item) => left.push(item);
                    const pushBack = (item) => right.push(item);
                    const popFront = () => {
                        if (left.length > 0) return left.pop();
                        if (right.length === 0) return null;
                        while (right.length > 0) left.push(right.pop());
                        return left.pop();
                    };
                    for (const k of sourceKeys) {
                        if (k === -1 || k === undefined || l.blockSet.has(k)) continue;
                        if (!map.has(k) || 0 < map.get(k)) {
                            map.set(k, 0);
                            pushBack(k);
                        }
                    }
                    while (true) {
                        const k = popFront();
                        if (k === null) break;
                        const d = map.get(k);
                        const p = APP.LevelUtils.UNPACK(k);
                        const portal = resolvePortal(l, k);
                        if (portal && portal.dest !== -1 && !l.blockSet.has(portal.dest)) {
                            const pd = map.get(portal.dest);
                            if (pd === undefined || d < pd) {
                                map.set(portal.dest, d);
                                pushFront(portal.dest);
                            }
                        }
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            const nx = p.x + dx, ny = p.y + dy;
                            if (!APP.LevelUtils.inBounds(nx, ny, w, h)) return;
                            const nk = APP.LevelUtils.PACK(nx, ny);
                            if (l.blockSet.has(nk)) return;
                            const nd = d + 1;
                            const prev = map.get(nk);
                            if (prev === undefined || nd < prev) {
                                map.set(nk, nd);
                                pushBack(nk);
                            }
                        });
                    }
                    return map;
                },
                _buildDistMap(l) {
                    return this._buildOptimisticDistMap(l, [l.goalKey]);
                },
                _buildFlipperDistMap(l, flipperSet) {
                    return this._buildOptimisticDistMap(l, flipperSet);
                },
                _mstBoundFromNodes(nodes, pairDist, toGoalDist, nearestFromStart) {
                    if (nodes.length === 0) return Infinity;
                    if (nearestFromStart === Infinity) return Infinity;
                    const nodeCount = nodes.length + 1;
                    const visited = new Array(nodeCount).fill(false);
                    const minEdge = new Array(nodeCount).fill(Infinity);
                    minEdge[0] = 0;
                    const edgeWeight = (a, b) => {
                        if (a === b) return 0;
                        if (a === 0) return toGoalDist[nodes[b - 1]];
                        if (b === 0) return toGoalDist[nodes[a - 1]];
                        return pairDist[nodes[a - 1]][nodes[b - 1]];
                    };
                    let mst = 0;
                    for (let i = 0; i < nodeCount; i++) {
                        let v = -1;
                        for (let j = 0; j < nodeCount; j++) {
                            if (!visited[j] && (v === -1 || minEdge[j] < minEdge[v])) v = j;
                        }
                        if (v === -1 || minEdge[v] === Infinity) return Infinity;
                        visited[v] = true;
                        mst += minEdge[v];
                        for (let to = 0; to < nodeCount; to++) {
                            if (visited[to]) continue;
                            const w = edgeWeight(v, to);
                            if (w < minEdge[to]) minEdge[to] = w;
                        }
                    }
                    return nearestFromStart + mst;
                },
                _estimateMustPassBoundFrom(key, state, l) {
                    return this._estimateMustPassBoundDetailed(key, state, l).bound;
                },
                _estimateMustPassBoundDetailed(key, state, l) {
                    const mask = state.mustMask;
                    if (mask === 0n) return { bound: l.distMapForSolver.get(key) ?? Infinity, method: 'goalOnly', k: 0 };
                    if (l.mustPassDpMode === 'exact') {
                        const memoKey = `${key}|${mask.toString()}`;
                        const cached = l.mustPassKeyMaskCache.get(memoKey);
                        if (cached !== undefined) return { bound: cached, method: 'permExact', k: l._popcountMask(mask) };
                        let best = Infinity;
                        for (let i = 0; i < l.mustPassKeys.length; i++) {
                            const bit = 1n << BigInt(i);
                            if ((mask & bit) === 0n) continue;
                            const dToMust = l.mustPassDistMaps[i].get(key);
                            if (dToMust === undefined) continue;
                            const rest = l.mustPassDp(mask ^ bit, i);
                            if (rest === Infinity) continue;
                            const total = dToMust + rest;
                            if (total < best) best = total;
                        }
                        l.mustPassKeyMaskCache.set(memoKey, best);
                        return { bound: best, method: 'permExact', k: l._popcountMask(mask) };
                    }
                    let nearest = Infinity;
                    const nodes = [];
                    for (let i = 0; i < l.mustPassKeys.length; i++) {
                        const bit = 1n << BigInt(i);
                        if ((mask & bit) === 0n) continue;
                        nodes.push(i);
                        const d = l.mustPassDistMaps[i].get(key);
                        if (d !== undefined && d < nearest) nearest = d;
                    }
                    if (nearest === Infinity) return { bound: Infinity, method: 'mst', k: nodes.length };
                    if (nodes.length === 0) return { bound: l.distMapForSolver.get(key) ?? Infinity, method: 'goalOnly', k: 0 };
                    return { bound: this._mstBoundFromNodes(nodes, l.mustPassPairDist, l.mustPassToGoalDist, nearest), method: 'mst', k: nodes.length };
                },
                _encodeMustCrossCounts(state) {
                    if (!state.mustCrossCounts || state.mustCrossCounts.length === 0) return 0n;
                    let code = 0n;
                    for (let i = 0; i < state.mustCrossCounts.length; i++) {
                        code = code * 3n + BigInt(state.mustCrossCounts[i]);
                    }
                    return code;
                },
                _encodeCounts(state) {
                    if (!state?.counts || state.counts.size === 0) return '';
                    const entries = [];
                    state.counts.forEach((count, key) => {
                        if (count > 0) entries.push([key, count]);
                    });
                    entries.sort((a, b) => a[0] - b[0]);
                    return entries.map(([key, count]) => `${key}:${count}`).join(',');
                },
                _encodeUsage(state) {
                    if (!state?.usage || state.usage.size === 0) return '';
                    const entries = [];
                    state.usage.forEach((usage, key) => {
                        if (!usage) return;
                        const h = usage.h ? 1 : 0;
                        const v = usage.v ? 1 : 0;
                        const encoded = h + (v << 1);
                        if (encoded > 0) entries.push([key, encoded]);
                    });
                    entries.sort((a, b) => a[0] - b[0]);
                    return entries.map(([key, usage]) => `${key}:${usage}`).join(',');
                },
                _portalForced(state, l) {
                    const k = state.path[state.path.length - 1];
                    return l.portalMap.has(k) && !state.isJump.has(state.path.length - 1);
                },
                _stateSignature(state, l, realLen) {
                    const posKey = state.path[state.path.length - 1];
                    const portalForced = this._portalForced(state, l) ? 1 : 0;
                    const crossCounts = this._encodeMustCrossCounts(state).toString();
                    const countsSig = this._encodeCounts(state);
                    const usageSig = this._encodeUsage(state);
                    return [
                        posKey,
                        realLen,
                        state.ints,
                        state.mustMask.toString(),
                        state.mustCrossMask ? state.mustCrossMask.toString() : '0',
                        crossCounts,
                        portalForced,
                        state.flipParity,
                        state.flipperCrossMask ? state.flipperCrossMask.toString() : '0',
                        state.flipperParityAtCrossMask ? state.flipperParityAtCrossMask.toString() : '0',
                        countsSig,
                        usageSig
                    ].join('|');
                },
                _crossNeeds(state) {
                    if (!state.mustCrossCounts) return 0;
                    let needs = 0;
                    for (let i = 0; i < state.mustCrossCounts.length; i++) needs += (2 - state.mustCrossCounts[i]);
                    return needs;
                },
                _mustCrossExtraVisitsLowerBound(mask, crossNeed, l) {
                    const outstandingNodes = mask ? l._popcountMask(mask) : 0;
                    const extraVisitsLB = Math.max(0, crossNeed - outstandingNodes);
                    return { outstandingNodes, extraVisitsLB };
                },
                _nearestOutstandingMustCrossDist(key, state, l) {
                    if (!state.mustCrossMask || state.mustCrossMask === 0n) return Infinity;
                    let best = Infinity;
                    for (let i = 0; i < l.mustCrossKeys.length; i++) {
                        const bit = 1n << BigInt(i);
                        if ((state.mustCrossMask & bit) === 0n) continue;
                        const d = l.mustCrossDistMaps[i].get(key);
                        if (d !== undefined && d < best) best = d;
                    }
                    return best;
                },
                _estimateMustCrossBoundFrom(key, state, l) {
                    const mask = state.mustCrossMask;
                    const crossNeed = this._crossNeeds(state);
                    let baseBound;
                    if (!mask || mask === 0n) {
                        baseBound = l.distMapForSolver.get(key) ?? Infinity;
                    } else if (l.mustCrossDpMode === 'exact') {
                        const memoKey = `${key}|${mask.toString()}`;
                        const cached = l.mustCrossKeyMaskCache.get(memoKey);
                        if (cached !== undefined) baseBound = cached;
                        else {
                            let best = Infinity;
                            for (let i = 0; i < l.mustCrossKeys.length; i++) {
                                const bit = 1n << BigInt(i);
                                if ((mask & bit) === 0n) continue;
                                const dToCross = l.mustCrossDistMaps[i].get(key);
                                if (dToCross === undefined) continue;
                                const rest = l.mustCrossDp(mask ^ bit, i);
                                if (rest === Infinity) continue;
                                const total = dToCross + rest;
                                if (total < best) best = total;
                            }
                            l.mustCrossKeyMaskCache.set(memoKey, best);
                            baseBound = best;
                        }
                    } else {
                        let nearest = Infinity;
                        const nodes = [];
                        for (let i = 0; i < l.mustCrossKeys.length; i++) {
                            const bit = 1n << BigInt(i);
                            if ((mask & bit) === 0n) continue;
                            nodes.push(i);
                            const d = l.mustCrossDistMaps[i].get(key);
                            if (d !== undefined && d < nearest) nearest = d;
                        }
                        baseBound = this._mstBoundFromNodes(nodes, l.mustCrossPairDist, l.mustCrossToGoalDist, nearest);
                    }
                    if (baseBound === Infinity) return Infinity;
                    const extraVisitsLB = this._mustCrossExtraVisitsLowerBound(mask, crossNeed, l).extraVisitsLB;
                    return baseBound + extraVisitsLB;
                },
                _hazardDecisionForKey(key, state, l, options = {}) {
                    if (!l.gooseSet.has(key)) return { allowed: true, terminal: false };
                    const policy = options.hazardPolicy || 'forbid';
                    if (policy === 'allow_dead_end') return { allowed: true, terminal: true };
                    return { allowed: false, terminal: true };
                },
                _recordDepth0Prune(debugStats, reason, details) {
                    if (!debugStats || debugStats.depth0) return;
                    debugStats.depth0 = { reason, details };
                },
                _staticNeighborDegree(key, l) {
                    const { w, h } = l.grid;
                    const p = APP.LevelUtils.UNPACK(key);
                    let degree = 0;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                        const nx = p.x + dx, ny = p.y + dy;
                        if (!APP.LevelUtils.inBounds(nx, ny, w, h)) return;
                        const nk = APP.LevelUtils.PACK(nx, ny);
                        if (!l.blockSet.has(nk)) degree++;
                    });
                    if (l.portalMap.has(key)) degree++;
                    return degree;
                },
                _getNeighbors(k, state, distMap, flipperDistMap, usageFreq, l, options, scratch, debugStats = null) {
                    const { w, h } = l.grid;
                    const p = APP.LevelUtils.UNPACK(k);
                    const candidates = [];
                    const portal = resolvePortal(l, k);
                    const portalForced = portal && !state.isJump.has(state.path.length - 1);
                    const portalDest = portal ? portal.dest : -1;
                    if (portalForced && portalDest !== -1) {
                        candidates.push(portalDest);
                    } else {
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            const nx = p.x + dx, ny = p.y + dy;
                            if (APP.LevelUtils.inBounds(nx, ny, w, h)) candidates.push(APP.LevelUtils.PACK(nx, ny));
                        });
                    }
                    const curLen = state.path.length - 1 - state.isJump.size;
                    const hasMust = state.mustMask !== 0n;
                    const crossNeed = this._crossNeeds(state);
                    const mustBoundCache = scratch.mustBoundCache;
                    const crossDistCache = scratch.crossDistCache;
                    const mustCachePrefix = `${state.mustMask.toString()}|`;
                    const crossCachePrefix = `${state.mustCrossMask?.toString() || '0'}|${crossNeed}|`;
                    const getMustBound = (key) => {
                        if (!hasMust) return 0;
                        const cKey = mustCachePrefix + key;
                        if (mustBoundCache.has(cKey)) return mustBoundCache.get(cKey);
                        const bound = this._estimateMustPassBoundFrom(key, state, l);
                        mustBoundCache.set(cKey, bound);
                        return bound;
                    };
                    const getCrossBound = (key) => {
                        if (crossNeed <= 0) return 0;
                        const cKey = crossCachePrefix + key;
                        if (crossDistCache.has(cKey)) return crossDistCache.get(cKey);
                        const b = this._estimateMustCrossBoundFrom(key, state, l);
                        crossDistCache.set(cKey, b);
                        return b;
                    };
                    const valid = candidates.filter(nk => {
                        if (debugStats) debugStats.branchesTried++;
                        if (!this._isMoveValid(nk, state.path, state.counts, state.usage, state.ints, state.isJump, l, state.flipCount, state.crossedFlippers, options)) {
                            if (debugStats) debugStats.prune.illegalMove++;
                            return false;
                        }
                        if (!this._hazardDecisionForKey(nk, state, l, options).allowed) {
                            if (debugStats) debugStats.prune.other++;
                            if (state.path.length === 1) this._recordDepth0Prune(debugStats, 'hazardBlocked', `gooseBlockedAt=${nk}`);
                            return false;
                        }
                        const isP = (portalDest === nk && portalForced);
                        const nLen = curLen + (isP ? 0 : 1);
                        const rSteps = l.reqLen - nLen;
                        const d = distMap.get(nk);
                        if (d === undefined || d > rSteps) {
                            if (debugStats) debugStats.prune.minRemOverflow++;
                            if (state.path.length === 1) this._recordDepth0Prune(debugStats, 'minRemOverflow', `goalDist=${d === undefined ? 'inf' : d} rSteps=${rSteps}`);
                            return false;
                        }
                        if (hasMust) {
                            const bestBound = getMustBound(nk);
                            if (bestBound === Infinity || bestBound > rSteps) {
                                if (debugStats) debugStats.prune.mustPassBound++;
                                if (state.path.length === 1) {
                                    const mustDetails = this._estimateMustPassBoundDetailed(nk, state, l);
                                    this._recordDepth0Prune(debugStats, 'mustPassBound', `mustPassBound=${mustDetails.bound} rSteps=${rSteps} k=${mustDetails.k} method=${mustDetails.method}`);
                                }
                                return false;
                            }
                        }
                        if (crossNeed > 0) {
                            const crossBound = getCrossBound(nk);
                            if (crossBound === Infinity || crossBound > rSteps) {
                                if (debugStats) debugStats.prune.mustCrossBound++;
                                if (state.path.length === 1) {
                                    const { outstandingNodes, extraVisitsLB } = this._mustCrossExtraVisitsLowerBound(state.mustCrossMask, crossNeed, l);
                                    this._recordDepth0Prune(debugStats, 'mustCrossBound', `mustCrossBound=${crossBound} rSteps=${rSteps} extraVisitsLB=${extraVisitsLB} crossNeed=${crossNeed} outstandingNodes=${outstandingNodes}`);
                                }
                                return false;
                            }
                        }
                        return true;
                    });
                    const scored = valid.map(nk => {
                        let score = 0;
                        const mustIdx = l.mustPassIndex ? l.mustPassIndex.get(nk) : undefined;
                        if (mustIdx !== undefined) {
                            const bit = 1n << BigInt(mustIdx);
                            if ((state.mustMask & bit) !== 0n) score -= 1000;
                        }
                        const crossIdx = l.mustCrossIndex ? l.mustCrossIndex.get(nk) : undefined;
                        if (crossIdx !== undefined && state.mustCrossCounts) {
                            const crossCount = state.mustCrossCounts[crossIdx] || 0;
                            if (crossCount < 2) score -= 800;
                        }
                        const mustBound = hasMust ? getMustBound(nk) : 0;
                        const crossBound = crossNeed > 0 ? getCrossBound(nk) : 0;
                        score += (mustBound === Infinity ? 100000 : mustBound * 6);
                        score += (crossBound === Infinity ? 100000 : crossBound * 6);
                        if (crossNeed > 0) score += crossNeed * 2;
                        score += (distMap.get(nk) ?? 999) * 2;
                        score += (usageFreq.get(nk) || 0);
                        score -= this._staticNeighborDegree(nk, l) * 3;
                        return { nk, score };
                    });
                    if (options?.dirOrderVariant === 'random') {
                        scored.sort(() => Math.random() - 0.5);
                    } else {
                        scored.sort((a, b) => {
                            if (a.score !== b.score) return b.score - a.score;
                            return options?.dirOrderVariant === 'alt' ? (a.nk - b.nk) : (b.nk - a.nk);
                        });
                    }
                    return scored.map(item => item.nk);
                },
                _pushState(s, k, isJump, l) {
                    const log = [];
                    const lastK = s.path[s.path.length - 1];
                    if (!isJump) {
                        const lP = APP.LevelUtils.UNPACK(lastK), cP = APP.LevelUtils.UNPACK(k);
                        const axis = (cP.y === lP.y) ? H : V;
                        const prop = axis === H ? 'h' : 'v';
                        let uL = s.usage.get(lastK);
                        if (!uL) {
                            uL = { h: false, v: false };
                            s.usage.set(lastK, uL);
                            log.push({ op: 'new_usage', key: lastK });
                        }
                        if (!uL[prop]) {
                            uL[prop] = true;
                            log.push({ op: 'set_prop', key: lastK, prop: prop });
                        }
                        let uC = s.usage.get(k);
                        if (!uC) {
                            uC = { h: false, v: false };
                            s.usage.set(k, uC);
                            log.push({ op: 'new_usage', key: k });
                        }
                        if (!uC[prop]) {
                            uC[prop] = true;
                            log.push({ op: 'set_prop', key: k, prop: prop });
                        }
                    }
                    const c = s.counts.get(k) || 0;
                    if (c > 0 && k !== l.goalKey && !l.gateKeys.includes(k)) {
                        s.ints++;
                        log.push({ op: 'inc_int' });
                    }
                    if (c === 0) {
                        s.counts.set(k, 1);
                        log.push({ op: 'new_count', key: k });
                    } else {
                        s.counts.set(k, c + 1);
                        log.push({ op: 'inc_count', key: k });
                    }
                    if (c === 0) {
                        const mustIdx = l.mustPassIndex ? l.mustPassIndex.get(k) : undefined;
                        if (mustIdx !== undefined && typeof s.mustMask === "bigint") {
                            const bit = 1n << BigInt(mustIdx);
                            if ((s.mustMask & bit) !== 0n) {
                                s.mustMask &= ~bit;
                                log.push({ op: 'mustmask', bit: bit });
                            }
                        }
                    }
                    if (s.mustCrossCounts && typeof s.mustCrossMask === "bigint") {
                        const crossIdx = l.mustCrossIndex ? l.mustCrossIndex.get(k) : undefined;
                        if (crossIdx !== undefined) {
                            const prev = s.mustCrossCounts[crossIdx];
                            if (prev < 2) {
                                s.mustCrossCounts[crossIdx] = prev + 1;
                                log.push({ op: 'mustcross_inc', idx: crossIdx, prev });
                                if (prev + 1 >= 2) {
                                    const bit = 1n << BigInt(crossIdx);
                                    if ((s.mustCrossMask & bit) !== 0n) {
                                        s.mustCrossMask &= ~bit;
                                        log.push({ op: 'mustcross_mask_clear', bit });
                                    }
                                }
                            }
                        }
                    }
                    s.path.push(k);
                    if (isJump) s.isJump.add(s.path.length - 1);
                    if (l.flippingFilterMap.has(k) && !s.crossedFlippers.has(k)) {
                        s.crossedFlippers.set(k, s.flipCount);
                        const flipIdx = l.flipperIndex ? l.flipperIndex.get(k) : undefined;
                        if (flipIdx !== undefined && typeof s.flipperCrossMask === "bigint" && typeof s.flipParity === "number") {
                            const bit = 1n << BigInt(flipIdx);
                            s.flipperCrossMask |= bit;
                            if (typeof s.flipperParityAtCrossMask === "bigint" && (s.flipParity & 1) === 1) s.flipperParityAtCrossMask |= bit;
                            log.push({ op: 'flipper_mask_set', bit, hadParity: (s.flipParity & 1) === 1 });
                        }
                        s.flipCount++;
                        if (typeof s.flipParity === "number") s.flipParity = s.flipCount % 2;
                        log.push({ op: 'flip_add', key: k });
                    }
                    return log;
                },
                _popState(s, log) {
                    const k = s.path.pop();
                    const idx = s.path.length;
                    if (s.isJump.has(idx)) s.isJump.delete(idx);
                    for (let i = log.length - 1; i >= 0; i--) {
                        const entry = log[i];
                        if (entry.op === 'inc_int') {
                            s.ints--;
                        } else if (entry.op === 'new_count') {
                            s.counts.delete(entry.key);
                        } else if (entry.op === 'inc_count') {
                            s.counts.set(entry.key, s.counts.get(entry.key) - 1);
                        } else if (entry.op === 'set_prop') {
                            const u = s.usage.get(entry.key);
                            if (u) u[entry.prop] = false;
                        } else if (entry.op === 'new_usage') {
                            s.usage.delete(entry.key);
                        } else if (entry.op === 'flip_add') {
                            s.crossedFlippers.delete(entry.key);
                            s.flipCount--;
                            s.flipParity = s.flipCount % 2;
                        } else if (entry.op === 'mustmask') {
                            s.mustMask |= entry.bit;
                        } else if (entry.op === 'mustcross_inc') {
                            s.mustCrossCounts[entry.idx] = entry.prev;
                        } else if (entry.op === 'mustcross_mask_clear') {
                            s.mustCrossMask |= entry.bit;
                        } else if (entry.op === 'flipper_mask_set') {
                            s.flipperCrossMask &= ~entry.bit;
                            if (entry.hadParity) s.flipperParityAtCrossMask &= ~entry.bit;
                        }
                    }
                },
                _checkFinalConstraints(state, l) {
                    for (const k of l.mustPassKeys) if (!state.counts.has(k)) return false;
                    for (const k of l.mustCrossKeys) if ((state.counts.get(k) || 0) < 2) return false;
                    for (const k of l.gooseSet) if (state.counts.has(k)) return false;
                    return true;
                },
                async _solveInstance(startKey, distMap, flipperDistMap, usageFreq, l, options, debugStats = null) {
                    const mustCount = l.mustPassKeys.length;
                    const mustCrossCount = l.mustCrossKeys.length;
                    options = options || {};
                    options.hazardPolicy = options.hazardPolicy || 'forbid';
                    const disabledPruneSet = new Set(options.disabledPrunes || []);
                    const useFailMemo = options.useFailMemo !== false && disabledPruneSet.size === 0;
                    const disableMustPassBound = disabledPruneSet.has('mustPassBound');
                    const disableMustCrossBound = disabledPruneSet.has('mustCrossBound');
                    const state = {
                        path: [startKey],
                        counts: new Map(),
                        usage: new Map(),
                        ints: 0,
                        isJump: new Set(),
                        flipCount: 0,
                        flipParity: 0,
                        crossedFlippers: new Map(),
                        flipperCrossMask: 0n,
                        flipperParityAtCrossMask: 0n,
                        mustMask: mustCount > 0 ? ((1n << BigInt(mustCount)) - 1n) : 0n,
                        mustCrossMask: mustCrossCount > 0 ? ((1n << BigInt(mustCrossCount)) - 1n) : 0n,
                        mustCrossCounts: mustCrossCount > 0 ? new Uint8Array(mustCrossCount) : null
                    };
                    const scratch = { mustBoundCache: new Map(), crossDistCache: new Map() };
                    state.counts.set(startKey, 1);
                    const startMustIdx = l.mustPassIndex ? l.mustPassIndex.get(startKey) : undefined;
                    if (startMustIdx !== undefined) state.mustMask &= ~(1n << BigInt(startMustIdx));
                    const startCrossIdx = l.mustCrossIndex ? l.mustCrossIndex.get(startKey) : undefined;
                    if (startCrossIdx !== undefined && state.mustCrossCounts) {
                        state.mustCrossCounts[startCrossIdx] = 1;
                    }
                    if (l.flippingFilterMap.has(startKey)) {
                        state.crossedFlippers.set(startKey, state.flipCount);
                        const flipIdx = l.flipperIndex ? l.flipperIndex.get(startKey) : undefined;
                        if (flipIdx !== undefined) state.flipperCrossMask |= (1n << BigInt(flipIdx));
                        state.flipCount++;
                        state.flipParity = state.flipCount % 2;
                    }
                    const failMemo = useFailMemo ? new Map() : null;
                    const startNeighbors = this._getNeighbors(startKey, state, distMap, flipperDistMap, usageFreq, l, options, scratch, debugStats);
                    const stack = [{ k: startKey, neighbors: startNeighbors, log: [], sig: this._stateSignature(state, l, 0) }];
                    let steps = 0;
                    while (stack.length > 0) {
                        if (options.signal?.aborted) return SOLVER_ABORTED;
                        if (Date.now() - options.startTime > options.timeLimit) return SOLVER_TIMEOUT;
                        if (++steps % 500 === 0) {
                            await new Promise(r => setTimeout(r, 0));
                            options.onProgress(Date.now() - options.startTime);
                        }
                        const top = stack[stack.length - 1];
                        if (top.neighbors.length === 0) {
                            if (debugStats) debugStats.prune.deadEnd++;
                            if (useFailMemo) failMemo.set(top.sig, true);
                            this._popState(state, top.log);
                            stack.pop();
                            continue;
                        }
                        const nextKey = top.neighbors.pop();
                        if (debugStats) debugStats.nodesExpanded++;
                        const topPortal = resolvePortal(l, top.k);
                        const isP = topPortal && !state.isJump.has(state.path.length - 1) ? topPortal.dest === nextKey : false;
                        const transLog = this._pushState(state, nextKey, isP, l);
                        const lastK = state.path[state.path.length - 1];
                        const hazard = this._hazardDecisionForKey(nextKey, state, l, options);
                        if (!hazard.allowed) {
                            this._popState(state, transLog);
                            continue;
                        }
                        const realLen = state.path.length - 1 - state.isJump.size;
                        if (debugStats && realLen > debugStats.maxDepth) debugStats.maxDepth = realLen;
                        if (realLen > l.reqLen) {
                            if (debugStats) debugStats.prune.lenOverflow++;
                            this._popState(state, transLog);
                            continue;
                        }
                        if (state.ints > l.reqInt) {
                            if (debugStats) debugStats.prune.intsOverflow++;
                            this._popState(state, transLog);
                            continue;
                        }
                        const rSteps = l.reqLen - realLen;
                        if ((l.reqInt - state.ints) > rSteps) {
                            if (debugStats) debugStats.prune.intsOverflow++;
                            this._popState(state, transLog);
                            continue;
                        }
                        const crossNeeds = this._crossNeeds(state);
                        if (crossNeeds > rSteps) {
                            if (debugStats) debugStats.prune.mustCrossBound++;
                            if (state.path.length === 2) this._recordDepth0Prune(debugStats, 'mustCrossNeed', `crossNeeds=${crossNeeds} rSteps=${rSteps}`);
                            this._popState(state, transLog);
                            continue;
                        }
                        if (!disableMustPassBound && state.mustMask !== 0n) {
                            const mustDetails = this._estimateMustPassBoundDetailed(lastK, state, l);
                            const mustBound = mustDetails.bound;
                            if (mustBound === Infinity || mustBound > rSteps) {
                                if (debugStats) debugStats.prune.mustPassBound++;
                                if (state.path.length === 2) this._recordDepth0Prune(debugStats, 'mustPassBound', `mustPassBound=${mustBound} rSteps=${rSteps} k=${mustDetails.k} method=${mustDetails.method}`);
                                this._popState(state, transLog);
                                continue;
                            }
                        }
                        if (!disableMustCrossBound && state.mustCrossMask !== 0n) {
                            const crossBound = this._estimateMustCrossBoundFrom(lastK, state, l);
                            if (crossBound === Infinity || crossBound > rSteps) {
                                if (debugStats) debugStats.prune.mustCrossBound++;
                                if (state.path.length === 2) {
                                    const { outstandingNodes, extraVisitsLB } = this._mustCrossExtraVisitsLowerBound(state.mustCrossMask, crossNeeds, l);
                                    this._recordDepth0Prune(debugStats, 'mustCrossBound', `mustCrossBound=${crossBound === Infinity ? 'inf' : crossBound} rSteps=${rSteps} extraVisitsLB=${extraVisitsLB} crossNeed=${crossNeeds} outstandingNodes=${outstandingNodes}`);
                                }
                                this._popState(state, transLog);
                                continue;
                            }
                        }
                        if (lastK === l.goalKey) {
                            if (realLen === l.reqLen && state.ints === l.reqInt) {
                                if (this._checkFinalConstraints(state, l)) return { path: state.path.slice(), len: realLen };
                            }
                            this._popState(state, transLog);
                            continue;
                        }
                        const minRem = distMap.get(lastK) || Infinity;
                        if (realLen + minRem > l.reqLen) {
                            if (debugStats) debugStats.prune.minRemOverflow++;
                            if (state.path.length === 2) this._recordDepth0Prune(debugStats, 'minRemOverflow', `minRem=${minRem} realLen=${realLen} reqLen=${l.reqLen}`);
                            this._popState(state, transLog);
                            continue;
                        }
                        const sig = this._stateSignature(state, l, realLen);
                        if (useFailMemo && failMemo.has(sig)) {
                            if (debugStats) debugStats.prune.failedStateHit++;
                            this._popState(state, transLog);
                            continue;
                        }
                        if (hazard.terminal) {
                            if (debugStats) debugStats.prune.deadEnd++;
                            this._popState(state, transLog);
                            continue;
                        }
                        const neighbors = this._getNeighbors(nextKey, state, distMap, flipperDistMap, usageFreq, l, options, scratch, debugStats);
                        stack.push({ k: nextKey, neighbors, log: transLog, sig });
                    }
                    if (debugStats) debugStats.memoSize = useFailMemo ? failMemo.size : 0;
                    return null;
                },
                async _solveTrapSpots(startKey, l, validSpotsSet, options) {
                    options = options || {};
                    options.hazardPolicy = options.hazardPolicy || 'forbid';
                    const { w, h } = l.grid;
                    const state = { path: [startKey], counts: new Map(), usage: new Map(), ints: 0, isJump: new Set(), flipCount: 0, crossedFlippers: new Map() };
                    state.counts.set(startKey, 1);
                    if (l.flippingFilterMap.has(startKey)) {
                        state.crossedFlippers.set(startKey, state.flipCount);
                        state.flipCount++;
                    }
                    const getNeighbors = (k, s) => {
                        const p = APP.LevelUtils.UNPACK(k);
                        let candidates = [];
                        const portal = resolvePortal(l, k);
                        if (portal && !s.isJump.has(s.path.length - 1)) candidates.push(portal.dest);
                        else [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            const nx = p.x + dx, ny = p.y + dy;
                            if (APP.LevelUtils.inBounds(nx, ny, w, h)) candidates.push(APP.LevelUtils.PACK(nx, ny));
                        });
                        return candidates.filter(nk => this._isMoveValid(nk, s.path, s.counts, s.usage, s.ints, s.isJump, l, s.flipCount, s.crossedFlippers, options) && this._hazardDecisionForKey(nk, s, l, options).allowed);
                    };
                    const stack = [{ k: startKey, neighbors: getNeighbors(startKey, state), log: [] }];
                    let steps = 0;
                    while (stack.length > 0) {
                        if (options.signal?.aborted) throw new DOMException("Aborted", "AbortError");
                        if (Date.now() - options.startTime > options.timeLimit) return;
                        if (++steps % 500 === 0) {
                            await new Promise(r => setTimeout(r, 0));
                            options.onProgress(Date.now() - options.startTime);
                        }
                        const top = stack[stack.length - 1];
                        if (top.neighbors.length === 0) {
                            this._popState(state, top.log);
                            stack.pop();
                            continue;
                        }
                        const nextKey = top.neighbors.pop();
                        const topPortal = resolvePortal(l, top.k);
                        const isP = topPortal && !state.isJump.has(state.path.length - 1) ? topPortal.dest === nextKey : false;
                        const transLog = this._pushState(state, nextKey, isP, l);
                        const hazard = this._hazardDecisionForKey(nextKey, state, l, options);
                        if (!hazard.allowed) {
                            this._popState(state, transLog);
                            continue;
                        }
                        const realLen = state.path.length - 1 - state.isJump.size;
                        if (realLen > l.reqLen) {
                            this._popState(state, transLog);
                            continue;
                        }
                        if (realLen === l.reqLen) {
                            if (state.ints === l.reqInt && this._checkFinalConstraints(state, l)) validSpotsSet.add(nextKey);
                            this._popState(state, transLog);
                            continue;
                        }
                        if (hazard.terminal) {
                            this._popState(state, transLog);
                            continue;
                        }
                        stack.push({ k: nextKey, neighbors: getNeighbors(nextKey, state), log: transLog });
                    }
                }
            };

        const PathfinderSolver = {
                async solve(level, options = {}) {
                    const { timeLimit = 105000, maxSolutions = 5, onProgress = () => {}, onStateUpdate = () => {}, signal = null, hazardPolicy = 'forbid', debug = false, debugLevel = null, dirOrderVariant = 'default', disabledPrunes = null } = options;
                    const startTime = Date.now();
                    const perfStart = performance.now();
                    const foundSolutions = [];
                    const validity = APP.Editor.validateLevelDetailed(level);
                    const debugStats = debug ? createSolverDebugStats(debugLevel ?? ((typeof level.id === "number") ? level.id + 1 : null)) : null;
                    foundSolutions.timedOut = false;
                    if (!validity.ok) {
                        if (debugStats) {
                            debugStats.invalidReasons = validity.reasons || [];
                            appendReachabilitySanityNote(level, debugStats, "invalid");
                            finalizeSolverDebugStats(debugStats, "invalid", perfStart);
                            return { ok: false, solution: null, debug: debugStats };
                        }
                        return [];
                    }
                    if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
                    onStateUpdate("Analyzing Bipartite Parity...");

                    const distMap = SolverCore._buildDistMap(level);
                    level.distMapForSolver = distMap;
                    level.mustPassIndex = new Map();
                    level.mustPassDistMaps = [];
                    level.mustPassToGoalDist = [];
                    level.mustPassPairDist = [];
                    level.mustPassKeyMaskCache = new Map();
                    level.mustPassDpMode = 'none';
                    level.mustPassDp = () => Infinity;

                    if (level.mustPassKeys.length > 0) {
                        for (let i = 0; i < level.mustPassKeys.length; i++) {
                            const mustKey = level.mustPassKeys[i];
                            level.mustPassIndex.set(mustKey, i);
                            level.mustPassDistMaps.push(SolverCore._buildOptimisticDistMap(level, [mustKey]));
                            level.mustPassToGoalDist.push(distMap.get(mustKey) ?? Infinity);
                        }
                        const n = level.mustPassKeys.length;
                        level.mustPassPairDist = Array.from({ length: n }, () => Array(n).fill(Infinity));
                        for (let i = 0; i < n; i++) {
                            level.mustPassPairDist[i][i] = 0;
                            for (let j = i + 1; j < n; j++) {
                                const d = level.mustPassDistMaps[i].get(level.mustPassKeys[j]);
                                const val = d === undefined ? Infinity : d;
                                level.mustPassPairDist[i][j] = val;
                                level.mustPassPairDist[j][i] = val;
                            }
                        }
                        if (n <= 7) {
                            level.mustPassDpMode = 'exact';
                            const dpMemo = new Map();
                            level.mustPassDp = (mask, lastIdx) => {
                                if (mask === 0n) return level.mustPassToGoalDist[lastIdx];
                                const key = `${mask.toString()}|${lastIdx}`;
                                const cached = dpMemo.get(key);
                                if (cached !== undefined) return cached;
                                let best = Infinity;
                                for (let nxt = 0; nxt < n; nxt++) {
                                    const bit = 1n << BigInt(nxt);
                                    if ((mask & bit) === 0n) continue;
                                    const d = level.mustPassPairDist[lastIdx][nxt];
                                    if (d === Infinity) continue;
                                    const rest = level.mustPassDp(mask ^ bit, nxt);
                                    if (rest === Infinity) continue;
                                    const total = d + rest;
                                    if (total < best) best = total;
                                }
                                dpMemo.set(key, best);
                                return best;
                            };
                        }
                    }

                    level.mustCrossIndex = new Map();
                    level.mustCrossDistMaps = [];
                    level.mustCrossToGoalDist = [];
                    level.mustCrossPairDist = [];
                    level.mustCrossKeyMaskCache = new Map();
                    level.mustCrossDpMode = 'none';
                    level.mustCrossDp = () => Infinity;
                    if (level.mustCrossKeys.length > 0) {
                        for (let i = 0; i < level.mustCrossKeys.length; i++) {
                            const crossKey = level.mustCrossKeys[i];
                            level.mustCrossIndex.set(crossKey, i);
                            level.mustCrossDistMaps.push(SolverCore._buildOptimisticDistMap(level, [crossKey]));
                            level.mustCrossToGoalDist.push(distMap.get(crossKey) ?? Infinity);
                        }
                        const n = level.mustCrossKeys.length;
                        level.mustCrossPairDist = Array.from({ length: n }, () => Array(n).fill(Infinity));
                        for (let i = 0; i < n; i++) {
                            level.mustCrossPairDist[i][i] = 0;
                            for (let j = i + 1; j < n; j++) {
                                const d = level.mustCrossDistMaps[i].get(level.mustCrossKeys[j]);
                                const val = d === undefined ? Infinity : d;
                                level.mustCrossPairDist[i][j] = val;
                                level.mustCrossPairDist[j][i] = val;
                            }
                        }
                        if (n <= 6) {
                            level.mustCrossDpMode = 'exact';
                            const dpMemo = new Map();
                            level.mustCrossDp = (mask, lastIdx) => {
                                if (mask === 0n) return level.mustCrossToGoalDist[lastIdx];
                                const key = `${mask.toString()}|${lastIdx}`;
                                const cached = dpMemo.get(key);
                                if (cached !== undefined) return cached;
                                let best = Infinity;
                                for (let nxt = 0; nxt < n; nxt++) {
                                    const bit = 1n << BigInt(nxt);
                                    if ((mask & bit) === 0n) continue;
                                    const d = level.mustCrossPairDist[lastIdx][nxt];
                                    if (d === Infinity) continue;
                                    const rest = level.mustCrossDp(mask ^ bit, nxt);
                                    if (rest === Infinity) continue;
                                    const total = d + rest;
                                    if (total < best) best = total;
                                }
                                dpMemo.set(key, best);
                                return best;
                            };
                        }
                    }

                    level._popcountMask = (mask) => {
                        let count = 0;
                        let m = mask;
                        while (m !== 0n) {
                            count += Number(m & 1n);
                            m >>= 1n;
                        }
                        return count;
                    };

                    level.flipperIndex = new Map();
                    let fIdx = 0;
                    level.flippingFilterMap.forEach((_, k) => level.flipperIndex.set(k, fIdx++));

                    const flipperSet = new Set();
                    level.portalMap.forEach((v, k) => {
                        const p1 = APP.LevelUtils.UNPACK(k), p2 = APP.LevelUtils.UNPACK(v.dest);
                        if (((p1.x + p1.y) % 2) !== ((p2.x + p2.y) % 2)) flipperSet.add(k);
                    });
                    const flipperDistMap = SolverCore._buildFlipperDistMap(level, flipperSet);

                    const gatePruneReasons = [];
                    const validGates = level.gateKeys.filter(gk => {
                        const gateReasons = [];
                        const d = distMap.get(gk);
                        if (d === undefined || d > level.reqLen) gateReasons.push(`distance:${d === undefined ? 'inf' : d}>${level.reqLen}`);
                        if (gateReasons.length > 0) {
                            gatePruneReasons.push(`${gk}=>${gateReasons.join(',')}`);
                            return false;
                        }
                        return true;
                    });
                    if (validGates.length === 0) {
                        if (debugStats) {
                            debugStats.prune.other++;
                            const suffix = gatePruneReasons.length ? ` (${gatePruneReasons.join('; ')})` : '';
                            if (!debugStats.depth0) debugStats.depth0 = { reason: "noViableGate", details: `all gates pruned by safe bounds${suffix}` };
                            appendReachabilitySanityNote(level, debugStats, "no-solution");
                            finalizeSolverDebugStats(debugStats, "no-solution", perfStart);
                            return { ok: false, solution: null, debug: debugStats };
                        }
                        return [];
                    }

                    const runSolvePass = async ({ passName, localTimeLimit, disabledPrunes = [], useFailMemo = true, statusLabel = null }) => {
                        const passSolutions = [];
                        passSolutions.timedOut = false;
                        let passCellUsageFreq = new Map();
                        if (level.hints && level.hints.length > 0) {
                            level.hints.forEach(path => path.forEach(k => passCellUsageFreq.set(k, (passCellUsageFreq.get(k) || 0) + 1)));
                        }
                        const shuffledGates = validGates.slice();
                        if (dirOrderVariant === 'alt') shuffledGates.reverse();
                        else shuffledGates.sort(() => Math.random() - 0.5);
                        if (debugStats) {
                            debugStats.pass = passName;
                            debugStats.disabledPrunes = disabledPrunes.slice();
                            debugStats.failMemoUsed = useFailMemo && disabledPrunes.length === 0;
                        }
                        onStateUpdate(statusLabel || `Solving (${shuffledGates.length} viable gates)...`);
                        for (const gateKey of shuffledGates) {
                            if (passSolutions.length >= maxSolutions) break;
                            await new Promise(r => setTimeout(r, 0));
                            const internalOpts = {
                                timeLimit: localTimeLimit,
                                dirOrderVariant,
                                startTime,
                                onProgress,
                                signal,
                                hazardPolicy,
                                disabledPrunes,
                                useFailMemo
                            };
                            const result = await SolverCore._solveInstance(gateKey, distMap, flipperDistMap, passCellUsageFreq, level, internalOpts, debugStats);
                            if (result === SOLVER_ABORTED) {
                                if (debugStats) {
                                    finalizeSolverDebugStats(debugStats, "aborted", perfStart);
                                    return { kind: "aborted", solutions: null };
                                }
                                throw new DOMException("Aborted", "AbortError");
                            }
                            if (result === SOLVER_TIMEOUT) {
                                passSolutions.timedOut = true;
                                if (debugStats) {
                                    finalizeSolverDebugStats(debugStats, "timeout", perfStart);
                                    return { kind: "timeout", solutions: null };
                                }
                                break;
                            }
                            if (result) {
                                const solStr = JSON.stringify(result.path);
                                if (!passSolutions.some(s => JSON.stringify(s.path) === solStr)) {
                                    passSolutions.push(result);
                                    result.path.forEach(k => passCellUsageFreq.set(k, (passCellUsageFreq.get(k) || 0) + 1));
                                }
                            }
                        }
                        return { kind: "ok", solutions: passSolutions };
                    };

                    const primaryRun = await runSolvePass({ passName: "primary", localTimeLimit: timeLimit, disabledPrunes: disabledPrunes || [], useFailMemo: !disabledPrunes });
                    if (primaryRun.kind === "aborted") return { ok: false, solution: null, debug: debugStats };
                    if (primaryRun.kind === "timeout") return { ok: false, solution: null, debug: debugStats };

                    foundSolutions.push(...(primaryRun.solutions || []));
                    foundSolutions.timedOut = !!primaryRun.solutions?.timedOut;

                    const goalReachable = isGoalReachableFromAnyGate(level);
                    const primarySolved = foundSolutions.length > 0;
                    const primaryStatus = primarySolved ? "solved" : (foundSolutions.timedOut ? "timeout" : "no-solution");

                    if (debugStats && !primarySolved && primaryStatus === "no-solution") {
                        appendReachabilitySanityNote(level, debugStats, primaryStatus, goalReachable);
                    }

                    if (debugStats && !primarySolved && primaryStatus === "no-solution" && goalReachable) {
                        const primaryPruneSnapshot = {
                            mustPassBound: debugStats.prune.mustPassBound || 0,
                            mustCrossBound: debugStats.prune.mustCrossBound || 0,
                            failedStateHit: debugStats.prune.failedStateHit || 0,
                            minRemOverflow: debugStats.prune.minRemOverflow || 0,
                            deadEnd: debugStats.prune.deadEnd || 0
                        };
                        debugStats.notes.push("SANITY PASS: retrying with memo disabled and mustPass/mustCross bounds disabled.");
                        const diagnosticBudget = Math.min(Math.max(Math.floor(timeLimit * 0.25), 2000), 5000);
                        const sanityRun = await runSolvePass({
                            passName: "sanity-pass",
                            localTimeLimit: diagnosticBudget,
                            disabledPrunes: ["mustPassBound", "mustCrossBound"],
                            useFailMemo: false,
                            statusLabel: `Sanity pass (${validGates.length} viable gates)...`
                        });
                        if (sanityRun.kind === "aborted") return { ok: false, solution: null, debug: debugStats };
                        if (sanityRun.kind === "timeout") return { ok: false, solution: null, debug: debugStats };
                        if ((sanityRun.solutions || []).length > 0) {
                            foundSolutions.length = 0;
                            foundSolutions.push(...sanityRun.solutions);
                            debugStats.notes.push("SANITY OVERRIDE: Solution found only after disabling memo/bounds. Original pruning/memo likely incorrect.");
                            debugStats.notes.push(`LIKELY CULPRIT: mustPassBound and/or failMemo (primary prunes: mustPassBound=${primaryPruneSnapshot.mustPassBound} mustCrossBound=${primaryPruneSnapshot.mustCrossBound} failedStateHit=${primaryPruneSnapshot.failedStateHit} minRemOverflow=${primaryPruneSnapshot.minRemOverflow} deadEnd=${primaryPruneSnapshot.deadEnd})`);
                        } else {
                            debugStats.notes.push("SANITY CONFIRMED: Reachable but still no strict solution under relaxed pruning; likely truly unsat given constraints.");
                        }
                    }

                    if (debugStats) {
                        const solved = foundSolutions.length > 0;
                        const status = solved ? "solved" : (foundSolutions.timedOut ? "timeout" : "no-solution");
                        if (status === "no-solution" && !(debugStats.notes || []).some(n => n.startsWith("SANITY:"))) {
                            appendReachabilitySanityNote(level, debugStats, status, goalReachable);
                        }
                        finalizeSolverDebugStats(debugStats, status, perfStart);
                        return { ok: solved, solution: solved ? foundSolutions : null, debug: debugStats };
                    }
                    return foundSolutions;
                },
                async findTrapSpots(level, options = {}) {
                    const { timeLimit = 8000, onProgress = () => {}, onStateUpdate = () => {}, signal = null, hazardPolicy = 'forbid' } = options;
                    const startTime = Date.now();
                    const validSpots = new Set();
                    if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
                    onStateUpdate(`Mapping Traps (${level.gateKeys.length} gates)...`);
                    for (const gateKey of level.gateKeys) {
                        await new Promise(r => setTimeout(r, 0));
                        const internalOpts = { timeLimit, startTime, onProgress, signal, hazardPolicy };
                        await SolverCore._solveTrapSpots(gateKey, level, validSpots, internalOpts);
                        if (Date.now() - startTime > timeLimit) break;
                    }
                    return validSpots;
                }
            };

        const normalizeSolutionEntries = (solutionLike) => {
            const isPathEntry = (v) => !!v && typeof v === 'object' && Array.isArray(v.path);
            if (isPathEntry(solutionLike)) return [{ path: solutionLike.path }];
            if (!Array.isArray(solutionLike)) return [];

            const treatAsSingleRawPath = solutionLike.length > 0
                && !isPathEntry(solutionLike[0])
                && !Array.isArray(solutionLike[0]);
            const entries = treatAsSingleRawPath ? [solutionLike] : solutionLike;

            const normalized = [];
            for (const entry of entries) {
                if (isPathEntry(entry)) normalized.push({ path: entry.path });
                else if (Array.isArray(entry)) normalized.push({ path: entry });
            }
            return normalized.filter(sol => Array.isArray(sol.path) && sol.path.length > 0);
        };

        const applyCanonicalSolutionShape = (result) => {
            if (!result || typeof result !== 'object') return result;
            const canonical = normalizeSolutionEntries(result.solution ?? result.solutions ?? []);
            result.solution = canonical;
            result.solutions = canonical;
            return result;
        };

        const Referee = {
        allocateStageBudgets(totalMs) {
            const total = Math.max(1000, Math.floor(totalMs || 15000));
            const stage0 = Math.min(Math.floor(total * 0.2), Math.max(500, total - 3500));
            const stage1 = Math.min(Math.floor(total * 0.4), Math.max(1500, total - stage0 - 2000));
            const stage2 = Math.min(Math.floor(total * 0.2), Math.max(1000, total - stage0 - stage1 - 500));
            const stage3 = Math.max(500, total - stage0 - stage1 - stage2);
            return { stage0, stage1, stage2, stage3, total };
        },

        async runBaselineStage(level, budgetMs, opts = {}) {
            const started = Date.now();
            const r = await PathfinderSolver.solve(level, {
                timeLimit: budgetMs,
                debug: true,
                debugLevel: (typeof level.id === 'number' ? level.id + 1 : null),
                dirOrderVariant: (opts.dirOrderVariant === 'alt' || opts.dirOrderVariant === 'random') ? opts.dirOrderVariant : 'default'
            });
            const elapsedMs = Date.now() - started;
            const solution = normalizeSolutionEntries(r?.solution ?? r?.solutions ?? []);
            if (r?.ok && solution.length > 0) {
                return { ok: true, status: 'solved', solution, solutions: solution, elapsedMs, stats: { debug: r.debug } };
            }
            const debug = r?.debug || {};
            const rawStatus = debug.status === 'timeout' ? 'timeout' : (debug.status === 'no-solution' ? normalizeNoSolutionStatus(debug) : 'error');
            return { ok: false, status: rawStatus, elapsedMs, stats: { debug } };
        },

        async runStage2Fallback(level, budgetMs) {
            const started = Date.now();
            const r = await PathfinderSolver.solve(level, {
                timeLimit: budgetMs,
                debug: true,
                debugLevel: (typeof level.id === 'number' ? level.id + 1 : null),
                disabledPrunes: ['mustPassBound', 'mustCrossBound']
            });
            const elapsedMs = Date.now() - started;
            const solution = normalizeSolutionEntries(r?.solution ?? r?.solutions ?? []);
            if (r?.ok && solution.length > 0) {
                return { ok: true, status: 'solved', solution, solutions: solution, elapsedMs, stats: { debug: r.debug } };
            }
            const debug = r?.debug || {};
            if (debug.status === 'timeout') return { ok: false, status: 'timeout', elapsedMs, stats: { debug } };
            return { ok: false, status: 'no-solution-inconclusive', elapsedMs, stats: { debug } };
        },

        async solve(levelInput, opts = {}) {
            const level = levelInput.gateKeys ? levelInput : APP.LevelUtils.normalizeLevel(levelInput.id ?? APP.State.ENGINE.levelIdx);
            const purpose = opts.purpose || 'solve';
            const defaultBudget = purpose === 'hint' ? 5000 : 15000;
            const key = getLevelAttemptKey(level, purpose);
            const prev = attemptHistory[key] || { timesTried: 0, lastStageReached: -1, lastStatus: null };
            const timesTried = prev.timesTried + 1;
            const escalated = timesTried > 1 && ['timeout', 'no-solution-inconclusive'].includes(prev.lastStatus);
            const requestedBudget = opts.timeBudgetMs || defaultBudget;
            const budgetMs = escalated
                ? (purpose === 'hint' ? Math.max(requestedBudget, 15000) : Math.max(requestedBudget, 60000))
                : requestedBudget;
            const { stage0, stage1, stage2, stage3 } = this.allocateStageBudgets(budgetMs);

            const stagesTried = [];
            let stageOrder = [0, 1, 2, 3];
            if (opts.variant === 'beamFirst') stageOrder = [0, 2, 3, 1];
            if (escalated || opts.variant === 'altOrder') stageOrder = [1, 2, 0, 3];
            const allowGemini = !!opts.allowGemini;

            const markStage = (stage, name, variant, budget, startedAt, result) => {
                stagesTried.push({ stage, name, variant, budgetMs: budget, elapsedMs: Date.now() - startedAt, result: toStageResultStatus(result?.status) });
            };

            let last = { ok: false, status: 'timeout', stage: -1, message: 'No solution found.', stagesTried };

            for (const stage of stageOrder) {
                if (APP.State.ENGINE.activeSolverController?.signal?.aborted) {
                    last = { ok: false, status: 'cancelled', stage, message: 'Solver cancelled.', stagesTried };
                    break;
                }
                if (stage === 0) {
                    if (opts.onStage) opts.onStage({ stage: 0, name: 'Stage 0', variant: 'default', budgetMs: stage0 });
                    const t0 = Date.now();
                    const r0 = await this.runBaselineStage(level, stage0, { dirOrderVariant: 'default' });
                    markStage(0, 'Stage 0', 'default', stage0, t0, r0);
                    last = { ...r0, stage: 0, message: r0.ok ? 'Solved (fast pass).' : (r0.status === 'timeout' ? 'Search timed out.' : 'No solution found in fast pass.'), stagesTried };
                    if (r0.ok || r0.status === 'no-solution-proven') break;
                }
                if (stage === 1) {
                    if (opts.onStage) opts.onStage({ stage: 1, name: 'Stage 1', variant: 'altOrder', budgetMs: stage1 });
                    const t1 = Date.now();
                    const r1 = await this.runBaselineStage(level, stage1, { dirOrderVariant: 'alt' });
                    markStage(1, 'Stage 1', 'altOrder', stage1, t1, r1);
                    last = { ...r1, stage: 1, message: r1.ok ? 'Solved (alternate ordering).' : (r1.status === 'timeout' ? 'Alternate ordering timed out.' : 'Alternate ordering did not find a solution.'), stagesTried };
                    if (r1.ok || r1.status === 'no-solution-proven') break;
                }
                if (stage === 2) {
                    if (opts.onStage) opts.onStage({ stage: 2, name: 'Stage 2', variant: 'shuffle', budgetMs: stage2 });
                    const t2 = Date.now();
                    const r2 = await this.runBaselineStage(level, stage2, { dirOrderVariant: 'random' });
                    markStage(2, 'Stage 2', 'shuffle', stage2, t2, r2);
                    last = { ...r2, stage: 2, message: r2.ok ? 'Solved (randomized ordering).' : (r2.status === 'timeout' ? 'Randomized ordering timed out.' : 'Randomized ordering did not find a solution.'), stagesTried };
                    if (r2.ok || r2.status === 'no-solution-proven') break;
                }
                if (stage === 3) {
                    if (opts.onStage) opts.onStage({ stage: 3, name: 'Stage 3', variant: 'fallback', budgetMs: stage3 });
                    const t3 = Date.now();
                    const r3 = await this.runStage2Fallback(level, stage3);
                    markStage(3, 'Stage 3', 'fallback', stage3, t3, r3);
                    last = { ...r3, stage: 3, message: r3.ok ? 'Solved (fallback strategy).' : (r3.status === 'timeout' ? 'Fallback strategy timed out.' : 'Fallback strategy inconclusive.'), stagesTried };
                    if (r3.ok) break;
                }
            }

            if (!last.ok && allowGemini && last.status !== 'no-solution-proven') {
                if (opts.onStage) opts.onStage({ stage: 4, name: 'Stage 4', variant: 'gemini', budgetMs: 15000 });
                const t4 = Date.now();
                const gem = await requestGeminiSolverSuggestion(level, purpose, timesTried, 15000);
                if (gem.ok) {
                    const validation = validateCandidatePath(level, gem.candidate);
                    if (validation.ok) {
                        last = { ok: true, status: 'solved', stage: 4, solution: [{ path: validation.path }], solutions: [{ path: validation.path }], stats: { notes: gem.notes || '' }, message: 'Solved (Gemini + validator).', stagesTried };
                    } else {
                        last = { ok: false, status: 'gemini-invalid', stage: 4, stats: { reason: validation.reason }, message: `Gemini candidate failed validation: ${validation.reason}`, stagesTried };
                    }
                } else {
                    last = { ok: false, status: 'gemini-failed', stage: 4, stats: { reason: gem.reason, details: gem.details || null }, message: `Gemini failed: ${gem.reason}`, stagesTried };
                }
                stagesTried.push({ stage: 4, name: 'Stage 4', variant: 'gemini', budgetMs: 15000, elapsedMs: Date.now() - t4, result: toStageResultStatus(last.status) });
            }

            if (last.ok || last.status === 'no-solution-proven') delete attemptHistory[key];
            else attemptHistory[key] = { timesTried, lastStageReached: last.stage, lastStatus: last.status };

            applyCanonicalSolutionShape(last);
            last.retrySuggested = !last.ok && ['timeout', 'no-solution-inconclusive'].includes(last.status);
            last.usedEscalation = escalated;
            last.budgetMs = budgetMs;
            return last;
        }
    };

        const Mega = {
        active: false,
        results: {},
        meta: {},
        getFailedLevels() {
            return Object.entries(this.meta)
                .filter(([, m]) => !['solved', 'no-solution-proven'].includes(m.status))
                .map(([lvl]) => Number(lvl));
        },
        updateSummary() {
            const values = Object.values(this.meta || {});
            const solved = values.filter(v => v.status === 'solved').length;
            const timeout = values.filter(v => v.status === 'timeout').length;
            const inconclusive = values.filter(v => v.status === 'no-solution-inconclusive').length;
            const proven = values.filter(v => v.status === 'no-solution-proven').length;
            const errors = values.filter(v => ['error', 'cancelled', 'gemini-invalid', 'gemini-failed'].includes(v.status)).length;
            APP.UI.setModalContent('megaSummary', `Solved: ${solved} | Timeout: ${timeout} | Inconclusive: ${inconclusive} | Proven Unsat: ${proven} | Error: ${errors}`, 'text');
        },
        appendOutput(line) { APP.UI.appendMegaOutputLine(line); },
        setProgress(text) {
            APP.UI.openModal('megaStatus');
            APP.UI.setModalContent('megaStatus', text, 'text');
            APP.UI.setStatus(text, 'info');
        },
        clearProgress() {
            APP.UI.closeModal('megaStatus');
            APP.UI.setModalContent('megaStatus', '', 'text');
        },
        async run() { return this.runTargets({ targets: null, timeLimitMs: 15000, variant: 'default', allowGemini: false }); },
        async runTargets({ targets = null, timeLimitMs = 15000, variant = 'default', allowGemini = false }) {
            if (this.active || APP.Solver.isRunning()) return;
            const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS;
            if (!targets) { this.results = {}; this.meta = {}; APP.UI.setMegaOutput(''); }
            const toRun = targets || levels.map((_, i) => i + 1).filter(i => !levels[i - 1].hints || levels[i - 1].hints.length === 0);
            if (toRun.length === 0) {
                showMessage('All levels have hints!', 'text-green-600');
                return;
            }
            this.active = true;
            showMessage(allowGemini ? 'Mega Gemini attempt started…' : (targets ? `Mega retry started (${Math.round(timeLimitMs / 1000)}s)…` : 'Mega solver started…'), 'text-sky-600');
            const orig = document.getElementById('megaSolverBtn')?.innerText || 'Mega Solver';
            APP.UI.setButtonState('megaSolverBtn', { enabled: false });

            try {
                await APP.Solver.megaSolve(levels, {
                    targets: toRun,
                    timeLimitMs,
                    variant,
                    allowGemini,
                    results: this.results,
                    meta: this.meta,
                    onProgress: ({ index, total, lvlNum, attempt }) => {
                        this.setProgress(`MEGA ${index + 1}/${total} • Level ${lvlNum} • Attempt ${attempt}`);
                    },
                    onLevelResult: ({ lvlNum, attempt, res, timeLimitMs: budgetMs }) => {
                        const stagesText = (res.stagesTried || []).map(st => `${st.name}/${st.variant}:${st.result}@${st.elapsedMs}ms`).join(' | ');
                        this.appendOutput(`/* Level ${lvlNum} | status=${res.status} | attempts=${attempt} | lastBudgetMs=${budgetMs} | lastStage=${res.stage} */`);
                        this.appendOutput(`/* stages: ${stagesText || 'none'} */`);
                        if (res.ok) this.appendOutput(JSON.stringify(this.results[lvlNum]));
                        else {
                            this.appendOutput(`FAIL: ${res.message}${res.stats?.reason ? ` (${res.stats.reason})` : ''}`);
                            if (res.status === 'gemini-failed' && res.stats?.details) {
                                this.appendOutput(`FAIL_DETAIL: ${JSON.stringify(res.stats.details)}`);
                            }
                        }
                        this.appendOutput('');
                        this.updateSummary();
                    }
                });
            } finally {
                APP.Engine.setOverlayState(OVERLAY_NONE);
                this.clearProgress();
                this.showReport();
                this.active = false;
                APP.UI.setButtonLabel('megaSolverBtn', orig);
                APP.UI.setButtonState('megaSolverBtn', { enabled: true });
                showMessage('Mega solver finished…', 'text-emerald-600');
            }
        },
        async retryFailed({ timeLimitMs = 60000, variant = 'default' }) {
            const failed = this.getFailedLevels();
            if (!failed.length) {
                showMessage('Mega retry: no failed levels.', 'text-emerald-600');
                return;
            }
            return this.runTargets({ targets: failed, timeLimitMs, variant, allowGemini: false });
        },
        async askGeminiForFailed() {
            const failed = this.getFailedLevels();
            if (!failed.length) {
                showMessage('No failed levels eligible for Gemini (only proven-unsat remain).', 'text-emerald-600');
                return;
            }
            return this.runTargets({ targets: failed, timeLimitMs: 15000, variant: 'default', allowGemini: true });
        },
        showReport() { this.updateSummary(); APP.UI.openModal('megaModal'); }
    };

        const startRun = ({ label = 'Solve search running…', mode = 'solve' } = {}) => {
            if (APP.State.ENGINE.activeSolverController) return null;
            APP.State.ENGINE.activeSolverController = new AbortController();
            APP.State.ENGINE.solverAbortRequested = false;
            APP.Engine.setOverlayState(SOLVER_RUNNING);
            runStart = Date.now();
            status = { running: true, mode, startedAt: runStart };
            APP.UI.setModalContent('searchLabel', label, 'text');
            APP.UI.setSolverTimerText('0.0s');
            timerTick = setInterval(() => {
                APP.UI.setSolverTimerText(((Date.now() - runStart) / 1000).toFixed(1) + 's');
            }, 100);
            return APP.State.ENGINE.activeSolverController;
        };

        const finishRun = () => {
            if (timerTick) clearInterval(timerTick);
            timerTick = null;
            APP.State.ENGINE.activeSolverController = null;
            status = { running: false, mode: null, startedAt: 0 };
            APP.State.ENGINE.solverAbortRequested = false;
            APP.Engine.setOverlayState(OVERLAY_NONE);
            APP.UI.setButtonState('solverCloseBtn', { enabled: true });
        };

        const applySolutionsToEngine = (solutionEntries, purpose = 'solve') => {
            const normalizedEntries = normalizeSolutionEntries(solutionEntries);
            const paths = normalizedEntries.map(sol => sol.path);
            if (!Array.isArray(paths) || paths.length === 0) return;
            if (APP.State.ENGINE.mode === EDITOR) APP.Editor.setWorkingLevelHintsFromSolutions(paths.slice(0, 4));
            APP.State.ENGINE.hinter.pathList = paths;
            const seenHints = new Set((APP.State.ENGINE.foundHintsSinceLoad || []).map(p => JSON.stringify(p)));
            if (!APP.State.ENGINE.foundHintsSinceLoad) APP.State.ENGINE.foundHintsSinceLoad = [];
            paths.forEach(path => {
                const key = JSON.stringify(path);
                if (!seenHints.has(key)) {
                    APP.State.ENGINE.foundHintsSinceLoad.push(path);
                    seenHints.add(key);
                }
            });
            APP.State.ENGINE.hinter.source = 'dynamic';
            APP.State.ENGINE.hinter.currentPathIdx = 0;
            APP.UI.setSolutionOutput(JSON.stringify(paths).replace(/\s/g, ''));
            APP.Solver.startHintAnimation();
            showMessage(purpose === 'hint' ? 'Hint found.' : 'Solved.', 'text-emerald-600');
        };

        const solveLevel = async (level, opts = {}) => {
            const purpose = opts.purpose || 'solve';
            const timeBudgetMs = Number.isFinite(opts.timeBudgetMs) ? opts.timeBudgetMs : (purpose === 'hint' ? 5000 : 15000);
            const allowReferee = opts.allowReferee !== undefined ? !!opts.allowReferee : !!APP.State.ENGINE.flags?.useRefereeSolver;
            const debug = opts.debug !== undefined ? !!opts.debug : true;
            const debugLevel = opts.debugLevel !== undefined ? opts.debugLevel : (typeof level?.id === 'number' ? level.id + 1 : null);
            const controller = startRun({ label: purpose === 'hint' ? 'Hint search running…' : 'Solve search running…', mode: 'solve' });
            if (!controller) return { ok: false, status: 'error', rawStatus: 'already-running', solution: [], solutions: [], stagesTried: [] };

            try {
                let solverResult;
                if (!allowReferee) {
                    showMessage('Solving…', 'text-sky-600');
                    const legacy = await PathfinderSolver.solve(level, {
                        timeLimit: timeBudgetMs,
                        debug,
                        debugLevel,
                        signal: controller.signal
                    });
                    const legacySolution = normalizeSolutionEntries(legacy?.solution ?? legacy?.solutions ?? []);
                    if (legacy?.ok && legacySolution.length > 0) {
                        solverResult = { ok: true, status: 'solved', rawStatus: 'solved', stage: 0, solution: legacySolution, solutions: legacySolution, stagesTried: [] };
                    } else {
                        const rawStatus = legacy?.debug?.status === 'timeout' ? 'timeout' : (legacy?.debug?.status === 'no-solution' ? normalizeNoSolutionStatus(legacy.debug) : 'error');
                        const normalizedStatus = rawStatus === 'no-solution-proven' ? 'no-solution' : rawStatus;
                        solverResult = { ok: false, status: normalizedStatus, rawStatus, stage: 0, solution: [], solutions: [], message: 'No solution found.', stagesTried: [], debug: legacy?.debug || null };
                    }
                } else {
                    const hist = attemptHistory[getLevelAttemptKey(level, purpose)] || { timesTried: 0, lastStatus: null };
                    const willEscalate = hist.timesTried > 0 && ['timeout', 'no-solution-inconclusive'].includes(hist.lastStatus);
                    if (willEscalate) showMessage('Retrying with alternate ordering and longer budget…', 'text-amber-600');
                    solverResult = await Referee.solve(level, {
                        purpose,
                        timeBudgetMs,
                        allowGemini: false,
                        onStage: ({ name, variant, budgetMs }) => {
                            APP.UI.setModalContent('searchLabel', `${name} (${variant}, ${Math.round(budgetMs / 1000)}s)`, 'text');
                            if (APP.State.ENGINE.flags.refereeDebug) showMessage(`Stage transition: ${name} (${variant})`, 'text-sky-600');
                            if (typeof opts.onStage === 'function') opts.onStage({ name, variant, budgetMs });
                        }
                    });
                    const canonical = solverResult.solution ?? solverResult.solutions ?? [];
                    solverResult.solution = canonical;
                    solverResult.solutions = canonical;
                    solverResult.rawStatus = solverResult.status;
                    if (solverResult.status === 'no-solution-proven') solverResult.status = 'no-solution';

                    const rawStatus = solverResult.rawStatus || solverResult.status;
                    const shouldTryLegacyFallback = !solverResult.ok && ['timeout', 'no-solution-inconclusive', 'error'].includes(rawStatus);
                    if (shouldTryLegacyFallback) {
                        const fallbackBudgetMs = Number.isFinite(solverResult.budgetMs) ? solverResult.budgetMs : timeBudgetMs;
                        showMessage('Referee was inconclusive. Trying legacy solver…', 'text-amber-600');
                        const legacy = await PathfinderSolver.solve(level, {
                            timeLimit: fallbackBudgetMs,
                            debug,
                            debugLevel,
                            signal: controller.signal
                        });
                        const legacySolution = normalizeSolutionEntries(legacy?.solution ?? legacy?.solutions ?? []);
                        if (legacy?.ok && legacySolution.length > 0) {
                            solverResult = {
                                ok: true,
                                status: 'solved',
                                rawStatus: 'solved',
                                stage: solverResult.stage,
                                solution: legacySolution,
                                solutions: legacySolution,
                                stagesTried: solverResult.stagesTried || []
                            };
                        }
                    }
                }
                applyCanonicalSolutionShape(solverResult);
                if (APP.State.ENGINE.flags?.refereeDebug && solverResult?.ok && solverResult.solution.length === 0) {
                    console.warn('Solver marked ok but returned empty canonical solution.', { solverResult, stagesTried: solverResult.stagesTried || [] });
                }
                const solution = normalizeSolutionEntries(solverResult.solution ?? solverResult.solutions ?? []);
                const debugInfo = solverResult.debug || solverResult.stats?.debug || null;
                return {
                    ok: !!solverResult.ok,
                    status: solverResult.status || 'error',
                    rawStatus: solverResult.rawStatus || solverResult.status || 'error',
                    timedOut: (solverResult.rawStatus || solverResult.status) === 'timeout',
                    duration: Number.isFinite(solverResult.duration)
                        ? solverResult.duration
                        : (Number.isFinite(solverResult.elapsedMs) ? solverResult.elapsedMs : (debugInfo?.elapsedMs || 0)),
                    nodesVisited: Number.isFinite(solverResult.nodesVisited)
                        ? solverResult.nodesVisited
                        : (Number.isFinite(debugInfo?.nodesVisited)
                            ? debugInfo.nodesVisited
                            : (Number.isFinite(debugInfo?.nodesExpanded) ? debugInfo.nodesExpanded : 0)),
                    solution,
                    solutions: solution,
                    debug: debugInfo,
                    stagesTried: solverResult.stagesTried || [],
                    stage: solverResult.stage,
                    message: solverResult.message || ''
                };
            } catch (err) {
                if (err?.name === 'AbortError') return { ok: false, status: 'aborted', rawStatus: 'aborted', solution: [], solutions: [], stagesTried: [] };
                console.error('Solver error:', err);
                return { ok: false, status: 'error', rawStatus: 'error', solution: [], solutions: [], stagesTried: [], message: err?.message || 'Solver error' };
            } finally {
                finishRun();
            }
        };

        const megaSolve = async (levels, opts = {}) => {
            if (APP.State.ENGINE.activeSolverController) return { cancelled: true };
            const controller = startRun({ label: 'Mega solver running…', mode: 'mega' });
            if (!controller) return { cancelled: true };
            const toRun = opts.targets || levels.map((_, i) => i + 1).filter(i => !levels[i - 1].hints || levels[i - 1].hints.length === 0);
            const timeLimitMs = opts.timeLimitMs ?? 15000;
            const allowGemini = !!opts.allowGemini;
            const variant = opts.variant || 'default';
            const results = opts.results || {};
            const meta = opts.meta || {};

            try {
                for (let i = 0; i < toRun.length; i++) {
                    if (controller.signal.aborted) break;
                    const lvlNum = toRun[i];
                    const idx = lvlNum - 1;
                    const l = APP.LevelUtils.normalizeLevel(idx);
                    const prevMeta = meta[lvlNum] || { attempts: 0 };
                    const attempt = prevMeta.attempts + 1;
                    if (typeof opts.onProgress === 'function') opts.onProgress({ index: i, total: toRun.length, lvlNum, attempt });
                    APP.UI.setModalContent('searchLabel', `Mega solving level ${lvlNum}/${toRun.length}…`, 'text');
                    const res = await Referee.solve(l, {
                        purpose: 'mega',
                        timeBudgetMs: timeLimitMs,
                        allowGemini,
                        variant,
                        onStage: ({ name, variant: stageVariant, budgetMs }) => {
                            APP.UI.setModalContent('searchLabel', `${name} (${stageVariant}, ${Math.round(budgetMs / 1000)}s)`, 'text');
                            if (APP.State.ENGINE.solverAbortRequested) APP.UI.setModalContent('searchLabel', 'Stopping… finishing current stage safely.', 'text');
                        }
                    });
                    meta[lvlNum] = {
                        status: res.status,
                        attempts: attempt,
                        lastBudgetMs: timeLimitMs,
                        lastStageReached: res.stage,
                        stagesTried: res.stagesTried || []
                    };
                    if (res.ok) results[lvlNum] = (res.solution || []).map(sv => sv.path);
                    if (typeof opts.onLevelResult === 'function') opts.onLevelResult({ lvlNum, attempt, res, timeLimitMs, results, meta });
                }
                return { cancelled: controller.signal.aborted, results, meta };
            } finally {
                finishRun();
            }
        };

        const findTrapSpots = async (level, opts = {}) => {
            const controller = startRun({ label: 'Finding trap spots…', mode: 'trap' });
            if (!controller) return { ok: false, status: 'error', spots: new Set() };
            try {
                const spots = await PathfinderSolver.findTrapSpots(level, {
                    timeLimit: opts.timeLimit ?? 8000,
                    signal: controller.signal,
                    onStateUpdate: (msg) => {
                        APP.UI.setModalContent('searchLabel', msg, 'text');
                        showMessage(msg, 'text-white font-black');
                    },
                    onProgress: (elapsedMs) => {
                        APP.UI.setSolverTimerText((elapsedMs / 1000).toFixed(1) + 's');
                    }
                });
                return { ok: true, status: 'solved', spots };
            } catch (err) {
                if (err?.name === 'AbortError') return { ok: false, status: 'aborted', spots: new Set() };
                console.error(err);
                return { ok: false, status: 'error', spots: new Set(), error: err };
            } finally {
                finishRun();
            }
        };

        const cancel = () => {
            if (!APP.State.ENGINE.activeSolverController) return;
            APP.State.ENGINE.solverAbortRequested = true;
            APP.UI.setModalContent('searchLabel', 'Stopping… finishing current stage safely.', 'text');
            APP.UI.setButtonState('solverCloseBtn', { enabled: false });
            APP.State.ENGINE.activeSolverController.abort();
        };



            const attemptHistory = {};

            function getLevelAttemptKey(level, purpose) {
                const levelNum = (typeof level?.id === 'number') ? (level.id + 1) : (APP.State.ENGINE.levelIdx + 1);
                return `${levelNum}:${purpose}`;
            }

            function isNoSolutionTrulyProven(debug) {
                if (!debug || typeof debug !== 'object') return false;
                if (debug.exhaustive === true || debug.exhaustiveDone === true) return true;
                if (debug.done === true && typeof debug.reason === 'string') {
                    const reason = debug.reason.toLowerCase();
                    if (reason.includes('exhaustive') || reason.includes('fully explored')) return true;
                }
                return false;
            }

            function normalizeNoSolutionStatus(debug) {
                return isNoSolutionTrulyProven(debug) ? 'no-solution-proven' : 'no-solution-inconclusive';
            }

            function toStageResultStatus(status) {
                if (status === 'solved') return 'solved';
                if (status === 'cancelled') return 'cancelled';
                if (status === 'error') return 'error';
                if (status === 'timeout') return 'timeout';
                if (status === 'no-solution-proven') return 'inconclusive';
                if (status === 'no-solution-inconclusive') return 'inconclusive';
                if (status === 'gemini-invalid') return 'inconclusive';
                if (status === 'gemini-failed') return 'error';
                return 'inconclusive';
            }

            function validateCandidatePath(level, pathCoordsOrKeys) {
                if (!Array.isArray(pathCoordsOrKeys) || pathCoordsOrKeys.length < 2) return { ok: false, reason: 'Path must contain at least 2 nodes.' };
                const toKey = (node) => {
                    if (typeof node === 'number') return node;
                    if (Array.isArray(node) && node.length >= 2) return APP.LevelUtils.PACK(Number(node[0]) - 1, Number(node[1]) - 1);
                    if (node && typeof node === 'object' && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                        const x = Number(node.x);
                        const y = Number(node.y);
                        if (x >= 1 && y >= 1 && (x > level.grid.w || y > level.grid.h)) return APP.LevelUtils.PACK(x - 1, y - 1);
                        return APP.LevelUtils.PACK(x, y);
                    }
                    return NaN;
                };
                const path = pathCoordsOrKeys.map(toKey);
                if (path.some(k => !Number.isFinite(k))) return { ok: false, reason: 'Invalid path coordinate format.' };
                if (!level.gateKeys.includes(path[0])) return { ok: false, reason: 'Path must start on a gate.' };
                const counts = new Map();
                const usage = new Map();
                const jumpSet = new Set();
                let intersections = 0;
                let flipCount = 0;
                const crossedSet = new Map();
                counts.set(path[0], 1);
                for (let i = 1; i < path.length; i++) {
                    const prev = path[i - 1];
                    const cur = path[i];
                    if (!isValidMoveCommon(cur, path.slice(0, i), counts, usage, intersections, jumpSet, level, { mode: PLAY, flipCount, crossedSet, hazardPolicy: 'forbid' })) {
                        return { ok: false, reason: `Invalid move at step ${i + 1}.` };
                    }
                    const prevP = APP.LevelUtils.UNPACK(prev);
                    const curP = APP.LevelUtils.UNPACK(cur);
                    const axis = (prevP.y === curP.y) ? H : V;
                    const updateUsage = (from, ax) => {
                        if (!usage.has(from)) usage.set(from, { h: false, v: false });
                        usage.get(from)[ax === H ? 'h' : 'v'] = true;
                    };
                    updateUsage(prev, axis);
                    updateUsage(cur, axis);
                    const c = counts.get(cur) || 0;
                    if (c > 0 && cur !== level.goalKey && !level.gateKeys.includes(cur)) intersections++;
                    counts.set(cur, c + 1);
                    if (level.flippingFilterMap.has(cur) && !crossedSet.has(cur)) {
                        crossedSet.set(cur, flipCount);
                        flipCount++;
                    }
                    const portal = resolvePortal(level, prev);
                    if (portal && portal.dest === cur) jumpSet.add(i);
                }
                const finalState = { mode: PLAY, level, editor: { workingLevel: level }, path, isPortalJump: jumpSet, visitedCounts: counts, intersections };
                if (path[path.length - 1] !== level.goalKey) return { ok: false, reason: 'Path does not end at goal.' };
                if (!areWinMetricsSatisfied(finalState, level)) return { ok: false, reason: 'Path fails reqLen/reqInt/must rules.' };
                return { ok: true, path };
            }

            async function requestGeminiSolverSuggestion(level, purpose, attempt = 1, timeoutMs = 15000) {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), timeoutMs);
                const startedAt = Date.now();
                const payloadLevel = APP.LevelUtils.denormalizeLevel(level);
                if (!payloadLevel?.goal || !Array.isArray(payloadLevel.gates) || payloadLevel.gates.length === 0) {
                    return { ok: false, reason: 'Gemini request blocked: level is missing gate or goal data.', details: { code: 'invalid-level', hasGoal: !!payloadLevel?.goal, gateCount: payloadLevel?.gates?.length || 0 } };
                }
                try {
                    const payload = {
                        model: 'gemini-2.5-flash',
                        level: payloadLevel,
                        attempt,
                        purpose
                    };
                    const resp = await fetch('./api/gemini_solver_suggest.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    const data = await resp.json();
                    if (!data?.ok) {
                        return {
                            ok: false,
                            reason: data?.error || 'Gemini request failed.',
                            details: {
                                code: data?.error || 'unknown',
                                httpStatus: data?.status || resp.status || 0,
                                upstream: data?.details || '',
                                elapsedMs: Date.now() - startedAt
                            }
                        };
                    }
                    const candidates = [];
                    if (typeof data.text === 'string' && data.text.trim()) {
                        candidates.push(data.text.trim());
                        const m = data.text.match(/```(?:json)?\s*([\s\S]*?)```/i);
                        if (m?.[1]) candidates.push(m[1].trim());
                    }
                    let parsed = null;
                    for (const c of candidates) {
                        try { parsed = JSON.parse(c); break; } catch {}
                    }
                    if (!parsed || !Array.isArray(parsed.path)) {
                        return { ok: false, reason: 'Gemini did not return valid path JSON.', details: { code: 'invalid-json-shape', elapsedMs: Date.now() - startedAt } };
                    }
                    return { ok: true, candidate: parsed.path, notes: parsed.notes || '', elapsedMs: Date.now() - startedAt };
                } catch (err) {
                    const isAbort = err?.name === 'AbortError';
                    return {
                        ok: false,
                        reason: isAbort ? 'Gemini request timed out.' : `Gemini error: ${err?.message || 'Unknown error'}`,
                        details: { code: isAbort ? 'timeout' : 'fetch-error', elapsedMs: Date.now() - startedAt, errorName: err?.name || 'Error' }
                    };
                } finally { clearTimeout(timer); }
            }

            async function runGameSolver(purpose = 'solve') {
                if (APP.Solver.isRunning()) return;
                APP.Solver.stopHintAnimation();
                const activeLevel = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel;
                const solverResult = await APP.Solver.solveLevel(activeLevel, { purpose });
                const canonical = normalizeSolutionEntries(solverResult.solution ?? solverResult.solutions ?? []);
                solverResult.solution = canonical;
                solverResult.solutions = canonical;
                const normalizedEntries = canonical;
                const normalizedEntries = solverResult.ok ? canonical : [];
                const normalizedPaths = normalizedEntries.map(sol => sol.path).filter(path => Array.isArray(path) && path.length > 0);
                if (solverResult.ok && canonical.length > 0 && normalizedPaths.length === 0) {
                    console.warn('Solver returned malformed solution entries.', { purpose, solution: canonical });
                    showMessage('Solver returned malformed solution data.', 'text-amber-600');
                }

                if (normalizedPaths.length > 0) {
                    APP.Solver.applySolutionsToEngine(normalizedEntries, purpose);
                } else if (solverResult.rawStatus === 'no-solution-proven') {
                    showMessage('No solution exists for this level (proven by exhaustive search).', 'text-amber-600');
                    APP.UI.setSolutionOutput(solverResult.message || 'No solution proven.');
                    APP.Engine.setOverlayState(OVERLAY_NONE);
                } else if (solverResult.status === 'aborted') {
                    showMessage('Solver cancelled.', 'text-amber-600');
                    APP.Engine.setOverlayState(OVERLAY_NONE);
                } else {
                    if (purpose === 'hint') {
                        showMessage('No hint found within 5s. Press New Hint again to try a deeper strategy (15s).', 'text-amber-600');
                    } else {
                        showMessage('No solution found within 15s (inconclusive). Press Solve again to try a deeper strategy (60s + alt ordering).', 'text-amber-600');
                    }
                    APP.UI.setSolutionOutput(solverResult.message || 'No solution found within budget.');
                    APP.Engine.setOverlayState(OVERLAY_NONE);
                }
            }

            function startHintAnimation() {
                if (!APP.State.ENGINE.hinter.pathList.length) return;
                APP.Engine.setOverlayState(HINT_ANIMATING);
                APP.State.ENGINE.hinter.alpha = 1; APP.State.ENGINE.hinter.index = 0;
                showMessage(`Solution ${APP.State.ENGINE.hinter.currentPathIdx + 1}/${APP.State.ENGINE.hinter.pathList.length}`, "text-emerald-600");
            }

            function stopHintAnimation() {
                APP.State.ENGINE.hinter.pathList = [];
                APP.State.ENGINE.hinter.currentPathIdx = 0;
                APP.State.ENGINE.hinter.index = 0;
                APP.State.ENGINE.hinter.alpha = 0;
                APP.Engine.setOverlayState(OVERLAY_NONE);
            }

        return {
            solveLevel,
            megaSolve,
            findTrapSpots,
            applySolutionsToEngine,
            cancel,
            isRunning: () => !!APP.State.ENGINE.activeSolverController,
            getStatus: () => ({ ...status, active: !!APP.State.ENGINE.activeSolverController }),
            Referee,
            Mega,
            runGameSolver,
            startHintAnimation,
            stopHintAnimation
        };
    })();

    // Purpose: startup loading flow and fallback/error orchestration.
    // Owns:
    // - loader progress state
    // - external themes/levels script loading
    // - fallback activation and timeout handling
    // - startup error finalization
    // Public API: init, finish, fail, getStatus.
    APP.Loader = (() => {
        const state = {
            progress: 0,
            hasLoaded: false,
            hasFinished: false,
            status: 'idle',
            mode: 'unknown',
            initPromise: null,
            timeoutId: null,
            settled: false
        };

        const setProgress = (nextProgress, label = 'Initing Systems...') => {
            state.progress = Math.max(0, Math.min(100, nextProgress));
            APP.UI.setProgress({ pct: state.progress, phase: label });
        };

        const finalizeInit = (mode) => {
            if (state.settled) return;
            state.settled = true;
            if (state.timeoutId) {
                clearTimeout(state.timeoutId);
                state.timeoutId = null;
            }
            state.mode = mode;
        };

        const triggerFallback = (reason = 'missing window.RAW_LEVELS') => {
            if (state.mode === 'ready' || (state.hasLoaded && state.status === 'ready')) return 'ready';
            state.hasLoaded = true;
            state.status = 'fallback';
            state.mode = 'fallback';
            setProgress(100, 'Using Local Fallback...');
            console.warn(`[Using fallback levels] ${reason}`);
            window.RAW_LEVELS = FALLBACK_RAW_LEVELS;
            return 'fallback';
        };

        const finish = () => {
            if (state.hasFinished) return;
            state.hasFinished = true;
            setProgress(100, state.mode === 'fallback' ? 'Fallback Ready' : 'Ready');
            if (document.getElementById('loadingOverlay') || document.getElementById('loadingOverlay')) {
                APP.UI.setOverlayOpacity('loadingOverlay', '0');
                setTimeout(() => APP.UI.hideOverlay('loadingOverlay'), 500);
            }
            APP.Themes.populateThemes();
        };

        const fail = (kind, payload) => {
            try { APP.UI.reportError(kind, payload); } catch {}
            state.status = 'failed';
            state.mode = 'failed';
            finish();
        };

        const init = () => {
            if (state.initPromise) return state.initPromise;
            state.status = 'loading';
            state.settled = false;
            state.hasFinished = false;
            setProgress(5, 'Initing Systems...');

            state.initPromise = new Promise((resolve) => {
                const done = (mode) => {
                    finalizeInit(mode);
                    resolve(mode);
                };

                const loadThemes = new Promise(innerResolve => {
                    setProgress(20, 'Loading Themes...');
                    const s = document.createElement('script');
                    s.src = './themes.js';
                    s.onload = () => {
                        if (window.THEMES_MORE) Object.assign(APP.Themes.THEMES, window.THEMES_MORE);
                        APP.Themes.ensureThemeLeaveColors();
                        setProgress(55, 'Themes Ready');
                        innerResolve();
                    };
                    s.onerror = () => {
                        setProgress(55, 'Themes Fallback');
                        innerResolve();
                    };
                    document.head.appendChild(s);
                });

                const loadLevels = new Promise((innerResolve, reject) => {
                    setProgress(70, 'Loading Levels...');
                    const s = document.createElement('script');
                    s.src = './levels.js';
                    s.onload = () => innerResolve();
                    s.onerror = () => reject(new Error('levels.js failed to load'));
                    document.head.appendChild(s);
                });

                loadThemes
                    .then(() => loadLevels)
                    .then(() => {
                        if (state.hasLoaded) {
                            done(state.mode === 'unknown' ? 'fallback' : state.mode);
                            return;
                        }
                        if (!Array.isArray(window.RAW_LEVELS)) {
                            done(triggerFallback('missing window.RAW_LEVELS after external script load'));
                            return;
                        }
                        state.hasLoaded = true;
                        state.status = 'ready';
                        setProgress(95, 'Levels Ready');
                        console.log('RAW_LEVELS loaded:', Array.isArray(window.RAW_LEVELS), window.RAW_LEVELS?.length);
                        done('ready');
                    })
                    .catch(err => {
                        console.error('[External level/theme load failed]', err);
                        done(triggerFallback('exception during external level/theme load'));
                    });

                state.timeoutId = setTimeout(() => {
                    done(triggerFallback('loader timeout after 5000ms'));
                }, 5000);
            });

            return state.initPromise;
        };

        const getStatus = () => ({
            phase: state.status,
            progress: state.progress,
            hasLoaded: state.hasLoaded,
            hasFinished: state.hasFinished,
            status: state.status,
            mode: state.mode
        });

        return { init, finish, fail, getStatus };
    })();

    window.addEventListener('error', (event) => APP.Loader.fail('error', event?.error || event));
    window.addEventListener('unhandledrejection', (event) => APP.Loader.fail('promise', event?.reason || event));

    // ======================================================
    // B) State / Engine
    // Purpose: single mutable app/game state container.
    // Owns:
    // - play/editor runtime state
    // - solver/theme transient flags
    // - ui/gamepad state snapshots
    // - persistence-facing progress data
    // Public API: APP.State.ENGINE.
    // ======================================================
    APP.State = (() => {
        const ENGINE = {
        mode: PLAY,
        logicState: IDLE,
        overlayState: OVERLAY_NONE,
        isDevMode: false,
        levelIdx: 0,
        variant: 0,
        level: null,
        path: [],
        isPortalJump: new Set(),
        visitedCounts: new Map(),
        cellUsage: new Map(),
        intersections: 0,
        activeGateKey: null,
        flipCount: 0,
        visualFlipCount: 0,
        crossedFlippingFilters: new Map(),
        detonatedFalseGoals: new Set(),
        armedFalseGoals: new Set(),
        undoStack: [],
        revealedGeese: new Set(),
        ripples: [],
        gooseEncounteredThisLevel: false,
        muted: true,
        rainbowActive: true,
        titleClickCount: 0,
        titleClickTimer: null,
        resetStreak: 0,
        lastFlipTime: 0,
        cheatTimer: null,
        hinter: { pathList: [], currentPathIdx: 0, alpha: 0, index: 0, source: 'none' },
        activeSolverController: null,
        solverAbortRequested: false,
        viewport: { cellW: 0, cellH: 0, swapped: false, lastWidth: 0, lastHeight: 0 },
        themeDragColor: null,
        themeDragTheme: null,
        themeDragCategory: null,
        themeTapSelectedColor: null,
        themeTapSelectedTheme: null,
        themeTapCategory: null,
        progressSet: new Set(),
        foundHintsSinceLoad: [],
        editor: { workingLevel: null, draggedObject: null, draggedFromGrid: false, selectedTool: null, isPencilMode: false, pendingPortal: null, paletteColors: ['#d946ef', '#0ea5e9', '#10b981', '#f59e0b', '#ef4444'], undoStack: [], validTrapSpots: new Set(), isModified: false, emptyClickCount: 0, mirrorHorizontal: true }
        ,ui: { isLandscapeLayout: false, forceLandscapeLayout: false, focusGroup: 'GRID', focusIndex: 0, bLastPressTime: 0, bSingleTimer: null, gamepadFocusEnabled: false }
        ,runtime: { currentTheme: 'classic', messageTimer: null, pendingAction: null, activePointerId: null, isHintExpanded: false }
        ,gamepad: { lastButtons: [], lastAxes: [0, 0], nextMoveAt: 0, hasPad: false, rafActive: false, rafId: null }
        ,flags: { useRefereeSolver: false, refereeDebug: false }
    };
        return { ENGINE };
    })();

    // ======================================================
    // B2) Engine + Editor API Facades
    // Purpose: stable bridge APIs between input/event layer and internals.
    // Owns:
    // - Engine facade entry points
    // - Editor facade entry points
    // - dependency binding to APP.State.ENGINE/UI
    // Public API (Engine): init, bind, loadLevel, resetRunState, handleCellClick, attemptMoveTo, processStep, checkWinCondition, areWinMetricsSatisfied, checkFalseGoalCondition, triggerJumpScare, triggerBombDetonation, getPackedPath, getIntersections.
    // Public API (Editor): init, bind, enterEditorMode, exitEditorMode, loadWorkingLevel, commitWorkingLevel, pickUpObject, placeEditorObject, validateLevelDetailed, saveEditorState, restoreEditorState, setWorkingHints.
    // ======================================================
    // Purpose: play/runtime mechanics facade.
    // Owns:
    // - level/run lifecycle wrappers
    // - movement/win/hazard entrypoints
    // - read-only runtime snapshots for UI/tools
    // Public API: init, bind, loadLevel, resetRunState, handlePrimaryGridInput, handleCellClick, attemptMoveTo, processStep, checkWinCondition, areWinMetricsSatisfied, checkFalseGoalCondition, triggerJumpScare, triggerBombDetonation, getPackedPath, getIntersections.
    APP.Engine = (() => {
        let refs = { ENGINE: null, UI: null };
        const bind = ({ ENGINE: engineRef, UI: uiRef }) => { refs = { ENGINE: engineRef, UI: uiRef }; };
        const init = bind;


            function processStep(key) { const activeLevel = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; if ([HAZARD_TRIGGERED].includes(APP.State.ENGINE.logicState) && APP.State.ENGINE.mode !== EDITOR) return null; if (APP.State.ENGINE.path.length > 1 && key === APP.State.ENGINE.path[APP.State.ENGINE.path.length - 2]) { APP.Engine.PathNavigator.truncateTo(APP.State.ENGINE, APP.State.ENGINE.path.length - 2); SOUND_BUS.play("E4", "32n"); return "valid"; } if (isValidMoveEngine(key, APP.State.ENGINE.path, APP.State.ENGINE.visitedCounts, APP.State.ENGINE.cellUsage, APP.State.ENGINE.intersections, APP.State.ENGINE.isPortalJump, activeLevel)) { if (APP.State.ENGINE.mode === EDITOR) APP.State.ENGINE.editor.isModified = true; if (APP.State.ENGINE.mode !== EDITOR && activeLevel.gooseSet.has(key)) { APP.State.ENGINE.revealedGeese.add(key); if (!APP.State.ENGINE.gooseEncounteredThisLevel) { APP.State.ENGINE.gooseEncounteredThisLevel = true; triggerJumpScare(); } APP.Engine.setLogicState(HAZARD_TRIGGERED); SOUND_BUS.play("C2", "8n"); return "goose"; } APP.State.ENGINE.undoStack.push(createSnapshot()); if(APP.State.ENGINE.undoStack.length > 200) APP.State.ENGINE.undoStack.shift(); APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, key, false); if (APP.State.ENGINE.armedFalseGoals.has(key) && checkFalseGoalCondition()) { triggerBombDetonation(key); return "detonate"; } const portal = resolvePortal(activeLevel, key); if (portal && portal.dest !== -1) { APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, portal.dest, true); if (APP.State.ENGINE.armedFalseGoals.has(portal.dest) && checkFalseGoalCondition()) { triggerBombDetonation(portal.dest); return "detonate"; } APP.State.ENGINE.ripples.push({x: APP.LevelUtils.UNPACK(key).x, y: APP.LevelUtils.UNPACK(key).y, startTime: Date.now(), color: portal.color}); APP.State.ENGINE.ripples.push({x: APP.LevelUtils.UNPACK(portal.dest).x, y: APP.LevelUtils.UNPACK(portal.dest).y, startTime: Date.now(), color: portal.color}); SOUND_BUS.play("A5", "16n"); APP.Engine.setLogicState(PORTAL_PAUSE); checkWinCondition(); return "portal"; } SOUND_BUS.play("G4", "32n"); checkWinCondition(); return "valid"; } return null; }


            function attemptMoveTo(target) { if (APP.State.ENGINE.mode === EDITOR && !APP.State.ENGINE.editor.isPencilMode) return; if ([HAZARD_TRIGGERED].includes(APP.State.ENGINE.logicState) && APP.State.ENGINE.mode !== EDITOR) return; if (!APP.State.ENGINE.path.length) return; const headPos = APP.LevelUtils.UNPACK(APP.State.ENGINE.path[APP.State.ENGINE.path.length - 1]); if (APP.State.ENGINE.logicState === PORTAL_PAUSE) { if (target.x !== headPos.x || target.y !== headPos.y) APP.Engine.setLogicState(DRAGGING); else return; } if (target.x === headPos.x && target.y === headPos.y) return; const dx = target.x - headPos.x; const dy = target.y - headPos.y; if (dx !== 0 && dy !== 0) return; const pathSteps = []; if (dx !== 0) { for (let i = 1; i <= Math.abs(dx); i++) pathSteps.push(APP.LevelUtils.PACK(headPos.x + Math.sign(dx) * i, headPos.y)); } else if (dy !== 0) { for (let i = 1; i <= Math.abs(dy); i++) pathSteps.push(APP.LevelUtils.PACK(headPos.x, headPos.y + Math.sign(dy) * i)); } for (const step of pathSteps) { const result = processStep(step); if (result === null || result === "goose" || result === "detonate") break; } }

            function checkWinCondition() { if (checkWinConditionImpl(APP.State.ENGINE.path, APP.State.ENGINE.level, APP.State.ENGINE.mode, APP.State.ENGINE.logicState, APP.State.ENGINE.isPortalJump, APP.State.ENGINE.visitedCounts, APP.State.ENGINE.intersections)) { APP.Engine.setLogicState(RESOLVED); winOutEl.value = JSON.stringify(APP.State.ENGINE.path).replace(/\s/g, ''); document.getElementById('winExportArea').classList.toggle('hidden', !APP.State.ENGINE.isDevMode); if (APP.State.ENGINE.mode === PLAY) APP.Persistence.markLevelComplete(APP.State.ENGINE.levelIdx); APP.UI.openModal('winModal'); SOUND_BUS.play("C5", "8n"); } }

            function checkWinConditionImpl(path, level, mode, logicState, isPortalJump, visitedCounts, intersections) { if (!path.length || [HAZARD_TRIGGERED].includes(logicState) || mode === EDITOR) return false; const last = path[path.length - 1]; if (last !== level.goalKey) return false; const stubState = { mode, level, editor: { workingLevel: level }, path, isPortalJump, visitedCounts, intersections }; return areWinMetricsSatisfied(stubState, level); }

            function checkFalseGoalCondition() {
                const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel;
                if (!l) return false;
                return getRealLength() === l.reqLen && APP.State.ENGINE.intersections === l.reqInt;
            }


            function triggerJumpScare() {
                APP.UI.showGooseJumpScare();
                APP.Engine.setOverlayState(GOOSE_OVERLAY);
                setTimeout(() => {
                    APP.UI.hideGooseJumpScare();
                    APP.Engine.setOverlayState(OVERLAY_NONE);
                }, 2500);
            }


            function triggerBombDetonation(key) {
                APP.State.ENGINE.armedFalseGoals.delete(key);
                APP.State.ENGINE.detonatedFalseGoals.add(key);
                APP.Engine.setOverlayState(FALSE_GOAL_ANIMATING);
                APP.UI.showBombDetonation();
                SOUND_BUS.play("C2", "8n");
                setTimeout(() => {
                    APP.UI.showBombDetonation({ explodedMarkup: `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="#ef4444" stroke-width="10" stroke-dasharray="10 5" class="animate-ping"/><path d="M 50 10 L 50 90 M 10 50 L 90 50 M 20 20 L 80 80 M 20 80 L 80 20" stroke="#f97316" stroke-width="8"/></svg>` });
                    SOUND_BUS.play("F1", "4n");
                    setTimeout(() => {
                        APP.UI.hideBombDetonation({ resetMarkup: `<svg viewBox="0 0 100 100"><use href="#def-falsegoal"/></svg>` });
                        APP.Engine.setOverlayState(OVERLAY_NONE);
                    }, 1000);
                }, 1000);
            }


            function isValidMoveEngine(key, path, counts, usage, ints, jumpSet, l) { return isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, { mode: APP.State.ENGINE.mode, armedFalseGoals: APP.State.ENGINE.armedFalseGoals, flipCount: APP.State.ENGINE.flipCount, crossedSet: APP.State.ENGINE.crossedFlippingFilters }); }


            function createSnapshot() { return { path: [...APP.State.ENGINE.path], isPortalJump: new Set(APP.State.ENGINE.isPortalJump), activeGateKey: APP.State.ENGINE.activeGateKey, logicState: APP.State.ENGINE.logicState, detonatedFalseGoals: new Set(APP.State.ENGINE.detonatedFalseGoals) }; }

            function applySnapshot(snap) { APP.State.ENGINE.path = [...snap.path]; APP.State.ENGINE.isPortalJump = new Set(snap.isPortalJump); APP.State.ENGINE.activeGateKey = snap.activeGateKey; APP.Engine.setLogicState(snap.logicState); APP.State.ENGINE.detonatedFalseGoals = new Set(snap.detonatedFalseGoals); const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; const armed = new Set(l?.falseGoalKeys || []); APP.State.ENGINE.detonatedFalseGoals.forEach(k => armed.delete(k)); APP.State.ENGINE.armedFalseGoals = armed; APP.Engine.rebuildDerivedPathState(APP.State.ENGINE); showMessage("", ""); }

            function updatePlayModeLayout() { if (APP.State.ENGINE.mode !== PLAY) return; APP.UI.setClassState('megaSolverBtn', 'hidden', !APP.State.ENGINE.isDevMode); APP.UI.setClassState('exportArea', 'hidden', !APP.State.ENGINE.isDevMode); APP.UI.setClassState('devCopyBtn', 'hidden', !APP.State.ENGINE.isDevMode); APP.UI.setClassState('devGenBtn', 'hidden', !APP.State.ENGINE.isDevMode); }

            function switchMode(newMode) { const isEd = newMode === EDITOR; APP.State.ENGINE.mode = newMode; APP.Engine.setLogicState(IDLE); APP.Engine.setOverlayState(OVERLAY_NONE); APP.Engine.PathNavigator.clear(APP.State.ENGINE); APP.State.ENGINE.undoStack = []; APP.State.ENGINE.revealedGeese.clear(); APP.State.ENGINE.gooseEncounteredThisLevel = false; APP.State.ENGINE.armedFalseGoals.clear(); APP.State.ENGINE.detonatedFalseGoals.clear(); document.getElementById('editorPalette').classList.toggle('hidden', !isEd); document.getElementById('playMetrics').classList.toggle('hidden', isEd); document.getElementById('editorMetrics').classList.toggle('hidden', !isEd); document.getElementById('gameButtonGrid').classList.toggle('hidden', isEd); document.getElementById('editorButtonGrid').classList.toggle('hidden', !isEd); const exportArea = document.getElementById('exportArea'); document.getElementById('editCopyBtn').classList.toggle('hidden', !isEd); document.getElementById('editGenBtn').classList.toggle('hidden', !isEd); document.getElementById('devCopyBtn').classList.toggle('hidden', isEd || !APP.State.ENGINE.isDevMode); document.getElementById('devGenBtn').classList.toggle('hidden', isEd || !APP.State.ENGINE.isDevMode); if (isEd) { APP.State.ENGINE.variant = 0; APP.State.ENGINE.editor.workingLevel = APP.LevelUtils.deepCloneLevel(APP.State.ENGINE.level); APP.State.ENGINE.editor.isPencilMode = false; APP.State.ENGINE.editor.undoStack = []; APP.State.ENGINE.editor.validTrapSpots.clear(); APP.State.ENGINE.editor.emptyClickCount = 0; APP.UI.setInputValue('editReqLen', APP.State.ENGINE.editor.workingLevel.reqLen || 0); APP.UI.setInputValue('editReqInt', APP.State.ENGINE.editor.workingLevel.reqInt || 0); APP.State.ENGINE.editor.isModified = false; exportArea.classList.remove('hidden'); updatePencilState(); } else { updatePlayModeLayout(); APP.Engine.loadLevel(APP.State.ENGINE.levelIdx, { keepVariant: true }); } updateAppScale(); updateViewport(); syncEditorPalettePlacement(); APP.Persistence.updateCompletionUI(); showMessage("", ""); }

            function updatePencilState() { const btn = document.getElementById('editPencilBtn'); const svg = btn.querySelector('svg'); if (APP.State.ENGINE.editor.isPencilMode) { btn.classList.add('selected'); svg.setAttribute('fill', 'currentColor'); } else { btn.classList.remove('selected'); svg.setAttribute('fill', 'none'); } }



            APP.Renderer = (() => {

                const cvs = document.getElementById('gameCanvas');

                const ctx = cvs.getContext('2d');



                function getScreenPos(cx, cy) { const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; const { tx, ty } = APP.LevelUtils.transformPoint(cx, cy, APP.State.ENGINE.variant, l.grid.w, l.grid.h); return { sx: (tx + 0.5) * APP.State.ENGINE.viewport.cellW, sy: (ty + 0.5) * APP.State.ENGINE.viewport.cellH }; }

                function drawBombAsset(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); const scale = s / 100; ctx.scale(scale, scale); ctx.beginPath(); ctx.arc(0, 10, 25, 0, Math.PI * 2); ctx.fillStyle = '#334155'; ctx.fill(); ctx.beginPath(); ctx.moveTo(0, -15); ctx.quadraticCurveTo(15, -30, 30, -25); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 4; ctx.stroke(); ctx.beginPath(); ctx.arc(30, -25, 5, 0, Math.PI * 2); ctx.fillStyle = '#ef4444'; ctx.fill(); ctx.beginPath(); ctx.arc(30, -25, 2.5, 0, Math.PI * 2); ctx.fillStyle = '#fde047'; ctx.fill(); ctx.beginPath(); ctx.moveTo(-5, -15); ctx.lineTo(5, -15); ctx.lineTo(5, -5); ctx.lineTo(-5, -5); ctx.closePath(); ctx.fillStyle = '#64748b'; ctx.fill(); ctx.restore(); }

                function drawPath(pathArr, isJumpSet, strokeStyle, width, isCaution = false) { if (!pathArr.length) return; ctx.save(); ctx.lineWidth = width; ctx.lineCap = isCaution ? 'butt' : 'round'; ctx.lineJoin = 'round'; const drawDot = (sx, sy, color) => { ctx.save(); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(sx, sy, width / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }; if (pathArr.length === 1 && !isCaution) { const start = APP.LevelUtils.UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); drawDot(sStart.sx, sStart.sy, (strokeStyle === 'rainbow') ? '#ff0000' : strokeStyle); ctx.restore(); return; } if (isCaution) { const trace = () => { const start = APP.LevelUtils.UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); ctx.beginPath(); ctx.moveTo(sStart.sx, sStart.sy); ctx.lineTo(sStart.sx, sStart.sy); for (let i = 1; i < pathArr.length; i++) { const p = APP.LevelUtils.UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); if (isJumpSet.has(i)) { ctx.moveTo(s.sx, s.sy); ctx.lineTo(s.sx, s.sy); } else { ctx.lineTo(s.sx, s.sy); } } }; ctx.strokeStyle = '#fbbf24'; trace(); ctx.stroke(); ctx.strokeStyle = '#000000'; ctx.setLineDash([width, width]); trace(); ctx.stroke(); ctx.setLineDash([]); } else if (APP.State.ENGINE.rainbowActive) { const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3']; let totalLength = 0; const segments = []; for (let i = 1; i < pathArr.length; i++) { if (isJumpSet.has(i)) continue; const p1 = APP.LevelUtils.UNPACK(pathArr[i - 1]); const p2 = APP.LevelUtils.UNPACK(pathArr[i]); const s1 = getScreenPos(p1.x, p1.y); const s2 = getScreenPos(p2.x, p2.y); const dx = s2.sx - s1.sx; const dy = s2.sy - s1.sy; const len = Math.hypot(dx, dy); segments.push({ s1, s2, len }); totalLength += len; } const start = APP.LevelUtils.UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); drawDot(sStart.sx, sStart.sy, colors[0]); let curTravel = 0; segments.forEach(seg => { const mid = curTravel + seg.len / 2; const t = mid / Math.max(totalLength, 1); const colorIndex = Math.floor(t * colors.length) % colors.length; ctx.strokeStyle = colors[colorIndex]; ctx.beginPath(); ctx.moveTo(seg.s1.sx, seg.s1.sy); ctx.lineTo(seg.s2.sx, seg.s2.sy); ctx.stroke(); curTravel += seg.len; }); let jumpTravel = 0; for (let i = 1; i < pathArr.length; i++) { if (isJumpSet.has(i)) { const p = APP.LevelUtils.UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); const t = jumpTravel / Math.max(totalLength, 1); const colorIndex = Math.floor(t * colors.length) % colors.length; drawDot(s.sx, s.sy, colorIndex >= 0 ? colors[colorIndex] : colors[0]); } else { const p1 = APP.LevelUtils.UNPACK(pathArr[i - 1]); const p2 = APP.LevelUtils.UNPACK(pathArr[i]); jumpTravel += Math.hypot(p2.x - p1.x, p2.y - p1.y) * APP.State.ENGINE.viewport.cellW; } } } else { ctx.strokeStyle = strokeStyle; const trace = () => { const start = APP.LevelUtils.UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); ctx.beginPath(); ctx.moveTo(sStart.sx, sStart.sy); ctx.lineTo(sStart.sx, sStart.sy); for (let i = 1; i < pathArr.length; i++) { const p = APP.LevelUtils.UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); if (isJumpSet.has(i)) { ctx.moveTo(s.sx, s.sy); ctx.lineTo(s.sx, s.sy); } else { ctx.lineTo(s.sx, s.sy); } } }; trace(); ctx.stroke(); } ctx.restore(); }

                function drawProhibitedAsset(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); ctx.beginPath(); ctx.arc(0, 0, s * 0.35, 0, Math.PI * 2); ctx.strokeStyle = "#ef4444"; ctx.lineWidth = s * 0.1; ctx.stroke(); ctx.beginPath(); const lineLen = s * 0.25; ctx.moveTo(-lineLen, -lineLen); ctx.lineTo(lineLen, lineLen); ctx.stroke(); ctx.restore(); }

                function drawRequiredAsset(ctx, cx, cy, s, hit, colors) { ctx.save(); ctx.translate(cx, cy); const tilt = hit ? 15 : -15; ctx.rotate(tilt * Math.PI / 180); const scale = s / 35; ctx.scale(scale, scale); ctx.beginPath(); ctx.moveTo(-1, 0); ctx.lineTo(1, 0); ctx.lineTo(1.5, -12); ctx.lineTo(-1.5, -12); ctx.closePath(); ctx.fillStyle = '#94a3b8'; ctx.fill(); ctx.beginPath(); ctx.arc(0, -18, 7, 0, Math.PI * 2); ctx.fillStyle = hit ? colors.pin : colors.pinUnflipped; ctx.fill(); ctx.restore(); }

                function drawMustCrossAsset(ctx, cx, cy, s, color) { ctx.save(); ctx.strokeStyle = color; ctx.globalAlpha = 0.25; ctx.lineWidth = s * 0.08; const outer = s * 0.4, inner = s * 0.18; ctx.beginPath(); ctx.moveTo(cx - outer, cy - inner); ctx.lineTo(cx - inner, cy - inner); ctx.lineTo(cx - inner, cy - outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx + outer, cy - inner); ctx.lineTo(cx + inner, cy - inner); ctx.lineTo(cx + inner, cy - outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - outer, cy + inner); ctx.lineTo(cx - inner, cy + inner); ctx.lineTo(cx - inner, cy + outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx + outer, cy + inner); ctx.lineTo(cx + inner, cy + inner); ctx.lineTo(cx + inner, cy + outer); ctx.stroke(); ctx.restore(); }

                function drawGooseAsset(ctx, cx, cy, s, isCheatReveal = false) { ctx.save(); if (isCheatReveal) ctx.globalAlpha = 0.5; const mapX = (v) => cx - s/2 + (v / 100 * s), mapY = (v) => cy - s/2 + (v / 100 * s); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.moveTo(mapX(30), mapY(0)); ctx.lineTo(mapX(70), mapY(0)); ctx.lineTo(mapX(100), mapY(30)); ctx.lineTo(mapX(100), mapY(70)); ctx.lineTo(mapX(70), mapY(100)); ctx.lineTo(mapX(30), mapY(100)); ctx.lineTo(mapX(0), mapY(70)); ctx.lineTo(mapX(0), mapY(30)); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.moveTo(mapX(25), mapY(60)); ctx.quadraticCurveTo(mapX(25), mapY(45), mapX(45), mapY(45)); ctx.lineTo(mapX(65), mapY(45)); ctx.quadraticCurveTo(mapX(75), mapY(45), mapX(75), mapY(55)); ctx.quadraticCurveTo(mapX(75), mapY(65), mapX(65), mapY(65)); ctx.lineTo(mapX(40), mapY(65)); ctx.quadraticCurveTo(mapX(25), mapY(65), mapX(25), mapY(60)); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(25), mapY(55)); ctx.lineTo(mapX(15), mapY(45)); ctx.lineTo(mapX(30), mapY(55)); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(60), mapY(45)); ctx.lineTo(mapX(60), mapY(25)); ctx.quadraticCurveTo(mapX(60), mapY(18), mapX(68), mapY(18)); ctx.quadraticCurveTo(mapX(75), mapY(18), mapX(75), mapY(25)); ctx.lineTo(mapX(75), mapY(35)); ctx.lineTo(mapX(68), mapY(35)); ctx.lineTo(mapX(68), mapY(45)); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(mapX(70), mapY(23), s * 0.02, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.moveTo(mapX(75), mapY(29)); ctx.lineTo(mapX(88), mapY(32)); ctx.lineTo(mapX(75), mapY(35)); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(45), mapY(65)); ctx.lineTo(mapX(40), mapY(78)); ctx.lineTo(mapX(52), mapY(78)); ctx.closePath(); ctx.moveTo(mapX(58), mapY(65)); ctx.lineTo(mapX(53), mapY(78)); ctx.lineTo(mapX(65), mapY(78)); ctx.closePath(); ctx.fill(); ctx.restore(); }

                function drawFilterAsset(ctx, cx, cy, s, axis, color) { ctx.save(); ctx.translate(cx, cy); if (axis === V) ctx.rotate(Math.PI / 2); ctx.fillStyle = color; ctx.globalAlpha = 0.25; const w = s * 0.45, t = s * 0.08; ctx.fillRect(-s/2 + s*0.1, -w/2, s*0.8, t); ctx.fillRect(-s/2 + s*0.1, w/2 - t, s*0.8, t); ctx.restore(); }

                function drawFlippingFilter(ctx, cx, cy, s, axis, color, rotation, crossed) { ctx.save(); ctx.translate(cx, cy); ctx.rotate(rotation); if (axis === V) ctx.rotate(Math.PI / 2); ctx.fillStyle = color; ctx.globalAlpha = 0.25; const w = s * 0.45, t = s * 0.08; ctx.fillRect(-s/2 + s*0.1, -w/2, s*0.8, t); ctx.fillRect(-s/2 + s*0.1, w/2 - t, s*0.8, t); if (APP.State.ENGINE.mode === EDITOR) { ctx.globalAlpha = crossed ? 0.4 : 1.0; ctx.fillStyle = color; ctx.font = `900 ${s * 0.45}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('↺', 0, 0); } ctx.restore(); }

                function drawScorchMark(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 0.4); grad.addColorStop(0, 'rgba(0,0,0,0.5)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); const radii = [0.35, 0.15, 0.4, 0.2, 0.3, 0.15, 0.35, 0.2, 0.4, 0.15, 0.3, 0.25, 0.35, 0.15, 0.4, 0.2]; for (let i = 0; i < 16; i++) { const a = (i / 16) * Math.PI * 2; const r = s * radii[i]; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); } ctx.closePath(); ctx.fill(); ctx.restore(); }

                function render() {

                const vp = APP.State.ENGINE.viewport, l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; if (!vp.cellW || !l) return; const th = APP.Themes.THEMES[APP.Themes.getCurrentTheme()]; ctx.fillStyle = th.canvasBg; ctx.fillRect(0, 0, cvs.width, cvs.height); const W = l.grid.w, H = l.grid.h, dispW = APP.State.ENGINE.viewport.swapped ? H : W, dispH = APP.State.ENGINE.viewport.swapped ? W : H, inset = vp.cellW * 0.25; ctx.beginPath(); ctx.strokeStyle = th.grid; ctx.lineWidth = 1; for (let i = 0; i <= dispW; i++) { const x = i * vp.cellW; ctx.moveTo(x, inset); ctx.lineTo(x, cvs.height - inset); } for (let i = 0; i <= dispH; i++) { const y = i * vp.cellH; ctx.moveTo(inset, y); ctx.lineTo(cvs.width - inset, y); } ctx.stroke();



                if (APP.State.ENGINE.mode === EDITOR && APP.State.ENGINE.editor.validTrapSpots && APP.State.ENGINE.editor.validTrapSpots.size > 0) { APP.State.ENGINE.editor.validTrapSpots.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const cx = sx - vp.cellW / 2, cy = sy - vp.cellH / 2; ctx.save(); ctx.fillStyle = th.colors.goal + '40'; ctx.fillRect(cx + 2, cy + 2, vp.cellW - 4, vp.cellH - 4); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = 3; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.1]); ctx.strokeRect(cx + 2, cy + 2, vp.cellW - 4, vp.cellH - 4); ctx.restore(); }); }



                let reqLen = 0, showParityWarnings = false, targetParity = 0, hasFlippingPortal = false;

                if ((APP.State.ENGINE.mode === EDITOR || APP.State.ENGINE.cheatActive) && l.goalKey !== -1) {

                    reqLen = APP.State.ENGINE.mode === EDITOR ? (parseInt(APP.UI.getValue('editReqLen')) || 0) : l.reqLen;

                    if (reqLen > 0 || APP.State.ENGINE.path.length > 0 || APP.State.ENGINE.cheatActive) {

                        showParityWarnings = true; const gp = APP.LevelUtils.UNPACK(l.goalKey); targetParity = (gp.x + gp.y + reqLen) % 2;

                        l.portalVisuals.forEach(pv => { const p1 = APP.LevelUtils.UNPACK(pv.k1), p2 = APP.LevelUtils.UNPACK(pv.k2); if ((p1.x + p1.y) % 2 === (p2.x + p2.y) % 2) hasFlippingPortal = true; });

                    }

                }



                l.filterMap.forEach((axis, k) => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawFilterAsset(ctx, sx, sy, vp.cellW, APP.LevelUtils.transformAxis(axis, APP.State.ENGINE.variant), th.colors.filter); });



                l.flippingFilterMap.forEach((baseAxis, k) => {

                    const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y);

                    const crossed = APP.State.ENGINE.crossedFlippingFilters.has(k);

                    const targetFlips = crossed ? APP.State.ENGINE.crossedFlippingFilters.get(k) : APP.State.ENGINE.flipCount;

                    let currentVisualFlips = targetFlips;

                    if (!crossed && APP.State.ENGINE.visualFlipCount !== undefined) { currentVisualFlips = APP.State.ENGINE.visualFlipCount; }

                    const rotation = currentVisualFlips * (Math.PI / 2);

                    drawFlippingFilter(ctx, sx, sy, vp.cellW, APP.LevelUtils.transformAxis(baseAxis, APP.State.ENGINE.variant), th.colors.filter, rotation, crossed);

                });



                l.mustCrossKeys.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawMustCrossAsset(ctx, sx, sy, vp.cellW, th.colors.cross); });

                l.blockSet.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const cx = sx - vp.cellW / 2, cy = sy - vp.cellH / 2, cr = vp.cellW * 0.2; ctx.fillStyle = th.colors.block; ctx.beginPath(); ctx.roundRect(cx + 1, cy + 1, vp.cellW - 2, vp.cellH - 2, cr); ctx.fill(); ctx.fillStyle = th.grid; for(let r=1;r<=3;r++) for(let c=1;c<=3;c++) { ctx.beginPath(); ctx.arc(cx+(c*0.25*vp.cellW),cy+(r*0.25*vp.cellH),vp.cellW*0.045,0,Math.PI*2); ctx.fill(); } });



                l.portalVisuals.forEach(pv => { const color = APP.State.ENGINE.mode === EDITOR ? pv.color : th.colors.portal; ctx.strokeStyle = color; ctx.lineWidth = vp.cellW * 0.1; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); [APP.LevelUtils.UNPACK(pv.k1), APP.LevelUtils.UNPACK(pv.k2)].forEach(p => { const { sx, sy } = getScreenPos(p.x, p.y); ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.3, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = color + '25'; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); if (showParityWarnings && !hasFlippingPortal) { if ((p.x + p.y) % 2 !== targetParity) drawProhibitedAsset(ctx, sx, sy, vp.cellW); } }); }); ctx.setLineDash([]);



                if (APP.State.ENGINE.editor.pendingPortal) { const pp = APP.LevelUtils.UNPACK(APP.State.ENGINE.editor.pendingPortal), { sx, sy } = getScreenPos(pp.x, pp.y); ctx.strokeStyle = th.colors.portal; ctx.lineWidth = vp.cellW * 0.1; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.3, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = th.colors.portal + '25'; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.2, 0, Math.PI * 2); ctx.fill(); }

                l.mustPassKeys.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const isHit = APP.State.ENGINE.visitedCounts.get(k) > 0; drawRequiredAsset(ctx, sx, sy, vp.cellW, isHit, th.colors); });



                const now = Date.now(); APP.State.ENGINE.ripples = APP.State.ENGINE.ripples.filter(r => now - r.startTime < 600); APP.State.ENGINE.ripples.forEach(r => { const pct = (now - r.startTime) / 600, { sx, sy } = getScreenPos(r.x, r.y); ctx.save(); ctx.globalAlpha = 1 - pct; ctx.strokeStyle = r.color; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * (0.3 + pct * 1.2), 0, Math.PI * 2); ctx.stroke(); ctx.restore(); });



                l.gateKeys.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); ctx.save(); ctx.translate(sx, sy); ctx.rotate(-Math.PI / 4); const color = (APP.State.ENGINE.activeGateKey === k || !APP.State.ENGINE.activeGateKey) ? th.colors.gate : '#94a3b8'; ctx.strokeStyle = color; ctx.lineWidth = vp.cellW * 0.12; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; for(let i=0; i<2; i++) { const offset = (i - 0.5) * vp.cellW * 0.32; ctx.beginPath(); ctx.moveTo(offset - vp.cellW * 0.1, -vp.cellW * 0.2); ctx.lineTo(offset + vp.cellW * 0.1, 0); ctx.lineTo(offset - vp.cellW * 0.1, vp.cellW * 0.2); ctx.stroke(); } ctx.restore(); if (showParityWarnings && !hasFlippingPortal) { if ((p.x + p.y) % 2 !== targetParity) drawProhibitedAsset(ctx, sx, sy, vp.cellW); } });



                if (APP.State.ENGINE.path.length) { const stroke = APP.State.ENGINE.rainbowActive ? 'rainbow' : th.path; drawPath(APP.State.ENGINE.path, APP.State.ENGINE.isPortalJump, stroke, vp.cellW * 0.25); }



                if (APP.State.ENGINE.overlayState === HINT_ANIMATING && APP.State.ENGINE.hinter.pathList.length) {

                    ctx.save(); ctx.globalAlpha = APP.State.ENGINE.hinter.alpha;

                    const hPath = APP.State.ENGINE.hinter.pathList[APP.State.ENGINE.hinter.currentPathIdx], displayPath = hPath.slice(0, Math.floor(APP.State.ENGINE.hinter.index)), hintsJumps = new Set();

                    for(let i=1; i<displayPath.length; i++){ const p1 = APP.LevelUtils.UNPACK(displayPath[i-1]), p2 = APP.LevelUtils.UNPACK(displayPath[i]); if (Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) > 1) hintsJumps.add(i); }

                    drawPath(displayPath, hintsJumps, '#22c55e', vp.cellW * 0.3, true);

                    ctx.restore();

                }



                if (l.goalKey !== -1) { const goalP = APP.LevelUtils.UNPACK(l.goalKey), sGoal = getScreenPos(goalP.x, goalP.y); ctx.save(); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = vp.cellW * 0.1; ctx.beginPath(); ctx.arc(sGoal.sx, sGoal.sy, vp.cellW * 0.32, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = th.colors.goal; ctx.beginPath(); ctx.arc(sGoal.sx, sGoal.sy, vp.cellW * 0.14, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }



                l.falseGoalKeys.forEach(k => { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); if (APP.State.ENGINE.armedFalseGoals.has(k)) { ctx.save(); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = vp.cellW * 0.1; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.32, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = th.colors.goal; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.14, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } else if (APP.State.ENGINE.detonatedFalseGoals.has(k)) { drawScorchMark(ctx, sx, sy, vp.cellW); } else if (APP.State.ENGINE.mode === EDITOR) { drawBombAsset(ctx, sx, sy, vp.cellW); } });



                l.gooseSet.forEach(k => { if (APP.State.ENGINE.revealedGeese.has(k) || APP.State.ENGINE.cheatActive || APP.State.ENGINE.mode === EDITOR) { const p = APP.LevelUtils.UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawGooseAsset(ctx, sx, sy, vp.cellW, APP.State.ENGINE.cheatActive && !APP.State.ENGINE.revealedGeese.has(k)); } });



                if (APP.State.ENGINE.mode === PLAY) { const curLen = APP.Engine.getRealLength(APP.State.ENGINE); document.getElementById('lengthInfo').innerText = `${curLen}/${l.reqLen}`; const intEl = document.getElementById('intersectionInfo'); intEl.innerText = `${APP.State.ENGINE.intersections}/${l.reqInt}`; if (APP.State.ENGINE.intersections > l.reqInt) { intEl.classList.remove('text-white'); intEl.classList.add('text-red-300'); } else { intEl.classList.add('text-white'); intEl.classList.remove('text-red-300'); } }

                else if (APP.State.ENGINE.mode === EDITOR) { const curLen = APP.Engine.getRealLength(APP.State.ENGINE); const lMet = document.getElementById('editCopyMetrics'); if (lMet) lMet.innerText = `Set (${curLen}/${APP.State.ENGINE.intersections})`; }

            }



                return {

                    render,

                    getScreenPos,

                    drawBombAsset,

                    drawPath,

                    drawProhibitedAsset,

                    drawRequiredAsset,

                    drawMustCrossAsset,

                    drawGooseAsset,

                    drawFilterAsset,

                    drawFlippingFilter,

                    drawScorchMark,

                    getCanvas: () => cvs,

                    getContext: () => ctx

                };

            })();

            function loadLevel(idx, keepVariant = false) {

                if (APP.State.ENGINE.activeSolverController) return;

                const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : (typeof FALLBACK_RAW_LEVELS !== 'undefined' ? FALLBACK_RAW_LEVELS : null);

                if (!levels) return;



                APP.State.ENGINE.levelIdx = idx;

                const isEditor = APP.State.ENGINE.mode === EDITOR;

                if (isEditor) { APP.State.ENGINE.variant = 0; }

                else if (!keepVariant) { APP.State.ENGINE.variant = Math.floor(Math.random() * 8); }



                APP.Engine.setLogicState(IDLE);

                APP.Engine.setOverlayState(OVERLAY_NONE);



                APP.State.ENGINE.level = APP.LevelUtils.normalizeLevel(idx);

                APP.LevelUtils.assertLevelShape(APP.State.ENGINE.level);

                APP.Engine.PathNavigator.clear(APP.State.ENGINE);

                APP.State.ENGINE.undoStack = [];

                APP.State.ENGINE.revealedGeese.clear();

                APP.State.ENGINE.ripples = [];

                APP.State.ENGINE.gooseEncounteredThisLevel = false;

                APP.State.ENGINE.armedFalseGoals = new Set(APP.State.ENGINE.level.falseGoalKeys || []);

                APP.State.ENGINE.detonatedFalseGoals = new Set();

                APP.State.ENGINE.foundHintsSinceLoad = [];

                if (isEditor) {

                    APP.State.ENGINE.editor.workingLevel = APP.LevelUtils.deepCloneLevel(APP.State.ENGINE.level);

                    APP.State.ENGINE.editor.isPencilMode = false;

                    APP.State.ENGINE.editor.undoStack = [];

                    APP.State.ENGINE.editor.validTrapSpots.clear();

                    APP.State.ENGINE.editor.emptyClickCount = 0;

                    APP.UI.setInputValue('editReqLen', APP.State.ENGINE.editor.workingLevel.reqLen || 0);

                    APP.UI.setInputValue('editReqInt', APP.State.ENGINE.editor.workingLevel.reqInt || 0);

                    APP.State.ENGINE.editor.isModified = false;

                    updatePencilState();

                }

                APP.UI.updateLevelDisplay(idx, false);

                APP.UI.closeModal('winModal');

                showMessage("", "");

                updateAppScale();

                updateViewport();

                APP.Persistence.updateCompletionUI();

            }

            function loop() {
                if (APP.State.ENGINE.overlayState === HINT_ANIMATING && APP.State.ENGINE.hinter.pathList.length) {
                    APP.State.ENGINE.hinter.index += 0.5; const hPath = APP.State.ENGINE.hinter.pathList[APP.State.ENGINE.hinter.currentPathIdx];
                    if (APP.State.ENGINE.hinter.index >= hPath.length + 40) {
                        APP.State.ENGINE.hinter.alpha -= 0.05;
                        if (APP.State.ENGINE.hinter.alpha <= 0) {
                            APP.Engine.setOverlayState(OVERLAY_NONE);
                            showMessage("", "");
                        }
                    }
                }
                if (APP.State.ENGINE.visualFlipCount !== undefined) {
                    if (APP.State.ENGINE.visualFlipCount < APP.State.ENGINE.flipCount) { APP.State.ENGINE.visualFlipCount = Math.min(APP.State.ENGINE.flipCount, APP.State.ENGINE.visualFlipCount + 0.15); }
                    else if (APP.State.ENGINE.visualFlipCount > APP.State.ENGINE.flipCount) { APP.State.ENGINE.visualFlipCount = Math.max(APP.State.ENGINE.flipCount, APP.State.ENGINE.visualFlipCount - 0.15); }
                }
                APP.Renderer.render(); requestAnimationFrame(loop);
            }

            function getRealLength(state = APP.State.ENGINE) { return state.path.length > 0 ? state.path.length - 1 - state.isPortalJump.size : 0; }

            function rebuildDerivedPathState(state = APP.State.ENGINE) {
                const oldFlipCount = state.flipCount;
                state.visitedCounts.clear(); state.cellUsage.clear(); state.intersections = 0; state.flipCount = 0; state.crossedFlippingFilters.clear(); const l = state.mode === PLAY ? state.level : state.editor.workingLevel; if (state.path.length === 0) { if (oldFlipCount !== 0) state.lastFlipTime = Date.now(); return; }
                for (let i = 0; i < state.path.length; i++) {
                    const k = state.path[i]; const c = state.visitedCounts.get(k) || 0; if (c > 0 && k !== state.activeGateKey && (l && k !== l.goalKey)) { state.intersections++; } state.visitedCounts.set(k, c + 1);
                    if (i > 0 && !state.isPortalJump.has(i)) { const prevK = state.path[i-1]; const p1 = APP.LevelUtils.UNPACK(prevK), p2 = APP.LevelUtils.UNPACK(k); const axis = (p2.y === p1.y) ? H : V; let uPrev = state.cellUsage.get(prevK) || { h: false, v: false }; if (axis === H) uPrev.h = true; else uPrev.v = true; state.cellUsage.set(prevK, uPrev); let uCur = state.cellUsage.get(k) || { h: false, v: false }; if (axis === H) uCur.h = true; else uCur.v = true; state.cellUsage.set(k, uCur); }
                    if (l && l.flippingFilterMap.has(k) && !state.crossedFlippingFilters.has(k)) { state.crossedFlippingFilters.set(k, state.flipCount); state.flipCount++; }
                }
                if (state.flipCount !== oldFlipCount) state.lastFlipTime = Date.now();
            }

            function assertStateConsistency(state = APP.State.ENGINE) { if (!state.isDevMode) return; const l = state.mode === PLAY ? state.level : state.editor.workingLevel; if (!l) return; const originalIntersections = state.intersections; const originalCounts = new Map(state.visitedCounts); rebuildDerivedPathState(state); if (originalIntersections !== state.intersections) { console.error("Invariant broken: Intersections mismatch."); } originalCounts.forEach((v, k) => { if (state.visitedCounts.get(k) !== v) console.error("Invariant broken: Visited count mismatch."); }); }

            const PathNavigator = {
                pushStep(state, key, isJump) {
                    const l = state.mode === PLAY ? state.level : state.editor.workingLevel; const lastK = state.path[state.path.length - 1];
                    if (lastK !== undefined && !isJump) { const p1 = APP.LevelUtils.UNPACK(lastK), p2 = APP.LevelUtils.UNPACK(key); const axis = (p2.y === p1.y) ? H : V; const mark = (k, ax) => { let u = state.cellUsage.get(k) || { h: false, v: false }; if (ax === H) u.h = true; else u.v = true; state.cellUsage.set(k, u); }; mark(lastK, axis); mark(key, axis); }
                    const count = state.visitedCounts.get(key) || 0; if (count > 0 && key !== state.activeGateKey && (l && key !== l.goalKey)) { state.intersections++; } state.visitedCounts.set(key, count + 1); state.path.push(key); if (isJump) state.isPortalJump.add(state.path.length - 1);
                    if (l && l.flippingFilterMap.has(key) && !state.crossedFlippingFilters.has(key)) { state.crossedFlippingFilters.set(key, state.flipCount); state.flipCount++; state.lastFlipTime = Date.now(); }
                    assertStateConsistency(state);
                },
                truncateTo(state, targetIdx) {
                    if (targetIdx < -1 || targetIdx >= state.path.length - 1) return; state.path.splice(targetIdx + 1); const newJumps = new Set(); for (const j of state.isPortalJump) if (j <= targetIdx) newJumps.add(j); state.isPortalJump = newJumps;
                    if (state.path.length === 0) { state.activeGateKey = null; if ([DRAGGING, PORTAL_PAUSE].includes(state.logicState)) { APP.Engine.setLogicState(IDLE); } } if (state.mode === EDITOR) state.editor.isModified = true; rebuildDerivedPathState(state); assertStateConsistency(state);
                },
                clear(state) { state.path = []; state.isPortalJump.clear(); state.activeGateKey = null; if ([DRAGGING, PORTAL_PAUSE, HAZARD_TRIGGERED].includes(state.logicState)) { APP.Engine.setLogicState(IDLE); } if (state.mode === EDITOR) state.editor.isModified = true; rebuildDerivedPathState(state); assertStateConsistency(state); }
            };

            const VALID_LOGIC_TRANSITIONS = {
                [IDLE]: [DRAGGING, EDIT_DRAG, THEME_DRAG, RESOLVED],
                [DRAGGING]: [IDLE, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED],
                [PORTAL_PAUSE]: [DRAGGING, IDLE],
                [RESOLVED]: [IDLE],
                [HAZARD_TRIGGERED]: [IDLE],
                [EDIT_DRAG]: [IDLE],
                [THEME_DRAG]: [IDLE]
            };

            function setLogicState(newState) {
                if (!VALID_LOGIC_TRANSITIONS[APP.State.ENGINE.logicState].includes(newState) && newState !== IDLE) {
                    console.warn(`Blocked Logic Transition: ${APP.State.ENGINE.logicState} -> ${newState}`);
                    return false;
                }

                if (APP.State.ENGINE.logicState === EDIT_DRAG && newState !== EDIT_DRAG) {
                    APP.UI.EditorDragGhost.update({ visible: false });
                }

                APP.State.ENGINE.logicState = newState;
                return true;
            }

            // setOverlayState updates state only; APP.UI.applyOverlayState renders it.
            function setOverlayState(newState) {
                if (APP.State.ENGINE.overlayState === newState) return true;
                if (APP.State.ENGINE.overlayState === HINT_ANIMATING && newState !== HINT_ANIMATING) {
                    APP.State.ENGINE.hinter.alpha = 0;
                }

                APP.State.ENGINE.overlayState = newState;
                APP.UI.setSolverAbortRequested(APP.State.ENGINE.solverAbortRequested);
                APP.UI.applyOverlayState(newState);

                return true;
            }

        return {
            init,
            bind,
            loadLevel(levelObjOrIdx, options = {}) {
                if (typeof levelObjOrIdx === 'number') return loadLevel(levelObjOrIdx, !!options.keepVariant);
                if (!refs.ENGINE) return;
                const mode = options.mode || refs.ENGINE.mode;
                if (mode === PLAY) refs.ENGINE.level = levelObjOrIdx;
                else refs.ENGINE.editor.workingLevel = levelObjOrIdx;
                this.resetRunState({ keepLevel: true });
            },
            resetRunState({ keepLevel = true } = {}) {
                if (!refs.ENGINE) return;
                APP.Engine.PathNavigator.clear(refs.ENGINE);
                refs.ENGINE.undoStack = [];
                refs.ENGINE.revealedGeese.clear();
                refs.ENGINE.ripples = [];
                refs.ENGINE.gooseEncounteredThisLevel = false;
                if (!keepLevel) refs.ENGINE.level = null;
                refs.ENGINE.armedFalseGoals = new Set((refs.ENGINE.level?.falseGoalKeys) || []);
                refs.ENGINE.detonatedFalseGoals = new Set();
            },
            handlePrimaryGridInput(k, opts) { return attemptMoveTo(k, opts); },
            handleCellClick(k, opts) { return attemptMoveTo(k, opts); },
            attemptMoveTo(target, opts) { return attemptMoveTo(target, opts); },
            processStep(key) { return processStep(key); },
            checkWinCondition() { return checkWinCondition(); },
            areWinMetricsSatisfied(state, level) { return areWinMetricsSatisfied(state, level); },
            checkFalseGoalCondition() { return checkFalseGoalCondition(); },
            triggerJumpScare() { return triggerJumpScare(); },
            triggerBombDetonation(key) { return triggerBombDetonation(key); },
            isValidMoveEngine(key, path, counts, usage, ints, jumpSet, l) { return isValidMoveEngine(key, path, counts, usage, ints, jumpSet, l); },
            createSnapshot() { return createSnapshot(); },
            applySnapshot(snap) { return applySnapshot(snap); },
            checkWinConditionImpl(path, level, mode, logicState, isPortalJump, visitedCounts, intersections) { return checkWinConditionImpl(path, level, mode, logicState, isPortalJump, visitedCounts, intersections); },
            getPackedPath() { return [...(refs.ENGINE?.path || [])]; },
            getIntersections() { return refs.ENGINE?.intersections ?? 0; },
            updatePlayModeLayout,
            loop,
            switchMode,
            setLogicState,
            setOverlayState,
            getRealLength,
            rebuildDerivedPathState,
            assertStateConsistency,
            updatePencilState,
            PathNavigator
        };
    })();

    // Purpose: editor-mode mechanics facade.
    // Owns:
    // - editor mode transitions
    // - editor level mutate/validate helpers
    // - editor undo/restore wrappers
    // Public API: init, bind, enterEditorMode, exitEditorMode, loadWorkingLevel, commitWorkingLevel, applyMetricsFromUI, setWorkingLevelHintsFromSolutions, setObjectAt, removeObjectAt, validateWorkingLevel, setWorkingHints, pickUpObject, placeEditorObject, validateLevelDetailed, saveEditorState, restoreEditorState, setTrapSpots, resetWorkingGrid, createNewLevel.
    APP.Editor = (() => {
        let refs = { ENGINE: null, UI: null, Engine: null };
        const bind = ({ ENGINE: engineRef, UI: uiRef, Engine: engineApi }) => { refs = { ENGINE: engineRef, UI: uiRef, Engine: engineApi }; };
        const init = bind;

            function pickUpObject(k) { if(APP.State.ENGINE.editor.isPencilMode) return null; saveEditorState(); APP.State.ENGINE.editor.draggedFromGrid = true; APP.State.ENGINE.editor.validTrapSpots.clear(); const l = APP.State.ENGINE.editor.workingLevel; l.hints = []; if (l.gateKeys.includes(k)) { l.gateKeys = l.gateKeys.filter(gk => gk !== k); return {type:'gate'}; } if (l.goalKey === k) { l.goalKey = -1; return {type:'goal'}; } if (l.falseGoalKeys.has(k)) { l.falseGoalKeys.delete(k); return {type:'falseGoal'}; } if (l.blockSet.has(k)) { l.blockSet.delete(k); return {type:'block'}; } if (l.gooseSet.has(k)) { l.gooseSet.delete(k); return {type:'goose'}; } if (l.mustPassKeys.includes(k)) { l.mustPassKeys = l.mustPassKeys.filter(mk => mk !== k); return {type:'mustPass'}; } if (l.mustCrossKeys.includes(k)) { l.mustCrossKeys = l.mustCrossKeys.filter(mk => mk !== k); return {type:'mustCross'}; } if (l.filterMap.has(k)) { const a = l.filterMap.get(k); l.filterMap.delete(k); return {type: a === H ? 'filterH' : 'filterV'}; } if (l.flippingFilterMap.has(k)) { const a = l.flippingFilterMap.get(k); l.flippingFilterMap.delete(k); return {type: a === H ? 'flipH' : 'flipV'}; } if (l.portalMap.has(k)) { const port = l.portalMap.get(k); l.portalMap.delete(k); if (APP.State.ENGINE.editor.pendingPortal === k) { APP.State.ENGINE.editor.pendingPortal = null; showMessage("Portal Cancelled", "text-slate-500"); } else { l.portalVisuals = l.portalVisuals.filter(pv => pv.k1 !== k && pv.k2 !== k); const otherK = port.dest; if (otherK !== -1 && l.portalMap.has(otherK)) { l.portalMap.get(otherK).dest = -1; l.portalMap.get(otherK).color = '#999'; APP.State.ENGINE.editor.pendingPortal = otherK; showMessage("Portal unpaired! Place next terminal.", "text-fuchsia-600 font-bold"); } } return {type: 'portal'}; } APP.State.ENGINE.editor.undoStack.pop(); APP.State.ENGINE.editor.draggedFromGrid = false; return null; }

            function placeEditorObject(k) { const l = APP.State.ENGINE.editor.workingLevel; const toolType = APP.State.ENGINE.editor.draggedObject ? APP.State.ENGINE.editor.draggedObject.type : APP.State.ENGINE.editor.selectedTool; if (!toolType) return; if (APP.State.ENGINE.editor.pendingPortal && toolType !== 'portal' && toolType !== 'eraser') { showMessage("Finish portal pair first!", "text-red-600 font-bold"); return; } if (l.gateKeys.includes(k) || l.goalKey === k || l.falseGoalKeys.has(k) || l.blockSet.has(k) || l.gooseSet.has(k) || l.filterMap.has(k) || l.flippingFilterMap.has(k) || l.portalMap.has(k) || l.mustPassKeys.includes(k) || l.mustCrossKeys.includes(k)) { if (toolType === 'eraser') { pickUpObject(k); return; } return showMessage("Occupied", "text-red-500"); } if (toolType === 'eraser') return; saveEditorState(); APP.State.ENGINE.editor.validTrapSpots.clear(); l.hints = []; switch(toolType) { case 'gate': l.gateKeys.push(k); break; case 'goal': l.goalKey = k; break; case 'falseGoal': l.falseGoalKeys.add(k); break; case 'block': l.blockSet.add(k); break; case 'mustPass': l.mustPassKeys.push(k); break; case 'mustCross': l.mustCrossKeys.push(k); break; case 'goose': l.gooseSet.add(k); break; case 'filterH': l.filterMap.set(k, H); break; case 'filterV': l.filterMap.set(k, V); break; case 'flipH': l.flippingFilterMap.set(k, H); break; case 'flipV': l.flippingFilterMap.set(k, V); break; case 'portal': if (!APP.State.ENGINE.editor.pendingPortal) { APP.State.ENGINE.editor.pendingPortal = k; l.portalMap.set(k, { dest: -1, color: '#999' }); showMessage("Place second terminal.", "text-fuchsia-600 font-bold"); } else { const k1 = APP.State.ENGINE.editor.pendingPortal; if (k === k1) return; const color = APP.State.ENGINE.editor.paletteColors[l.portalVisuals.length % 5]; l.portalMap.set(k1, { dest: k, color }); l.portalMap.set(k, { dest: k1, color }); l.portalVisuals.push({ k1, k2: k, color }); APP.State.ENGINE.editor.pendingPortal = null; showMessage("Portal paired.", "text-fuchsia-600 font-bold"); } break; } APP.State.ENGINE.editor.draggedObject = null; }


            function validateLevelDetailed(l) {
                const reasons = [];
                if (!l) return { ok: false, reasons: ["Level missing"] };
                const { w, h } = l.grid;
                const inGrid = (k) => {
                    const p = APP.LevelUtils.UNPACK(k);
                    return APP.LevelUtils.inBounds(p.x, p.y, w, h);
                };
                const addOutOfBounds = (label, key) => {
                    const p = APP.LevelUtils.UNPACK(key);
                    reasons.push(`Out of bounds item: ${label} (${p.x + 1},${p.y + 1})`);
                };

                if (!Array.isArray(l.gateKeys) || l.gateKeys.length === 0) reasons.push("No gates");
                if (l.goalKey === -1 || l.goalKey === undefined) reasons.push("Goal missing");
                if (APP.State.ENGINE.editor.pendingPortal) reasons.push("Portal terminals incomplete");

                l.gateKeys.forEach(k => { if (!inGrid(k)) addOutOfBounds('gates', k); });
                if (l.goalKey !== -1 && l.goalKey !== undefined && !inGrid(l.goalKey)) addOutOfBounds('goal', l.goalKey);
                l.mustPassKeys.forEach(k => { if (!inGrid(k)) addOutOfBounds('mustPass', k); });
                l.mustCrossKeys.forEach(k => { if (!inGrid(k)) addOutOfBounds('mustCross', k); });
                l.gooseSet.forEach(k => { if (!inGrid(k)) addOutOfBounds('geese', k); });
                l.blockSet.forEach(k => { if (!inGrid(k)) addOutOfBounds('blocks', k); });

                let unpaired = false;
                l.portalMap.forEach((v, k) => {
                    if (!l.portalMap.has(v.dest)) unpaired = true;
                    if (!inGrid(k)) addOutOfBounds('portals', k);
                    if (v.dest !== -1 && !inGrid(v.dest)) addOutOfBounds('portals', v.dest);
                });
                if (unpaired) reasons.push("Portal terminals incomplete");

                for (const k of l.mustCrossKeys) {
                    const p = APP.LevelUtils.UNPACK(k);
                    if (l.blockSet.has(k)) reasons.push(`MustCross overlaps block at (${p.x + 1},${p.y + 1})`);
                    const neighbors = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => APP.LevelUtils.PACK(p.x+dx, p.y+dy));
                    const diags = [[1,1],[1,-1],[-1,1],[-1,-1]].map(([dx,dy]) => APP.LevelUtils.PACK(p.x+dx, p.y+dy));
                    if (neighbors.some(nk => l.blockSet.has(nk))) reasons.push(`Block touches MustCross at (${p.x + 1},${p.y + 1})`);
                    if (neighbors.some(nk => l.gooseSet.has(nk))) reasons.push(`Goose touches MustCross at (${p.x + 1},${p.y + 1})`);
                    const left = APP.LevelUtils.PACK(p.x-1,p.y), right = APP.LevelUtils.PACK(p.x+1,p.y), up = APP.LevelUtils.PACK(p.x,p.y-1), down = APP.LevelUtils.PACK(p.x,p.y+1);
                    if ([left, right].some(nk => l.filterMap.get(nk) === V || l.flippingFilterMap.get(nk) === V)) reasons.push(`Vertical Filter adj to MustCross at (${p.x + 1},${p.y + 1})`);
                    if ([up, down].some(nk => l.filterMap.get(nk) === H || l.flippingFilterMap.get(nk) === H)) reasons.push(`Horizontal Filter adj to MustCross at (${p.x + 1},${p.y + 1})`);
                    if (diags.some(nk => l.filterMap.has(nk) || l.flippingFilterMap.has(nk))) reasons.push(`Filter diag to MustCross at (${p.x + 1},${p.y + 1})`);
                }

                l.filterMap.forEach((f, k) => {
                    const p = APP.LevelUtils.UNPACK(k);
                    const neighbors = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => APP.LevelUtils.PACK(p.x+dx, p.y+dy));
                    for (const nk of neighbors) {
                        const nf = l.filterMap.get(nk);
                        if (nf && nf !== f) reasons.push(`Opposing filters adjacent at (${p.x + 1},${p.y + 1})`);
                    }
                });

                const barrier = (k) => l.blockSet.has(k);
                const reachableFrom = (startKey) => {
                    if (startKey === -1 || startKey === undefined || barrier(startKey)) return new Set();
                    const q = [startKey];
                    const visited = new Set([startKey]);
                    let head = 0;
                    while (head < q.length) {
                        const k = q[head++];
                        const p = APP.LevelUtils.UNPACK(k);
                        const nks = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => APP.LevelUtils.PACK(p.x+dx, p.y+dy));
                        const portal = resolvePortal(l, k);
                        if (portal && portal.dest !== -1) nks.push(portal.dest);
                        for (const nk of nks) {
                            const np = APP.LevelUtils.UNPACK(nk);
                            if (APP.LevelUtils.inBounds(np.x, np.y, w, h) && !visited.has(nk) && !barrier(nk)) {
                                visited.add(nk);
                                q.push(nk);
                            }
                        }
                    }
                    return visited;
                };
                if (l.goalKey !== -1 && l.goalKey !== undefined && !barrier(l.goalKey) && Array.isArray(l.gateKeys) && l.gateKeys.length > 0) {
                    const goalReach = reachableFrom(l.goalKey);
                    const hasConnectedGate = l.gateKeys.some(gk => goalReach.has(gk));
                    if (!hasConnectedGate) reasons.push("Grid partitioned by barriers");
                }

                return { ok: reasons.length === 0, reasons: Array.from(new Set(reasons)) };
            }


            function validateLevel(l) {
                const res = validateLevelDetailed(l);
                if (!res.ok) showMessage(res.reasons[0], "text-red-500 font-bold");
                return res.ok;
            }

            function saveEditorState() { APP.State.ENGINE.editor.isModified = true; APP.State.ENGINE.editor.undoStack.push(APP.LevelUtils.deepCloneLevel(APP.State.ENGINE.editor.workingLevel)); if (APP.State.ENGINE.editor.undoStack.length > 50) APP.State.ENGINE.editor.undoStack.shift(); APP.State.ENGINE.hinter.pathList = []; }

            function restoreEditorState() { if (APP.State.ENGINE.editor.undoStack.length === 0) return; APP.State.ENGINE.editor.isModified = true; APP.State.ENGINE.editor.workingLevel = APP.State.ENGINE.editor.undoStack.pop(); let newPending = null; APP.State.ENGINE.editor.workingLevel.portalMap.forEach((v, k) => { if (v.dest === -1) newPending = k; }); APP.State.ENGINE.editor.pendingPortal = newPending; APP.State.ENGINE.hinter.pathList = []; APP.State.ENGINE.editor.validTrapSpots.clear(); showMessage("Undo Grid Action", "text-slate-500"); }


            async function generateLevelString() { const l = APP.State.ENGINE.editor.workingLevel; const isValid = validateLevel(l); const reqLen = parseInt(APP.UI.getValue('editReqLen')) || 0; const reqInt = parseInt(APP.UI.getValue('editReqInt')) || 0; let exportedHints = l.hints || []; if (APP.State.ENGINE.path.length > 1 && APP.State.ENGINE.path[APP.State.ENGINE.path.length - 1] === l.goalKey) { const curLen = getRealLength(); const validLen = curLen === reqLen; const validInt = APP.State.ENGINE.intersections === reqInt; const validPass = l.mustPassKeys.every(k => APP.State.ENGINE.visitedCounts.get(k) > 0); const validCross = l.mustCrossKeys.every(k => (APP.State.ENGINE.visitedCounts.get(k) || 0) >= 2); if (validLen && validInt && validPass && validCross) { const currentPathStr = JSON.stringify(APP.State.ENGINE.path); const alreadyExists = exportedHints.some(h => JSON.stringify(h) === currentPathStr); if (!alreadyExists) { exportedHints = [APP.State.ENGINE.path, ...exportedHints].slice(0, 5); } } } const out = { grid: l.grid, gates: APP.LevelUtils.expCoords(l.gateKeys), goal: {x:APP.LevelUtils.UNPACK(l.goalKey).x+1, y:APP.LevelUtils.UNPACK(l.goalKey).y+1}, falseGoals: APP.LevelUtils.expCoords(l.falseGoalKeys), reqLen: reqLen, reqInt: reqInt, blocks: APP.LevelUtils.expCoords(l.blockSet), mustPass: APP.LevelUtils.expCoords(l.mustPassKeys), mustCross: APP.LevelUtils.expCoords(l.mustCrossKeys), filters: Array.from(l.filterMap.entries()).map(([k, axis]) => ({x:APP.LevelUtils.UNPACK(k).x+1, y:APP.LevelUtils.UNPACK(k).y+1, axis})), flippingFilters: Array.from(l.flippingFilterMap.entries()).map(([k, axis]) => ({x:APP.LevelUtils.UNPACK(k).x+1, y:APP.LevelUtils.UNPACK(k).y+1, axis})), portals: l.portalVisuals.map(pv => ({ x1: APP.LevelUtils.UNPACK(pv.k1).x+1, y1: APP.LevelUtils.UNPACK(pv.k1).y+1, x2: APP.LevelUtils.UNPACK(pv.k2).x+1, y2: APP.LevelUtils.UNPACK(pv.k2).y+1, color: pv.color })), geese: APP.LevelUtils.expCoords(l.gooseSet), hints: exportedHints }; const json = JSON.stringify(out).replace(/\s/g, '').slice(1, -1); APP.UI.setSolutionOutput(json); await APP.UI.copyText(json, { fallbackElId: 'solutionOutput' }); APP.State.ENGINE.editor.isModified = false; if (isValid) { showMessage("Data Generated & Copied!", "text-white font-black"); } else { setTimeout(() => showMessage("Data Copied (Check Errors!)", "text-white font-black"), 1500); } }



        return {
            init,
            bind,
            enterEditorMode() { APP.Engine.switchMode(EDITOR); },
            exitEditorMode() { APP.Engine.switchMode(PLAY); },
            loadWorkingLevel(fromLevelObjOrBlank) { refs.ENGINE.editor.workingLevel = APP.LevelUtils.deepCloneLevel(fromLevelObjOrBlank); refs.ENGINE.editor.isModified = false; },
            commitWorkingLevel() { refs.ENGINE.level = APP.LevelUtils.deepCloneLevel(refs.ENGINE.editor.workingLevel); refs.ENGINE.editor.isModified = false; },
            applyMetricsFromUI() {
                if (!refs.ENGINE?.editor?.workingLevel) return;
                refs.ENGINE.editor.workingLevel.reqLen = parseInt(refs.UI.getValue('editReqLen'));
                refs.ENGINE.editor.workingLevel.reqInt = parseInt(refs.UI.getValue('editReqInt'));
            },
            setWorkingLevelHintsFromSolutions(paths = []) {
                this.setWorkingHints(paths);
            },
            setObjectAt(k, obj) {
                refs.ENGINE.editor.draggedObject = obj;
                return placeEditorObject(k);
            },
            removeObjectAt(k) {
                refs.ENGINE.editor.draggedObject = null;
                return pickUpObject(k);
            },
            validateWorkingLevel() {
                return validateLevelDetailed(refs.ENGINE.editor.workingLevel);
            },
            setTrapSpots(spots = new Set()) {
                refs.ENGINE.editor.validTrapSpots = spots || new Set();
            },
            resetWorkingGrid() {
                this.saveEditorState();
                const l = refs.ENGINE.editor.workingLevel;
                Object.assign(l, {gateKeys: [], goalKey: -1, falseGoalKeys: new Set(), blockSet: new Set(), gooseSet: new Set(), mustPassKeys: [], mustCrossKeys: [], filterMap: new Map(), flippingFilterMap: new Map(), portalMap: new Map(), portalVisuals: []});
                APP.Engine.PathNavigator.clear(refs.ENGINE);
            },
            createNewLevel() {
                refs.ENGINE.editor.workingLevel = { grid: { w: 10, h: 10 }, reqLen: 0, reqInt: 0, goalKey: -1, falseGoalKeys: new Set(), gateKeys: [], blockSet: new Set(), gooseSet: new Set(), portalMap: new Map(), portalVisuals: [], filterMap: new Map(), flippingFilterMap: new Map(), mustPassKeys: [], mustCrossKeys: [], hints: [] };
                APP.Engine.PathNavigator.clear(refs.ENGINE);
                refs.ENGINE.hinter.pathList = [];
                refs.ENGINE.editor.pendingPortal = null;
                refs.ENGINE.editor.validTrapSpots.clear();
                refs.UI.setModalContent('levelTitle', '??', 'text');
                refs.UI.setInputValue('editReqLen', 0);
                refs.UI.setInputValue('editReqInt', 0);
                refs.ENGINE.editor.isPencilMode = false;
                updatePencilState();
                refs.ENGINE.editor.isModified = true;
                updateViewport();
            },
            markEditorInputsDirty() {
                refs.ENGINE.hinter.pathList = [];
                refs.ENGINE.editor.validTrapSpots.clear();
                refs.ENGINE.editor.isModified = true;
            },
            handlePaletteToolPointerDown(toolType) {
                if (refs.ENGINE.mode !== EDITOR) return;
                if (refs.ENGINE.overlayState !== OVERLAY_NONE) return;
                refs.ENGINE.editor.draggedFromGrid = false;
                refs.ENGINE.editor.emptyClickCount = 0;
                if (refs.ENGINE.editor.pendingPortal && toolType !== 'portal' && toolType !== 'eraser') {
                    refs.UI.showMessage('Finish portal pair!', 'text-white font-black');
                    return;
                }
                if (refs.ENGINE.editor.selectedTool === toolType) {
                    refs.ENGINE.editor.selectedTool = null;
                    refs.UI.setPaletteSelectedByType(toolType, false);
                } else {
                    refs.ENGINE.editor.selectedTool = toolType;
                    refs.ENGINE.editor.draggedObject = { type: toolType };
                    APP.Engine.setLogicState(EDIT_DRAG);
                    refs.UI.clearPaletteSelection();
                    refs.UI.setPaletteSelectedByType(toolType, true);
                }
                refs.ENGINE.editor.isPencilMode = false;
                updatePencilState();
            },
            togglePencilMode() {
                if (refs.ENGINE.overlayState !== OVERLAY_NONE) return;
                refs.ENGINE.editor.isPencilMode = !refs.ENGINE.editor.isPencilMode;
                if (refs.ENGINE.editor.isPencilMode) {
                    refs.ENGINE.editor.selectedTool = null;
                    refs.UI.clearPaletteSelection();
                } else {
                    APP.Engine.setLogicState(IDLE);
                }
                updatePencilState();
            },
            setWorkingHints(hints = []) { if (refs.ENGINE?.editor?.workingLevel) refs.ENGINE.editor.workingLevel.hints = hints; },
            pickUpObject(k) { return pickUpObject(k); },
            placeEditorObject(k) { return placeEditorObject(k); },
            validateLevelDetailed(level) { return validateLevelDetailed(level); },
            saveEditorState() { return saveEditorState(); },
            restoreEditorState() { return restoreEditorState(); },
            validateLevel(level) { return validateLevel(level); },
            generateLevelString() { return generateLevelString(); },
            setLogicState(newState) { return APP.Engine.setLogicState(newState); },
            setOverlayState(newState) { return APP.Engine.setOverlayState(newState); },
            getRealLength(state = APP.State.ENGINE) { return APP.Engine.getRealLength(state); },
            rebuildDerivedPathState(state = APP.State.ENGINE) { return APP.Engine.rebuildDerivedPathState(state); },
            assertStateConsistency(state = APP.State.ENGINE) { return APP.Engine.assertStateConsistency(state); },
            updatePencilState() { return APP.Engine.updatePencilState(); }
        };
    })();

    APP.Engine.init({ ENGINE: APP.State.ENGINE, UI: APP.UI });
    APP.Editor.init({ ENGINE: APP.State.ENGINE, UI: APP.UI, Engine: APP.Engine });

    // ======================================================
    // J) Persistence
    // ======================================================
    APP.Persistence = (() => {
        const firebaseConfigRaw = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
        let auth = null;
        let db = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'pathfinder-standalone';

        if (firebaseConfigRaw) {
            try {
                const config = JSON.parse(firebaseConfigRaw);
                firebase.initializeApp(config);
                auth = firebase.auth();
                db = firebase.firestore();
            } catch (e) {}
        }

        async function initAuth() {
            if (!auth) return;
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await auth.signInWithCustomToken(__initial_auth_token);
                } else {
                    await auth.signInAnonymously();
                }
            } catch (e) {}
        }

        function syncProgress(user) {
            const localData = localStorage.getItem(`pathfinder_progress_${appId}`);
            if (localData) {
                APP.State.ENGINE.progressSet = new Set(JSON.parse(localData));
                APP.Persistence.updateCompletionUI();
            }

            if (user && db) {
                const progressDoc = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('levelProgress');
                progressDoc.onSnapshot((doc) => {
                    if (doc.exists) {
                        const data = doc.data();
                        const cloudSet = new Set(data.completedLevels || []);
                        APP.State.ENGINE.progressSet = new Set([...APP.State.ENGINE.progressSet, ...cloudSet]);
                        APP.Persistence.updateCompletionUI();
                        localStorage.setItem(`pathfinder_progress_${appId}`, JSON.stringify(Array.from(APP.State.ENGINE.progressSet)));
                    }
                }, (err) => {});
            }
        }

        async function markLevelComplete(idx) {
            APP.State.ENGINE.progressSet.add(idx);
            APP.Persistence.updateCompletionUI();
            localStorage.setItem(`pathfinder_progress_${appId}`, JSON.stringify(Array.from(APP.State.ENGINE.progressSet)));

            const user = auth?.currentUser;
            if (user && db) {
                const progressDoc = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('levelProgress');
                await progressDoc.set({ completedLevels: Array.from(APP.State.ENGINE.progressSet) }, { merge: true });
            }
        }

        function updateCompletionUI() {
            const isComplete = APP.State.ENGINE.progressSet.has(APP.State.ENGINE.levelIdx);
            const isPlayMode = APP.State.ENGINE.mode === PLAY;
            APP.UI.updateLevelDisplay(APP.State.ENGINE.levelIdx, isComplete && isPlayMode);
        }

        return {
            initAuth,
            syncProgress,
            markLevelComplete,
            updateCompletionUI,
            hasConfig: !!firebaseConfigRaw,
            getCurrentUser: () => auth?.currentUser
        };
    })();

    function getViewportDimensions() {
        const vv = window.visualViewport;
        if (vv) return { width: vv.width, height: vv.height };
        return { width: window.innerWidth, height: window.innerHeight };
    }

    function measureGridModalRect() {
        const appLayout = document.getElementById('appLayout');
        const canvasContainer = document.getElementById('canvasContainer');
        const modalRectSource = canvasContainer || appLayout;
        if (!modalRectSource) return;
        const modalRect = modalRectSource.getBoundingClientRect();
        APP.UI.setRootCssVar('--grid-modal-left', `${modalRect.left}px`);
        APP.UI.setRootCssVar('--grid-modal-top', `${modalRect.top}px`);
        APP.UI.setRootCssVar('--grid-modal-width', `${modalRect.width}px`);
        APP.UI.setRootCssVar('--grid-modal-height', `${modalRect.height}px`);
    }

    function updateAppScale() {
        const VIEWPORT_EPSILON = 2;
        const viewport = getViewportDimensions();
        const widthChanged = Math.abs(viewport.width - APP.State.ENGINE.viewport.lastWidth) > VIEWPORT_EPSILON;
        const heightChanged = Math.abs(viewport.height - APP.State.ENGINE.viewport.lastHeight) > VIEWPORT_EPSILON;
        updateLayoutMode();
        if (!widthChanged && !heightChanged) return;
        APP.State.ENGINE.viewport.lastWidth = viewport.width;
        APP.State.ENGINE.viewport.lastHeight = viewport.height;
        const scale = Math.min(viewport.height * 0.02, viewport.width * 0.035);
        APP.UI.setRootCssVar('--app-scale', `${scale}px`);
        updateViewport();
    }

    function updateLayoutMode() {
        const viewport = getViewportDimensions();
        const naturalLandscape = window.matchMedia('(orientation: landscape)').matches && viewport.width >= 900;
        APP.State.ENGINE.ui.isLandscapeLayout = naturalLandscape || APP.State.ENGINE.ui.forceLandscapeLayout;
        const appLayout = document.getElementById('appLayout');
        APP.UI.setClassState(appLayout, 'forced-landscape', APP.State.ENGINE.ui.forceLandscapeLayout && !naturalLandscape);
        syncEditorPalettePlacement();
        measureGridModalRect();
        requestAnimationFrame(() => measureGridModalRect());
        const orientationBtn = document.getElementById('orientationToggleBtn');
        APP.UI.setTextContent(orientationBtn, APP.State.ENGINE.ui.forceLandscapeLayout ? 'Standard' : 'Landscape');
    }

    function syncEditorPalettePlacement() {
        const pal = document.getElementById('editorPalette');
        const gamePane = document.getElementById('gamePane');
        const controlsPane = document.getElementById('controlsPane');
        if (!pal || !gamePane || !controlsPane) return;
        const inLandscape = APP.State.ENGINE.ui.isLandscapeLayout;
        if (inLandscape && APP.State.ENGINE.mode === EDITOR) {
            if (pal.parentElement !== controlsPane) controlsPane.insertBefore(pal, controlsPane.firstChild);
            APP.UI.setClassState(pal, 'landscape-editor-tools', true);
        } else {
            if (pal.parentElement !== gamePane.parentElement) gamePane.parentElement.insertBefore(pal, controlsPane);
            APP.UI.setClassState(pal, 'landscape-editor-tools', false);
        }
    }
    // Shared globals consumed across modules.
    // NOTE: keep this block single-defined in global scope; duplicating it
    // with `const` declarations will throw and prevent input handlers from binding.
    const FALLBACK_RAW_LEVELS = [ { grid: {w:10, h:10}, gates: [{x:2,y:2}, {x:2,y:4}], goal: {x:9,y:9}, reqLen: 14, reqInt: 0, blocks: [{x:4,y:4}, {x:5,y:4}, {x:4,y:5}, {x:5,y:5}], mustPass: [{x:6,y:6}], geese: [{x:6,y:7}], flippingFilters: [{x:8, y:2, axis: 2}, {x:3, y:8, axis: 1}, {x:5, y:2, axis: 1}, {x:7, y:2, axis: 1}], falseGoals: [{x:2, y:8}], hints: [] } ];

    APP.LevelUtils = (() => {
            const PACK = (x, y) => (y << 16) | x;
            const UNPACK = (k) => ({ x: k & 0xFFFF, y: k >> 16 });
            const inBounds = (x, y, w, h) => x >= 0 && x < w && y >= 0 && y < h;
            const expCoords = (items) => (Array.isArray(items) ? items : Array.from(items)).map(k => { const p = UNPACK(k); return {x: p.x + 1, y: p.y + 1}; });

            function transformPoint(x, y, variant, W, H) { switch (variant) { case 0: return { tx: x, ty: y }; case 1: return { tx: H - 1 - y, ty: x }; case 2: return { tx: W - 1 - x, ty: H - 1 - y }; case 3: return { tx: y, ty: W - 1 - x }; case 4: return { tx: W - 1 - x, ty: y }; case 5: return { tx: x, ty: H - 1 - y }; case 6: return { tx: y, ty: x }; case 7: return { tx: H - 1 - y, ty: W - 1 - x }; default: return { tx: x, ty: y }; } }

            function inverseTransformPoint(tx, ty, variant, W, H) { switch (variant) { case 0: return { x: tx, y: ty }; case 1: return { x: ty, y: H - 1 - tx }; case 2: return { x: W - 1 - tx, y: H - 1 - ty }; case 3: return { x: W - 1 - ty, y: tx }; case 4: return { x: W - 1 - tx, y: ty }; case 5: return { x: tx, y: H - 1 - ty }; case 6: return { x: ty, y:tx }; case 7: return { x: W - 1 - ty, y: H - 1 - tx }; default: return { x: tx, y: ty }; } }

            function transformAxis(axis, variant) { const swaps = [1, 3, 6, 7]; if (swaps.includes(variant)) { if (axis === H) return V; if (axis === V) return H; } return axis; }

            function getGridCoord(e) { const canvas = APP.Renderer.getCanvas(); const rect = canvas.getBoundingClientRect(); const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; if (!l) return {x:0, y:0}; const gridW = APP.State.ENGINE.viewport.swapped ? l.grid.h : l.grid.w, gridH = APP.State.ENGINE.viewport.swapped ? l.grid.w : l.grid.h; const tx = Math.max(0, Math.min(gridW - 1, Math.floor((e.clientX - rect.left) * (canvas.width / rect.width) / APP.State.ENGINE.viewport.cellW))); const ty = Math.max(0, Math.min(gridH - 1, Math.floor((e.clientY - rect.top) * (canvas.height / rect.height) / APP.State.ENGINE.viewport.cellH))); return APP.LevelUtils.inverseTransformPoint(tx, ty, APP.State.ENGINE.variant, l.grid.w, l.grid.h); }

            function deepCloneLevel(src) { const l = JSON.parse(JSON.stringify(src)); l.blockSet = new Set(src.blockSet); l.gooseSet = new Set(src.gooseSet); l.falseGoalKeys = new Set(src.falseGoalKeys); l.portalMap = new Map(); if(src.portalMap) src.portalMap.forEach((v, k) => l.portalMap.set(k, v)); l.filterMap = new Map(); if(src.filterMap) src.filterMap.forEach((v, k) => l.filterMap.set(k, v)); l.flippingFilterMap = new Map(); if(src.flippingFilterMap) src.flippingFilterMap.forEach((v, k) => l.flippingFilterMap.set(k, v)); return l; }
            // ======================================================
            // C) Level / NormalizeAndCaches
            // ======================================================

            function normalizeLevel(idx) { const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; if (idx < 0 || idx >= levels.length) return null; const raw = levels[idx]; if (!raw) return null; const adj = (v) => v - 1; const l = { id: idx, grid: { ...raw.grid }, reqLen: raw.reqLen, reqInt: raw.reqInt, goalKey: APP.LevelUtils.PACK(adj(raw.goal.x), adj(raw.goal.y)), gateKeys: raw.gates.map(g => APP.LevelUtils.PACK(adj(g.x), adj(g.y))), blockSet: new Set(), gooseSet: new Set(), falseGoalKeys: new Set(), portalMap: new Map(), portalVisuals: [], filterMap: new Map(), flippingFilterMap: new Map(), mustPassKeys: raw.mustPass?.map(m => APP.LevelUtils.PACK(adj(m.x), adj(m.y))) || [], mustCrossKeys: raw.mustCross?.map(m => APP.LevelUtils.PACK(adj(m.x), adj(m.y))) || [], hints: raw.hints || [] }; (raw.blocks || raw.walls)?.forEach(w => l.blockSet.add(APP.LevelUtils.PACK(adj(w.x), adj(w.y)))); raw.geese?.forEach(m => l.gooseSet.add(APP.LevelUtils.PACK(adj(m.x), adj(m.y)))); raw.filters?.forEach(f => l.filterMap.set(APP.LevelUtils.PACK(adj(f.x), adj(f.y)), f.axis)); raw.flippingFilters?.forEach(f => l.flippingFilterMap.set(APP.LevelUtils.PACK(adj(f.x), adj(f.y)), f.axis)); raw.falseGoals?.forEach(g => l.falseGoalKeys.add(APP.LevelUtils.PACK(adj(g.x), adj(g.y)))); raw.portals?.forEach(p => { const k1 = APP.LevelUtils.PACK(adj(p.x1), adj(p.y1)), k2 = APP.LevelUtils.PACK(adj(p.x2), adj(p.y2)); l.portalMap.set(k1, { dest: k2, color: p.color || '#d946ef' }); l.portalMap.set(k2, { dest: k1, color: p.color || '#d946ef' }); l.portalVisuals.push({ k1, k2, color: p.color || '#d946ef' }); }); return l; }

            function denormalizeLevel(level) {
                if (!level || !level.grid) return null;
                const toCoord = (k) => { const p = APP.LevelUtils.UNPACK(k); return { x: p.x + 1, y: p.y + 1 }; };
                const sortCoords = (arr) => arr.sort((a, b) => (a.y - b.y) || (a.x - b.x));
                const blocks = sortCoords(Array.from(level.blockSet || []).map(toCoord));
                const geese = sortCoords(Array.from(level.gooseSet || []).map(toCoord));
                const falseGoals = sortCoords(Array.from(level.falseGoalKeys || []).map(toCoord));
                const mustPass = sortCoords((level.mustPassKeys || []).map(toCoord));
                const mustCross = sortCoords((level.mustCrossKeys || []).map(toCoord));
                const filters = sortCoords(Array.from(level.filterMap?.entries?.() || []).map(([k, axis]) => ({ ...toCoord(k), axis })));
                const flippingFilters = sortCoords(Array.from(level.flippingFilterMap?.entries?.() || []).map(([k, axis]) => ({ ...toCoord(k), axis })));
                const seenPortals = new Set();
                const portals = [];
                (level.portalMap || new Map()).forEach((v, k) => {
                    if (!v || typeof v.dest !== 'number' || v.dest < 0) return;
                    const pair = [k, v.dest].sort((a, b) => a - b).join(':');
                    if (seenPortals.has(pair)) return;
                    seenPortals.add(pair);
                    const a = toCoord(k);
                    const b = toCoord(v.dest);
                    portals.push({ x1: a.x, y1: a.y, x2: b.x, y2: b.y, color: v.color || '#d946ef' });
                });
                portals.sort((a, b) => (a.y1 - b.y1) || (a.x1 - b.x1) || (a.y2 - b.y2) || (a.x2 - b.x2));

                return {
                    grid: { w: level.grid.w, h: level.grid.h },
                    gates: sortCoords((level.gateKeys || []).map(toCoord)),
                    goal: typeof level.goalKey === 'number' && level.goalKey >= 0 ? toCoord(level.goalKey) : null,
                    reqLen: level.reqLen || 0,
                    reqInt: level.reqInt || 0,
                    blocks,
                    geese,
                    falseGoals,
                    mustPass,
                    mustCross,
                    filters,
                    flippingFilters,
                    portals,
                    hints: Array.isArray(level.hints) ? level.hints : [],
                    levelId: typeof level.id === 'number' ? level.id + 1 : null
                };
            }

            function shiftLevel(l, dx, dy) { if (dx === 0 && dy === 0) return; const shift = (k) => { if (k === -1) return -1; const p = APP.LevelUtils.UNPACK(k); return APP.LevelUtils.PACK(p.x + dx, p.y + dy); }; l.goalKey = shift(l.goalKey); l.gateKeys = l.gateKeys.map(shift); l.falseGoalKeys = new Set(Array.from(l.falseGoalKeys).map(shift)); l.blockSet = new Set(Array.from(l.blockSet).map(shift)); l.gooseSet = new Set(Array.from(l.gooseSet).map(shift)); l.mustPassKeys = l.mustPassKeys.map(shift); l.mustCrossKeys = l.mustCrossKeys.map(shift); const newFilterMap = new Map(); l.filterMap.forEach((v, k) => newFilterMap.set(shift(k), v)); l.filterMap = newFilterMap; const newFlipMap = new Map(); l.flippingFilterMap.forEach((v, k) => newFlipMap.set(shift(k), v)); l.flippingFilterMap = newFlipMap; const newPortalMap = new Map(); l.portalMap.forEach((v, k) => { newPortalMap.set(shift(k), { dest: v.dest === -1 ? -1 : shift(v.dest), color: v.color }); }); l.portalMap = newPortalMap; l.portalVisuals = l.portalVisuals.map(pv => ({ k1: shift(pv.k1), k2: shift(pv.k2), color: pv.color })); if (APP.State.ENGINE.editor.pendingPortal) { APP.State.ENGINE.editor.pendingPortal = shift(APP.State.ENGINE.editor.pendingPortal); } APP.State.ENGINE.path = APP.State.ENGINE.path.map(shift); APP.Engine.rebuildDerivedPathState(APP.State.ENGINE); l.hints = []; APP.State.ENGINE.hinter.pathList = []; }

            function changeGridSize(delta) { if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || !APP.State.ENGINE.editor.workingLevel) return; const l = APP.State.ENGINE.editor.workingLevel; const newSize = l.grid.w + delta; if (newSize < 6 || newSize > 15) { showMessage("Size limit reached", "text-amber-500 font-bold"); return; } const bounds = APP.LevelUtils.getLevelBounds(l); let shiftX = 0, shiftY = 0; if (bounds) { const width = bounds.maxX - bounds.minX + 1; const height = bounds.maxY - bounds.minY + 1; if (newSize < width || newSize < height) { showMessage("Cannot shrink: items blocking", "text-red-500 font-bold"); return; } if (bounds.maxX >= newSize) shiftX = newSize - 1 - bounds.maxX; if (bounds.maxY >= newSize) shiftY = newSize - 1 - bounds.maxY; } APP.Editor.saveEditorState(); if (shiftX !== 0 || shiftY !== 0) { APP.LevelUtils.shiftLevel(l, shiftX, shiftY); APP.State.ENGINE.editor.validTrapSpots.clear(); } l.grid.w = newSize; l.grid.h = newSize; const pathOutOfBounds = APP.State.ENGINE.path.some(k => { const p = APP.LevelUtils.UNPACK(k); return p.x < 0 || p.y < 0 || p.x >= newSize || p.y >= newSize; }); if (pathOutOfBounds) APP.Engine.PathNavigator.clear(APP.State.ENGINE); APP.State.ENGINE.editor.isModified = true; updateViewport(); showMessage(`Grid: ${newSize}x${newSize}`, "text-sky-600 font-bold"); }

            function transformLevel(l, coordMap, newW, newH, axisMap) { APP.Editor.saveEditorState(); const mapKey = (k) => { if (k === -1) return -1; const p = APP.LevelUtils.UNPACK(k); const tp = coordMap(p.x, p.y); return APP.LevelUtils.PACK(tp.x, tp.y); }; l.goalKey = mapKey(l.goalKey); l.gateKeys = l.gateKeys.map(mapKey); l.falseGoalKeys = new Set(Array.from(l.falseGoalKeys).map(mapKey)); l.blockSet = new Set(Array.from(l.blockSet).map(mapKey)); l.gooseSet = new Set(Array.from(l.gooseSet).map(mapKey)); l.mustPassKeys = l.mustPassKeys.map(mapKey); l.mustCrossKeys = l.mustCrossKeys.map(mapKey); const newFilterMap = new Map(); l.filterMap.forEach((v, k) => newFilterMap.set(mapKey(k), axisMap(v))); l.filterMap = newFilterMap; const newFlipMap = new Map(); l.flippingFilterMap.forEach((v, k) => newFlipMap.set(mapKey(k), axisMap(v))); l.flippingFilterMap = newFlipMap; const newPortalMap = new Map(); l.portalMap.forEach((v, k) => { newPortalMap.set(mapKey(k), { dest: v.dest === -1 ? -1 : mapKey(v.dest), color: v.color }); }); l.portalMap = newPortalMap; l.portalVisuals = l.portalVisuals.map(pv => ({ k1: mapKey(pv.k1), k2: mapKey(pv.k2), color: pv.color })); if (APP.State.ENGINE.editor.pendingPortal) { APP.State.ENGINE.editor.pendingPortal = mapKey(APP.State.ENGINE.editor.pendingPortal); } APP.State.ENGINE.path = APP.State.ENGINE.path.map(mapKey); if(APP.State.ENGINE.activeGateKey) APP.State.ENGINE.activeGateKey = mapKey(APP.State.ENGINE.activeGateKey); APP.Engine.rebuildDerivedPathState(APP.State.ENGINE); l.grid.w = newW; l.grid.h = newH; l.hints = []; APP.State.ENGINE.hinter.pathList = []; APP.State.ENGINE.editor.validTrapSpots.clear(); APP.State.ENGINE.editor.isModified = true; updateViewport(); }

            function getLevelBounds(l) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; const update = (k) => { if (k === -1) return; const p = APP.LevelUtils.UNPACK(k); if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y; if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y; }; if (l.goalKey !== -1) update(l.goalKey); l.gateKeys.forEach(update); l.falseGoalKeys.forEach(update); l.blockSet.forEach(update); l.gooseSet.forEach(update); l.mustPassKeys.forEach(update); l.mustCrossKeys.forEach(update); l.filterMap.forEach((v, k) => update(k)); l.flippingFilterMap.forEach((v, k) => update(k)); l.portalMap.forEach((v, k) => update(k)); if (minX === Infinity) return null; return { minX, minY, maxX, maxY }; }

            function assertLevelShape(level) { if (!level) throw new Error("Level object is null"); if (level.goalKey === undefined || level.goalKey === -1) throw new Error("Level missing goal"); if (!Array.isArray(level.gateKeys) || level.gateKeys.length === 0) throw new Error("Level missing gates"); if (!level.grid || !level.grid.w || !level.grid.h) throw new Error("Grid dimensions missing"); }

        return {
            PACK, UNPACK, inBounds, expCoords, transformPoint, inverseTransformPoint,
            transformAxis, getGridCoord, deepCloneLevel, normalizeLevel, denormalizeLevel,
            shiftLevel, changeGridSize, transformLevel, getLevelBounds, assertLevelShape
        };
    })();

    const setSolversActive = (active) => {
        APP.UI.setSolverControlsEnabled(active);
    };

    function resolvePortal(level, key) { return level.portalMap.has(key) ? level.portalMap.get(key) : null; }

    const SOUND_BUS = { play(freq, dur = "16n") { if (!APP.State.ENGINE.muted && window.Tone && Tone.context.state === 'running') { new Tone.Synth().toDestination().triggerAttackRelease(freq, dur); } } };







    APP.Themes = (() => {
    function rc() { return `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; }

    const THEMES = {
    "classic": {
        "bodyBg": "#e0f2fe",
        "canvasBg": "#ffffff",
        "grid": "#94a3b8",
        "headerLeft": "#dc2626",
        "headerRight": "#2563eb",
        "path": "rainbow",
        "controls": "rgba(255, 255, 255, 0.7)",
        "metricText": "#ffffff",
        "btns": {
            "undo": "#4c566a",
            "reset": "#d12929",
            "guide": "#8c33db",
            "whoa": "#2563eb",
            "hint": "#cf6b17",
            "saved": "#0a8a65",
            "mega": "#ba29c9",
            "mute": "#e1e7f0",
            "muteIcon": "#64748b",
            "copy": "#e1e7f0",
            "gen": "#e1e7f0",
            "modeToggle": "#1a2438",
            "orient": "#1a2438",
            "solve": "#ba29c9",
            "editClear": "#d12929",
            "editBombs": "#ef4444",
            "editNew": "#0a8a65"
        },
        "modal": {
            "bg": "rgba(248, 250, 252, 0.95)",
            "panelBg": "#ffffff",
            "border": "#cbd5e1",
            "text": "#334155",
            "textMuted": "#64748b",
            "accent": "#0f172a"
        },
        "output": {
            "bg": "#0f172a",
            "text": "#38bdf8"
        },
        "colors": {
            "gate": "#3b82f6",
            "goal": "#ef4444",
            "block": "#cbd5e1",
            "pin": "#ef4444",
            "pinUnflipped": "#000000",
            "filter": "#000000",
            "portal": "#d946ef",
            "cross": "#000000"
        },
        "palette": {
            "bg": "#f8fafc",
            "border": "#cbd5e1",
            "itemBg": "#ffffff",
            "itemBorder": "#cbd5e1",
            "toolBg": "#f1f5f9"
        },
        "headerLeftText": "#ffffff",
        "headerLeftLabel": "rgba(255, 255, 255, 0.7)",
        "ghostBg": "#ffffff",
        "ghostBorder": "#0ea5e9",
        "win": {
            "bg": "#ffffff",
            "border": "#3b82f6",
            "text": "#64748b",
            "accent": "#1e3a8a"
        },
        "alert": {
            "bg": "#1e40af",
            "stroke": "#93c5fd"
        },
        "ctrlArea": {
            "bg": "#f1f5f9",
            "border": "#cbd5e1"
        },
        "text": {
            "modal": "#334155",
            "modalMuted": "#64748b",
            "modalAccent": "#0f172a",
            "output": "#38bdf8",
            "metric": "#ffffff",
            "headerMain": "#ffffff",
            "headerSub": "rgba(255, 255, 255, 0.7)",
            "win": "#64748b",
            "winAccent": "#1e3a8a",
            "megaDesc": "#64748b",
            "megaOutput": "#38bdf8",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#334155"
        },
        "mega": {
            "outputBg": "#0f172a",
            "outputBorder": "#cbd5e1",
            "primaryBg": "#ba29c9",
            "primaryBorder": "#d946ef",
            "secondaryBg": "#86198f",
            "secondaryBorder": "#d946ef",
            "geminiBg": "#4338ca",
            "geminiBorder": "#6366f1",
            "copyBg": "#e1e7f0",
            "copyBorder": "#cbd5e1"
        },
        "burst": "#ffe135",
        "check": "#1e293b",
        "leave": {
            "bg": "#dc2626",
            "hover": "#b91c1c",
            "text": "#ffffff",
            "border": "#b91c1c"
        }
    },
    "dark": {
        "bodyBg": "#020617",
        "canvasBg": "#111827",
        "grid": "#475569",
        "headerLeft": "#7f1d1d",
        "headerRight": "#1e3a8a",
        "path": "#22c55e",
        "controls": "rgba(30, 41, 59, 0.9)",
        "metricText": "#f1f5f9",
        "btns": {
            "undo": "#374151",
            "reset": "#7f1d1d",
            "guide": "#4c1d95",
            "whoa": "#1e3a8a",
            "hint": "#b45309",
            "saved": "#064e3b",
            "mega": "#701a75",
            "mute": "#1e293b",
            "muteIcon": "#94a3b8",
            "copy": "#1e293b",
            "gen": "#1e293b",
            "modeToggle": "#000000",
            "orient": "#000000",
            "solve": "#374151",
            "editClear": "#7f1d1d",
            "editBombs": "#f43f5e",
            "editNew": "#064e3b"
        },
        "modal": {
            "bg": "rgba(15, 23, 42, 0.95)",
            "panelBg": "#1e293b",
            "border": "#334155",
            "text": "#f8fafc",
            "textMuted": "#94a3b8",
            "accent": "#38bdf8"
        },
        "output": {
            "bg": "#020617",
            "text": "#22c55e"
        },
        "colors": {
            "gate": "#38bdf8",
            "goal": "#f43f5e",
            "block": "#1e293b",
            "pin": "#f43f5e",
            "pinUnflipped": "#64748b",
            "filter": "#94a3b8",
            "portal": "#d946ef",
            "cross": "#94a3b8"
        },
        "palette": {
            "bg": "#0f172a",
            "border": "#334155",
            "itemBg": "#1e293b",
            "itemBorder": "#334155",
            "toolBg": "#0f172a"
        },
        "headerLeftText": "#f1f5f9",
        "headerLeftLabel": "rgba(241, 245, 249, 0.7)",
        "ghostBg": "#1e293b",
        "ghostBorder": "#38bdf8",
        "win": {
            "bg": "#1e293b",
            "border": "#38bdf8",
            "text": "#94a3b8",
            "accent": "#f8fafc"
        },
        "alert": {
            "bg": "#7f1d1d",
            "stroke": "#fca5a5"
        },
        "ctrlArea": {
            "bg": "#0f172a",
            "border": "#334155"
        },
        "burst": "#334155",
        "check": "#f1f5f9",
        "text": {
            "modal": "#f8fafc",
            "modalMuted": "#94a3b8",
            "modalAccent": "#38bdf8",
            "output": "#22c55e",
            "metric": "#f1f5f9",
            "headerMain": "#f1f5f9",
            "headerSub": "rgba(241, 245, 249, 0.7)",
            "win": "#94a3b8",
            "winAccent": "#f8fafc",
            "megaDesc": "#94a3b8",
            "megaOutput": "#22c55e",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#f8fafc"
        },
        "mega": {
            "outputBg": "#020617",
            "outputBorder": "#334155",
            "primaryBg": "#701a75",
            "primaryBorder": "#334155",
            "secondaryBg": "#621666",
            "secondaryBorder": "#334155",
            "geminiBg": "#4c1d95",
            "geminiBorder": "#334155",
            "copyBg": "#1e293b",
            "copyBorder": "#334155"
        },
        "leave": {
            "bg": "#1e3a8a",
            "hover": "#193175",
            "text": "#ffffff",
            "border": "#193175"
        }
    },
    "tron": {
        "bodyBg": "#000000",
        "canvasBg": "#001d3d",
        "grid": "#00d9ff66",
        "headerLeft": "#00d9ff",
        "headerRight": "#ff00ff",
        "path": "#00d9ff",
        "controls": "rgba(0, 8, 20, 0.95)",
        "metricText": "#000000",
        "btns": {
            "undo": "#003366",
            "reset": "#990099",
            "guide": "#004080",
            "whoa": "#005099",
            "hint": "#008080",
            "saved": "#006600",
            "mega": "#ff9900",
            "mute": "#001d3d",
            "muteIcon": "#00d9ff",
            "copy": "#001d3d",
            "gen": "#001d3d",
            "modeToggle": "#001122",
            "orient": "#001122",
            "solve": "#003366",
            "editClear": "#990099",
            "editBombs": "#ff00ff",
            "editNew": "#006600"
        },
        "modal": {
            "bg": "rgba(0, 8, 20, 0.95)",
            "panelBg": "#001d3d",
            "border": "#00d9ff",
            "text": "#00d9ff",
            "textMuted": "#004e64",
            "accent": "#ff00ff"
        },
        "output": {
            "bg": "#000814",
            "text": "#ff00ff"
        },
        "colors": {
            "gate": "#00d9ff",
            "goal": "#ff00ff",
            "block": "#001d3d",
            "pin": "#ff00ff",
            "pinUnflipped": "#004e64",
            "filter": "#00d9ff",
            "portal": "#ff00ff",
            "cross": "#00d9ff"
        },
        "palette": {
            "bg": "#000814",
            "border": "#00d9ff",
            "itemBg": "#001d3d",
            "itemBorder": "#00d9ff",
            "toolBg": "#000814"
        },
        "headerLeftText": "#000000",
        "headerLeftLabel": "rgba(0, 0, 0, 0.7)",
        "ghostBg": "#001d3d",
        "ghostBorder": "#ff00ff",
        "win": {
            "bg": "#000814",
            "border": "#ff00ff",
            "text": "#00d9ff",
            "accent": "#ff00ff"
        },
        "alert": {
            "bg": "#001d3d",
            "stroke": "#00d9ff"
        },
        "ctrlArea": {
            "bg": "#000814",
            "border": "#00d9ff"
        },
        "burst": "#00d9ff",
        "check": "#1e293b",
        "text": {
            "modal": "#00d9ff",
            "modalMuted": "#004e64",
            "modalAccent": "#ff00ff",
            "output": "#ff00ff",
            "metric": "#000000",
            "headerMain": "#000000",
            "headerSub": "rgba(0, 0, 0, 0.7)",
            "win": "#00d9ff",
            "winAccent": "#ff00ff",
            "megaDesc": "#004e64",
            "megaOutput": "#ff00ff",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#00d9ff"
        },
        "mega": {
            "outputBg": "#000814",
            "outputBorder": "#00d9ff",
            "primaryBg": "#ff9900",
            "primaryBorder": "#00d9ff",
            "secondaryBg": "#e08600",
            "secondaryBorder": "#00d9ff",
            "geminiBg": "#004080",
            "geminiBorder": "#00d9ff",
            "copyBg": "#001d3d",
            "copyBorder": "#00d9ff"
        },
        "leave": {
            "bg": "#ff00ff",
            "hover": "#d800d8",
            "text": "#ffffff",
            "border": "#d800d8"
        }
    },
    "paper": {
        "bodyBg": "#fdf6e3",
        "canvasBg": "#fffaf0",
        "grid": "#3b3b3b66",
        "headerLeft": "#000000",
        "headerRight": "#555555",
        "path": "#000000",
        "controls": "rgba(255, 250, 240, 0.9)",
        "metricText": "#fdf6e3",
        "btns": {
            "undo": "#5a5a5a",
            "reset": "#333333",
            "guide": "#4a4a4a",
            "whoa": "#3d3d3d",
            "hint": "#6b6b6b",
            "saved": "#2e4a3d",
            "mega": "#2b2b2b",
            "mute": "#eee8d5",
            "muteIcon": "#000000",
            "copy": "#eee8d5",
            "gen": "#eee8d5",
            "modeToggle": "#1a1a1a",
            "orient": "#1a1a1a",
            "solve": "#5a5a5a",
            "editClear": "#333333",
            "editBombs": "#000000",
            "editNew": "#2e4a3d"
        },
        "modal": {
            "bg": "rgba(245, 230, 196, 0.95)",
            "panelBg": "#fdf6e3",
            "border": "#3b3b3b",
            "text": "#1a1a1a",
            "textMuted": "#5a5a5a",
            "accent": "#000000"
        },
        "output": {
            "bg": "#eee8d5",
            "text": "#000000"
        },
        "colors": {
            "gate": "#000000",
            "goal": "#000000",
            "block": "#cccccc",
            "pin": "#000000",
            "pinUnflipped": "#999999",
            "filter": "#000000",
            "portal": "#555555",
            "cross": "#000000"
        },
        "palette": {
            "bg": "#eee8d5",
            "border": "#3b3b3b",
            "itemBg": "#fdf6e3",
            "itemBorder": "#3b3b3b",
            "toolBg": "#eee8d5"
        },
        "headerLeftText": "#fdf6e3",
        "headerLeftLabel": "rgba(253, 246, 227, 0.7)",
        "ghostBg": "#fdf6e3",
        "ghostBorder": "#000000",
        "win": {
            "bg": "#fdf6e3",
            "border": "#3b82f6",
            "text": "#5a5a5a",
            "accent": "#1a1a1a"
        },
        "alert": {
            "bg": "#3b3b3b",
            "stroke": "#fdf6e3"
        },
        "ctrlArea": {
            "bg": "#eee8d5",
            "border": "#3b3b3b"
        },
        "burst": "#eee8d5",
        "check": "#000000",
        "text": {
            "modal": "#1a1a1a",
            "modalMuted": "#5a5a5a",
            "modalAccent": "#000000",
            "output": "#000000",
            "metric": "#fdf6e3",
            "headerMain": "#fdf6e3",
            "headerSub": "rgba(253, 246, 227, 0.7)",
            "win": "#5a5a5a",
            "winAccent": "#1a1a1a",
            "megaDesc": "#5a5a5a",
            "megaOutput": "#000000",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#1a1a1a"
        },
        "mega": {
            "outputBg": "#eee8d5",
            "outputBorder": "#3b3b3b",
            "primaryBg": "#2b2b2b",
            "primaryBorder": "#3b3b3b",
            "secondaryBg": "#252525",
            "secondaryBorder": "#3b3b3b",
            "geminiBg": "#4a4a4a",
            "geminiBorder": "#3b3b3b",
            "copyBg": "#eee8d5",
            "copyBorder": "#3b3b3b"
        },
        "leave": {
            "bg": "#555555",
            "hover": "#484848",
            "text": "#ffffff",
            "border": "#484848"
        }
    },
    "winter": {
        "bodyBg": "#e0f2fe",
        "canvasBg": "#f0f9ff",
        "grid": "#7dd3fcaa",
        "headerLeft": "#0ea5e9",
        "headerRight": "#0284c7",
        "path": "#2563eb",
        "controls": "rgba(240, 249, 255, 0.9)",
        "metricText": "#f0f9ff",
        "btns": {
            "undo": "#0369a1",
            "reset": "#be123c",
            "guide": "#6d28d9",
            "whoa": "#1d4ed8",
            "hint": "#0f766e",
            "saved": "#15803d",
            "mega": "#db2777",
            "mute": "#bae6fd",
            "muteIcon": "#0369a1",
            "copy": "#bae6fd",
            "gen": "#bae6fd",
            "modeToggle": "#075985",
            "orient": "#075985",
            "solve": "#0284c7",
            "editClear": "#be123c",
            "editBombs": "#2563eb",
            "editNew": "#15803d"
        },
        "modal": {
            "bg": "rgba(255, 255, 255, 0.95)",
            "panelBg": "#f0f9ff",
            "border": "#0ea5e9",
            "text": "#0c4a6e",
            "textMuted": "#0284c7",
            "accent": "#0369a1"
        },
        "output": {
            "bg": "#0c4a6e",
            "text": "#f0f9ff"
        },
        "colors": {
            "gate": "#0ea5e9",
            "goal": "#2563eb",
            "block": "#bae6fd",
            "pin": "#2563eb",
            "pinUnflipped": "#7dd3fc",
            "filter": "#0ea5e9",
            "portal": "#38bdf8",
            "cross": "#0ea5e9"
        },
        "palette": {
            "bg": "#e0f2fe",
            "border": "#0ea5e9",
            "itemBg": "#f0f9ff",
            "itemBorder": "#0ea5e9",
            "toolBg": "#e0f2fe"
        },
        "headerLeftText": "#ffffff",
        "headerLeftLabel": "rgba(255, 255, 255, 0.7)",
        "ghostBg": "#f0f9ff",
        "ghostBorder": "#0284c7",
        "win": {
            "bg": "#f0f9ff",
            "border": "#0ea5e9",
            "text": "#0284c7",
            "accent": "#0369a1"
        },
        "alert": {
            "bg": "#0ea5e9",
            "stroke": "#ffffff"
        },
        "ctrlArea": {
            "bg": "#e0f2fe",
            "border": "#0ea5e9"
        },
        "burst": "#e0f2fe",
        "check": "#0369a1",
        "text": {
            "modal": "#0c4a6e",
            "modalMuted": "#0284c7",
            "modalAccent": "#0369a1",
            "output": "#f0f9ff",
            "metric": "#f0f9ff",
            "headerMain": "#ffffff",
            "headerSub": "rgba(255, 255, 255, 0.7)",
            "win": "#0284c7",
            "winAccent": "#0369a1",
            "megaDesc": "#0284c7",
            "megaOutput": "#f0f9ff",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#0c4a6e"
        },
        "mega": {
            "outputBg": "#0c4a6e",
            "outputBorder": "#0ea5e9",
            "primaryBg": "#db2777",
            "primaryBorder": "#0ea5e9",
            "secondaryBg": "#c02268",
            "secondaryBorder": "#0ea5e9",
            "geminiBg": "#6d28d9",
            "geminiBorder": "#0ea5e9",
            "copyBg": "#bae6fd",
            "copyBorder": "#0ea5e9"
        },
        "leave": {
            "bg": "#0284c7",
            "hover": "#0170a9",
            "text": "#ffffff",
            "border": "#0170a9"
        }
    },
    "summer": {
        "bodyBg": "#fff7ed",
        "canvasBg": "#ffedd5",
        "grid": "#fb923caa",
        "headerLeft": "#ea580c",
        "headerRight": "#f97316",
        "path": "#16a34a",
        "controls": "rgba(255, 237, 213, 0.9)",
        "metricText": "#fff7ed",
        "btns": {
            "undo": "#c2410c",
            "reset": "#b91c1c",
            "guide": "#b45309",
            "whoa": "#be185d",
            "hint": "#ca8a04",
            "saved": "#15803d",
            "mega": "#ef4444",
            "mute": "#fed7aa",
            "muteIcon": "#9a3412",
            "copy": "#fed7aa",
            "gen": "#fed7aa",
            "modeToggle": "#431407",
            "orient": "#431407",
            "solve": "#b45309",
            "editClear": "#991b1b",
            "editBombs": "#16a34a",
            "editNew": "#15803d"
        },
        "modal": {
            "bg": "rgba(254, 243, 199, 0.95)",
            "panelBg": "#fff7ed",
            "border": "#ea580c",
            "text": "#431407",
            "textMuted": "#9a3412",
            "accent": "#ea580c"
        },
        "output": {
            "bg": "#431407",
            "text": "#fb923c"
        },
        "colors": {
            "gate": "#ea580c",
            "goal": "#16a34a",
            "block": "#fed7aa",
            "pin": "#16a34a",
            "pinUnflipped": "#fb923c",
            "filter": "#ea580c",
            "portal": "#f97316",
            "cross": "#ea580c"
        },
        "palette": {
            "bg": "#fff7ed",
            "border": "#ea580c",
            "itemBg": "#ffedd5",
            "itemBorder": "#ea580c",
            "toolBg": "#fff7ed"
        },
        "headerLeftText": "#fff7ed",
        "headerLeftLabel": "rgba(255, 247, 237, 0.7)",
        "ghostBg": "#ffedd5",
        "ghostBorder": "#ea580c",
        "win": {
            "bg": "#ffedd5",
            "border": "#ea580c",
            "text": "#9a3412",
            "accent": "#431407"
        },
        "alert": {
            "bg": "#ea580c",
            "stroke": "#ffedd5"
        },
        "ctrlArea": {
            "bg": "#fff7ed",
            "border": "#ea580c"
        },
        "burst": "#fef9c3",
        "check": "#ea580c",
        "text": {
            "modal": "#431407",
            "modalMuted": "#9a3412",
            "modalAccent": "#ea580c",
            "output": "#fb923c",
            "metric": "#fff7ed",
            "headerMain": "#fff7ed",
            "headerSub": "rgba(255, 247, 237, 0.7)",
            "win": "#9a3412",
            "winAccent": "#431407",
            "megaDesc": "#9a3412",
            "megaOutput": "#fb923c",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#431407"
        },
        "mega": {
            "outputBg": "#431407",
            "outputBorder": "#ea580c",
            "primaryBg": "#ef4444",
            "primaryBorder": "#ea580c",
            "secondaryBg": "#d23b3b",
            "secondaryBorder": "#ea580c",
            "geminiBg": "#b45309",
            "geminiBorder": "#ea580c",
            "copyBg": "#fed7aa",
            "copyBorder": "#ea580c"
        },
        "leave": {
            "bg": "#f97316",
            "hover": "#d36112",
            "text": "#ffffff",
            "border": "#d36112"
        }
    },
    "glf": {
        "bodyBg": "#bdc3c7",
        "canvasBg": "#ecf0f1",
        "grid": "#95a5a6",
        "headerLeft": "#D21F1B",
        "headerRight": "#4A90E2",
        "path": "#F4D03F",
        "controls": "rgba(236, 240, 241, 0.8)",
        "metricText": "#ecf0f1",
        "btns": {
            "undo": "#34495e",
            "reset": "#D21F1B",
            "guide": "#558735",
            "whoa": "#2a6ebd",
            "hint": "#d35400",
            "saved": "#27ae60",
            "mega": "#a51815",
            "mute": "#bdc3c7",
            "muteIcon": "#2c3e50",
            "copy": "#bdc3c7",
            "gen": "#bdc3c7",
            "modeToggle": "#2c3e50",
            "orient": "#2c3e50",
            "solve": "#c4a112",
            "editClear": "#a51815",
            "editBombs": "#F4D03F",
            "editNew": "#27ae60"
        },
        "modal": {
            "bg": "rgba(213, 219, 219, 0.95)",
            "panelBg": "#ecf0f1",
            "border": "#95a5a6",
            "text": "#2c3e50",
            "textMuted": "#7f8c8d",
            "accent": "#D21F1B"
        },
        "output": {
            "bg": "#2c3e50",
            "text": "#93C572"
        },
        "colors": {
            "gate": "#D21F1B",
            "goal": "#F4D03F",
            "block": "#bdc3c7",
            "pin": "#D21F1B",
            "pinUnflipped": "#7f8c8d",
            "filter": "#2c3e50",
            "portal": "#4A90E2",
            "cross": "#D21F1B"
        },
        "palette": {
            "bg": "#ecf0f1",
            "border": "#D21F1B",
            "itemBg": "#bdc3c7",
            "itemBorder": "#95a5a6",
            "toolBg": "#ecf0f1"
        },
        "headerLeftText": "#ffffff",
        "headerLeftLabel": "rgba(255, 255, 255, 0.7)",
        "ghostBg": "#bdc3c7",
        "ghostBorder": "#D21F1B",
        "win": {
            "bg": "#ecf0f1",
            "border": "#D21F1B",
            "text": "#7f8c8d",
            "accent": "#2c3e50"
        },
        "alert": {
            "bg": "#2c3e50",
            "stroke": "#ecf0f1"
        },
        "ctrlArea": {
            "bg": "#ecf0f1",
            "border": "#95a5a6"
        },
        "burst": "#ecf0f1",
        "check": "#D21F1B",
        "text": {
            "modal": "#2c3e50",
            "modalMuted": "#7f8c8d",
            "modalAccent": "#D21F1B",
            "output": "#93C572",
            "metric": "#ecf0f1",
            "headerMain": "#ffffff",
            "headerSub": "rgba(255, 255, 255, 0.7)",
            "win": "#7f8c8d",
            "winAccent": "#2c3e50",
            "megaDesc": "#7f8c8d",
            "megaOutput": "#93C572",
            "megaPrimary": "#ffffff",
            "megaSecondary": "#ffffff",
            "megaGemini": "#ffffff",
            "megaCopy": "#2c3e50"
        },
        "mega": {
            "outputBg": "#2c3e50",
            "outputBorder": "#95a5a6",
            "primaryBg": "#a51815",
            "primaryBorder": "#95a5a6",
            "secondaryBg": "#911512",
            "secondaryBorder": "#95a5a6",
            "geminiBg": "#558735",
            "geminiBorder": "#95a5a6",
            "copyBg": "#bdc3c7",
            "copyBorder": "#95a5a6"
        },
        "leave": {
            "bg": "#4A90E2",
            "hover": "#3e7ac0",
            "text": "#ffffff",
            "border": "#3e7ac0"
        }
    }
};

    function isValidHexColor(value) {
        return typeof value === 'string' && /^#[0-9a-fA-F]{6}$/.test(value.trim());
    }

    function parseGeminiSuggestionsText(text) {
        const parseCandidates = [];
        if (typeof text === 'string' && text.trim()) {
            parseCandidates.push(text);
            const fencedMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
            if (fencedMatch?.[1]) parseCandidates.push(fencedMatch[1]);
        }

        let parsed = null;
        let parseError = null;
        for (const candidateText of parseCandidates) {
            try {
                parsed = JSON.parse(candidateText);
                parseError = null;
                break;
            } catch (err) {
                parseError = err;
            }
        }
        if (!parsed) return { colors: null, error: parseError ? `Invalid JSON response: ${parseError.message}` : 'No JSON response text returned.' };

        if (!Array.isArray(parsed.suggestions)) return { colors: null, error: 'Invalid schema: suggestions must be an array.' };
        const normalized = [];
        for (const raw of parsed.suggestions) {
            const color = typeof raw === 'string' ? raw.trim() : '';
            if (isValidHexColor(color)) normalized.push(color.toUpperCase());
        }
        const unique = Array.from(new Set(normalized));
        if (unique.length < 6) return { colors: null, error: 'Invalid schema: need 6 valid #RRGGBB colors.' };
        return { colors: unique.slice(0, 6), error: null };
    }

    async function fetchGeminiThemeColors(themeName, themeObj) {
        const systemPrompt = "You are a professional UI/UX color palette specialist. Your goal is to analyze the provided Pathfinder game theme and suggest exactly 6 new hex colors that expand the existing palette while maintaining visual consistency and accessibility.";
        const userPrompt = `Theme Name: ${themeName}
Current Colors: ${JSON.stringify(themeObj)}

Suggest 6 complementary hex colors in #RRGGBB format.`;
        const prompt = `${systemPrompt}\n\n${userPrompt}`;
        const payload = {
            prompt,
            model: 'gemini-2.5-flash',
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        suggestions: {
                            type: "ARRAY",
                            items: { type: "STRING", pattern: "^#[0-9A-Fa-f]{6}$" },
                            minItems: 6,
                            maxItems: 6
                        }
                    },
                    required: ["suggestions"]
                }
            }
        };

        const delays = [1000, 2000, 4000, 8000, 16000];
        let lastError = null;
        for (let i = 0; i < 6; i++) {
            try {
                const res = await fetch('./api/gemini_color_suggest.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const body = await res.json().catch(() => ({}));

                if (res.status === 429) {
                    lastError = `Rate limited (${res.status}).`;
                    throw new Error('Rate Limit');
                }
                if (!res.ok) {
                    const apiMessage = body?.error || `HTTP ${res.status}`;
                    return { colors: null, error: `Suggestion API error: ${apiMessage}` };
                }
                if (!body?.ok) return { colors: null, error: body?.error || 'Unable to generate suggestions.' };

                const parsed = parseGeminiSuggestionsText(body?.text);
                if (parsed.colors) return { colors: parsed.colors, error: null };
                lastError = parsed.error;
            } catch (err) {
                if (err.message !== 'Rate Limit') lastError = err?.message || 'Unknown request failure.';
            }
            if (i < delays.length) await new Promise(r => setTimeout(r, delays[i]));
        }
        return { colors: null, error: lastError || 'Unable to generate suggestions.' };
    }

    const getCurrentTheme = () => APP.State.ENGINE.runtime.currentTheme;
    // ======================================================
    // I) Themes
    // ======================================================

    const CLASSIC_LEAVE = { bg: '#dc2626', hover: '#b91c1c', text: '#ffffff', border: '#b91c1c' };

    function toRgb(hex, fallback = { r: 220, g: 38, b: 38 }) {
        const normalized = (hex || '').replace('#', '');
        if (!/^[0-9a-fA-F]{6}$/.test(normalized)) return fallback;
        return { r: parseInt(normalized.slice(0, 2), 16), g: parseInt(normalized.slice(2, 4), 16), b: parseInt(normalized.slice(4, 6), 16) };
    }

    function darkenHex(hex, factor = 0.85) {
        const { r, g, b } = toRgb(hex);
        return `#${Math.max(0, Math.floor(r * factor)).toString(16).padStart(2, '0')}${Math.max(0, Math.floor(g * factor)).toString(16).padStart(2, '0')}${Math.max(0, Math.floor(b * factor)).toString(16).padStart(2, '0')}`;
    }

    function getLeaveThemeColors(theme, isClassic = false) {
        if (isClassic) return { ...CLASSIC_LEAVE };
        const fallbackBase = theme.headerRight || theme.btns?.editClear || theme.btns?.reset || theme.colors?.goal || '#7f1d1d';
        const leave = theme.leave || {};
        let bg = leave.bg || fallbackBase;
        if (bg.toLowerCase() === CLASSIC_LEAVE.bg) bg = theme.headerLeft || theme.colors?.goal || '#7f1d1d';
        let hover = leave.hover || darkenHex(bg, 0.85);
        if (hover.toLowerCase() === CLASSIC_LEAVE.hover) hover = darkenHex(bg, 0.78);
        const { r, g, b } = toRgb(bg);
        const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        const text = leave.text || (luminance > 0.55 ? '#0f172a' : '#ffffff');
        const border = leave.border || hover;
        return { bg, hover, text, border };
    }

    function normalizeTheme(theme, key = 'theme') {
        const t = theme || {};
        t.btns = t.btns || {};
        t.modal = t.modal || {};
        t.output = t.output || {};
        t.colors = t.colors || {};
        t.palette = t.palette || {};
        t.win = t.win || {};
        t.alert = t.alert || {};
        t.ctrlArea = t.ctrlArea || {};
        t.text = t.text || {};
        t.mega = t.mega || {};

        t.bodyBg = t.bodyBg || '#e0f2fe';
        t.canvasBg = t.canvasBg || '#ffffff';
        t.grid = t.grid || '#94a3b8';
        t.headerLeft = t.headerLeft || '#dc2626';
        t.headerRight = t.headerRight || '#2563eb';
        t.path = t.path || '#2563eb';
        t.controls = t.controls || 'rgba(255, 255, 255, 0.7)';
        t.metricText = t.metricText || '#ffffff';
        t.headerLeftText = t.headerLeftText || '#ffffff';
        t.headerLeftLabel = t.headerLeftLabel || 'rgba(255, 255, 255, 0.7)';
        t.ghostBg = t.ghostBg || t.canvasBg;
        t.ghostBorder = t.ghostBorder || t.headerRight;

        const btnFallbacks = { undo: t.grid, reset: t.headerLeft, guide: t.headerRight, whoa: t.headerRight, hint: t.headerRight, saved: t.headerRight, mega: t.headerRight, mute: t.canvasBg, muteIcon: t.headerRight, copy: t.canvasBg, gen: t.canvasBg, modeToggle: t.headerRight, orient: t.headerRight, solve: t.headerRight, editClear: t.headerLeft, editBombs: t.colors.goal || t.headerLeft, editNew: t.headerRight };
        Object.keys(btnFallbacks).forEach(btnKey => { t.btns[btnKey] = t.btns[btnKey] || btnFallbacks[btnKey]; });

        t.modal.bg = t.modal.bg || 'rgba(248, 250, 252, 0.95)';
        t.modal.panelBg = t.modal.panelBg || t.canvasBg;
        t.modal.border = t.modal.border || t.grid;
        t.modal.text = t.modal.text || t.headerRight;
        t.modal.textMuted = t.modal.textMuted || t.grid;
        t.modal.accent = t.modal.accent || t.headerLeft;

        t.output.bg = t.output.bg || t.bodyBg;
        t.output.text = t.output.text || t.modal.text;

        t.colors.gate = t.colors.gate || t.headerRight;
        t.colors.goal = t.colors.goal || t.headerLeft;
        t.colors.block = t.colors.block || t.canvasBg;
        t.colors.pin = t.colors.pin || t.colors.goal;
        t.colors.pinUnflipped = t.colors.pinUnflipped || t.grid;
        t.colors.filter = t.colors.filter || t.modal.text;
        t.colors.portal = t.colors.portal || t.headerRight;
        t.colors.cross = t.colors.cross || t.colors.filter;

        t.palette.bg = t.palette.bg || t.bodyBg;
        t.palette.border = t.palette.border || t.grid;
        t.palette.itemBg = t.palette.itemBg || t.canvasBg;
        t.palette.itemBorder = t.palette.itemBorder || t.grid;
        t.palette.toolBg = t.palette.toolBg || t.palette.bg;

        t.win.bg = t.win.bg || t.canvasBg;
        t.win.border = t.win.border || t.headerRight;
        t.win.text = t.win.text || t.modal.textMuted;
        t.win.accent = t.win.accent || t.modal.accent;

        t.alert.bg = t.alert.bg || t.headerLeft;
        t.alert.stroke = t.alert.stroke || t.grid;

        t.ctrlArea.bg = t.ctrlArea.bg || t.palette.bg;
        t.ctrlArea.border = t.ctrlArea.border || t.palette.border;

        t.text.modal = t.text.modal || t.modal.text;
        t.text.modalMuted = t.text.modalMuted || t.modal.textMuted;
        t.text.modalAccent = t.text.modalAccent || t.modal.accent;
        t.text.output = t.text.output || t.output.text;
        t.text.metric = t.text.metric || t.metricText;
        t.text.headerMain = t.text.headerMain || t.headerLeftText;
        t.text.headerSub = t.text.headerSub || t.headerLeftLabel;
        t.text.win = t.text.win || t.win.text;
        t.text.winAccent = t.text.winAccent || t.win.accent;
        t.text.megaDesc = t.text.megaDesc || t.modal.textMuted;
        t.text.megaOutput = t.text.megaOutput || t.output.text;
        t.text.megaPrimary = t.text.megaPrimary || '#ffffff';
        t.text.megaSecondary = t.text.megaSecondary || '#ffffff';
        t.text.megaGemini = t.text.megaGemini || '#ffffff';
        t.text.megaCopy = t.text.megaCopy || t.modal.text;

        t.mega.outputBg = t.mega.outputBg || t.output.bg;
        t.mega.outputBorder = t.mega.outputBorder || t.modal.border;
        t.mega.primaryBg = t.mega.primaryBg || t.btns.mega || t.headerRight;
        t.mega.primaryBorder = t.mega.primaryBorder || t.modal.border;
        t.mega.secondaryBg = t.mega.secondaryBg || darkenHex(t.mega.primaryBg, 0.88);
        t.mega.secondaryBorder = t.mega.secondaryBorder || t.modal.border;
        t.mega.geminiBg = t.mega.geminiBg || t.btns.guide || t.headerRight;
        t.mega.geminiBorder = t.mega.geminiBorder || t.modal.border;
        t.mega.copyBg = t.mega.copyBg || t.btns.copy || t.modal.panelBg;
        t.mega.copyBorder = t.mega.copyBorder || t.modal.border;

        t.burst = t.burst || t.palette.itemBg;
        t.check = t.check || t.colors.filter;
        t.leave = getLeaveThemeColors(t, key === 'classic');
        return t;
    }

    function ensureThemeLeaveColors() {
        Object.keys(APP.Themes.THEMES).forEach(key => {
            APP.Themes.THEMES[key] = normalizeTheme(APP.Themes.THEMES[key], key);
        });
    }

    function applyTheme(name) {
        if (name === 'chaos') { APP.Themes.THEMES.chaos = normalizeTheme({ bodyBg: rc(), canvasBg: rc(), grid: rc(), headerLeft: rc(), headerRight: rc(), path: rc(), controls: rc(), metricText: rc(), btns: { undo: rc(), reset: rc(), guide: rc(), whoa: rc(), hint: rc(), saved: rc(), mega: rc(), mute: rc(), muteIcon: rc(), copy: rc(), gen: rc(), modeToggle: rc(), orient: rc(), solve: rc(), editClear: rc(), editBombs: rc(), editNew: rc() }, modal: { bg: rc(), panelBg: rc(), border: rc(), text: rc(), textMuted: rc(), accent: rc() }, output: { bg: rc(), text: rc() }, colors: { gate: rc(), goal: rc(), block: rc(), pin: rc(), pinUnflipped: rc(), filter: rc(), portal: rc(), cross: rc() }, palette: { bg: rc(), border: rc(), itemBg: rc(), itemBorder: rc(), toolBg: rc() }, headerLeftText: rc(), headerLeftLabel: rc(), ghostBg: rc(), ghostBorder: rc(), win: { bg: rc(), border: rc(), text: rc(), accent: rc() }, alert: { bg: rc(), stroke: rc() }, ctrlArea: { bg: rc(), border: rc() }, text: { modal: rc(), modalMuted: rc(), modalAccent: rc(), output: rc(), metric: rc(), headerMain: rc(), headerSub: rc(), win: rc(), winAccent: rc(), megaDesc: rc(), megaOutput: rc(), megaPrimary: rc(), megaSecondary: rc(), megaGemini: rc(), megaCopy: rc() }, mega: { outputBg: rc(), outputBorder: rc(), primaryBg: rc(), primaryBorder: rc(), secondaryBg: rc(), secondaryBorder: rc(), geminiBg: rc(), geminiBorder: rc(), copyBg: rc(), copyBorder: rc() }, burst: rc(), check: rc(), leave: { bg: rc(), hover: rc(), text: rc(), border: rc() } }, 'chaos'); }
        APP.State.ENGINE.runtime.currentTheme = name;
        APP.Themes.currentTheme = APP.State.ENGINE.runtime.currentTheme;
        const t = APP.Themes.THEMES[name];
        APP.UI.applyTheme(t, { themeName: name });
        APP.State.ENGINE.rainbowActive = (name === 'classic');
    }

    function populateThemes() {
        if (!window.ORIGINAL_THEMES) {
            window.ORIGINAL_THEMES = JSON.parse(JSON.stringify(THEMES));
            delete window.ORIGINAL_THEMES['chaos'];
        }
        const grid = document.getElementById('themeGrid'); APP.UI.clearElement('themeGrid'); const themeKeys = Object.keys(APP.Themes.THEMES); if(!themeKeys.includes('chaos')) themeKeys.push('chaos');
        themeKeys.forEach(key => { const t = APP.Themes.THEMES[key] || APP.Themes.THEMES.classic; const btn = document.createElement('div'); btn.className = "flex flex-col items-center gap-2 cursor-pointer transition-transform hover:scale-105 active:scale-95 p-2 rounded-xl hover:bg-slate-100"; btn.onclick = () => { applyTheme(key); APP.UI.closeModal('themeModal'); }; const circle = document.createElement('div'); circle.className = "w-12 h-12 rounded-full border-4 shadow-md"; circle.style.backgroundColor = t.headerRight || '#000'; circle.style.borderColor = t.canvasBg || '#fff'; const label = document.createElement('span'); label.className = "text-[0.65rem] font-black text-slate-600 uppercase tracking-widest"; label.innerText = key; btn.appendChild(circle); btn.appendChild(label); grid.appendChild(btn); });
    }

    function replaceThemeColor(themeKey, oldColor, newColor, category) {
        if (!window.THEME_UNDO_STACKS) window.THEME_UNDO_STACKS = {};
        if (!window.THEME_UNDO_STACKS[themeKey]) window.THEME_UNDO_STACKS[themeKey] = [];
        window.THEME_UNDO_STACKS[themeKey].push(JSON.parse(JSON.stringify(APP.Themes.THEMES[themeKey])));

        const t = APP.Themes.THEMES[themeKey];
        const LINE_KEY_GROUPS = {
            modal: ['border'],
            palette: ['border', 'itemBorder'],
            win: ['border'],
            alert: ['stroke'],
            ctrlArea: ['border']
        };
        const replaceInKeys = (obj, keys) => {
            if (!obj) return;
            keys.forEach(key => {
                if (obj[key] === oldColor) obj[key] = newColor;
            });
        };

        if (category === "Buttons") {
            replaceInKeys(t.btns, Object.keys(t.btns || {}));
        }
        else if (category === "Grid Items") {
            replaceInKeys(t.colors, Object.keys(t.colors || {}));
            if (t.path === oldColor) t.path = newColor;
            if (t.grid === oldColor) t.grid = newColor;
        }
        else if (category === "Misc") {
            ['bodyBg', 'canvasBg', 'headerLeft', 'headerRight', 'controls', 'ghostBg', 'burst', 'check'].forEach(key => {
                if (t[key] === oldColor) t[key] = newColor;
            });
            replaceInKeys(t.modal, ['bg', 'panelBg']);
            replaceInKeys(t.output, ['bg']);
            replaceInKeys(t.palette, ['bg', 'itemBg', 'toolBg']);
            replaceInKeys(t.win, ['bg']);
            replaceInKeys(t.alert, ['bg']);
            replaceInKeys(t.ctrlArea, ['bg']);
            replaceInKeys(t.mega, ['outputBg', 'primaryBg', 'secondaryBg', 'geminiBg', 'copyBg']);
        } else if (category === "Lines") {
            replaceInKeys(t.modal, LINE_KEY_GROUPS.modal);
            replaceInKeys(t.palette, LINE_KEY_GROUPS.palette);
            replaceInKeys(t.win, LINE_KEY_GROUPS.win);
            replaceInKeys(t.alert, LINE_KEY_GROUPS.alert);
            replaceInKeys(t.ctrlArea, LINE_KEY_GROUPS.ctrlArea);
            replaceInKeys(t.mega, ['outputBorder', 'primaryBorder', 'secondaryBorder', 'geminiBorder', 'copyBorder']);
            if (t.ghostBorder === oldColor) t.ghostBorder = newColor;
            replaceInKeys(t.leave, ['border']);
        } else if (category === "Text") {
            ['metricText', 'headerLeftText', 'headerLeftLabel'].forEach(key => {
                if (t[key] === oldColor) t[key] = newColor;
            });
            replaceInKeys(t.modal, ['text', 'textMuted', 'accent']);
            replaceInKeys(t.output, ['text']);
            replaceInKeys(t.win, ['text', 'accent']);
            replaceInKeys(t.text, Object.keys(t.text || {}));
            replaceInKeys(t.leave, ['text']);
                } else {
            const replaceDeep = (obj) => {
                if (!obj || typeof obj !== 'object') return;
                for (let k in obj) {
                    if (typeof obj[k] === 'object' && obj[k] !== null) replaceDeep(obj[k]);
                    else if (obj[k] === oldColor) obj[k] = newColor;
                }
            };
            replaceDeep(t);
        }

        APP.UI.ThemeEditor.renderAll();
        APP.Themes.populateThemes();
    }

        return { THEMES, rc, isValidHexColor, parseGeminiSuggestionsText, fetchGeminiThemeColors, getCurrentTheme, toRgb, darkenHex, getLeaveThemeColors, normalizeTheme, ensureThemeLeaveColors, applyTheme, populateThemes, replaceThemeColor };
    })();

    function closeAllModals() { return APP.UI.closeAllModals(); }


    const msgEl = document.getElementById('message'); const winOutEl = document.getElementById('winSolutionOutput'); const ghostEl = document.getElementById('dragGhost');








    function isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, ctx = {}) {
        const { x, y } = APP.LevelUtils.UNPACK(key);
        const { w, h } = l.grid;
        if (!APP.LevelUtils.inBounds(x, y, w, h) || l.blockSet.has(key)) return false;
        if (ctx.mode === EDITOR && l.gooseSet.has(key)) return false;
        const lastK = path[path.length - 1];
        if (lastK === undefined) return true;
        if (ctx.mode !== EDITOR) {
            if (lastK === l.goalKey) return false;
            if (ctx.armedFalseGoals?.has(lastK)) return false;
            if (l.gateKeys.includes(key)) return false;
        } else if (path.length > 1 && l.gateKeys.includes(lastK)) return false;
        if (l.portalMap.has(lastK) && !jumpSet.has(path.length - 1)) return false;
        const lastP = APP.LevelUtils.UNPACK(lastK);
        const isPortalJumpCandidate = l.portalMap.has(lastK) && resolvePortal(l, lastK).dest === key;
        if (!isPortalJumpCandidate && Math.abs(x - lastP.x) + Math.abs(y - lastP.y) !== 1) return false;
        const axis = (y === lastP.y) ? H : V;
        const u = usage.get(key);
        if (u && ((axis === H && u.h) || (axis === V && u.v))) return false;
        const uLast = usage.get(lastK);
        if (uLast) {
            let entryAxis = NONE;
            if (path.length > 1 && !jumpSet.has(path.length - 1)) {
                const prevP = APP.LevelUtils.UNPACK(path[path.length - 2]);
                const lastP_check = APP.LevelUtils.UNPACK(lastK);
                entryAxis = (prevP.y === lastP_check.y) ? H : V;
            }
            if (axis !== entryAxis) {
                if ((axis === H && uLast.h) || (axis === V && uLast.v)) return false;
            }
        }
        const flipCount = ctx.flipCount || 0;
        const crossedSet = ctx.crossedSet || ctx.crossedFlippingFilters || new Map();
        let filterLast = l.filterMap.get(lastK);
        if (filterLast === undefined && l.flippingFilterMap.has(lastK)) {
            const relevantFlipCount = crossedSet.has(lastK) ? crossedSet.get(lastK) : flipCount;
            filterLast = (relevantFlipCount % 2 !== 0) ? (l.flippingFilterMap.get(lastK) === H ? V : H) : l.flippingFilterMap.get(lastK);
        }
        if (filterLast && filterLast !== axis) return false;
        let filterTarget = l.filterMap.get(key);
        if (filterTarget === undefined && l.flippingFilterMap.has(key)) {
            const relevantFlipCount = crossedSet.has(key) ? crossedSet.get(key) : flipCount;
            const baseAxis = l.flippingFilterMap.get(key);
            filterTarget = (relevantFlipCount % 2 !== 0) ? (baseAxis === H ? V : H) : baseAxis;
        }
        if (filterTarget && filterTarget !== axis) return false;
        return true;
    }




    const SOLVER_TIMEOUT = Symbol("solver-timeout");
    const SOLVER_ABORTED = Symbol("solver-aborted");

    function createSolverDebugStats(levelIndex = null) {
        return {
            levelIndex,
            status: "",
            nodesExpanded: 0,
            branchesTried: 0,
            maxDepth: 0,
            elapsedMs: 0,
            memoSize: 0,
            pass: "primary",
            disabledPrunes: [],
            failMemoUsed: true,
            invalidReasons: [],
            depth0: null,
            prune: {
                lenOverflow: 0,
                intsOverflow: 0,
                minRemOverflow: 0,
                mustPassBound: 0,
                mustCrossBound: 0,
                deadEnd: 0,
                failedStateHit: 0,
                illegalMove: 0,
                other: 0
            },
            notes: []
        };
    }

    function finalizeSolverDebugStats(debugStats, status, startPerf) {
        if (!debugStats) return;
        debugStats.status = status;
        debugStats.elapsedMs = Math.round(performance.now() - startPerf);
    }

    function isGoalReachableFromAnyGate(level) {
        if (!level) return false;
        const goalDistMap = SolverCore._buildDistMap(level);
        return Array.isArray(level.gateKeys) && level.gateKeys.some(gk => {
            const d = goalDistMap.get(gk);
            return d !== undefined && d !== Infinity;
        });
    }

    function appendReachabilitySanityNote(level, debugStats, solveStatus, gateReachable = null) {
        if (!debugStats || !level || (solveStatus !== 'no-solution' && solveStatus !== 'invalid')) return;
        const reachable = gateReachable === null ? isGoalReachableFromAnyGate(level) : gateReachable;
        if (reachable) {
            debugStats.notes.push("SANITY: goal reachable from at least one gate; solver returned NO-SOLUTION — check pruning/memoization");
        } else {
            debugStats.notes.push("SANITY: goal unreachable from all gates (including portals)");
        }
    }

    function formatSolverDebugBlock(levelNumber, debug) {
        const prune = debug?.prune || {};
        const lines = [
            `Level ${levelNumber}: UNSOLVED (${(debug?.status || 'unknown').toUpperCase()})`,
            `nodesExpanded=${debug?.nodesExpanded || 0} elapsedMs=${debug?.elapsedMs || 0} maxDepth=${debug?.maxDepth || 0} memoSize=${debug?.memoSize || 0} pass=${debug?.pass || 'primary'} failMemoUsed=${debug?.failMemoUsed ? 'yes' : 'no'} disabledPrunes=${(debug?.disabledPrunes || []).join(',') || 'none'}`,
            `prune: lenOverflow=${prune.lenOverflow || 0} intsOverflow=${prune.intsOverflow || 0} mustPassBound=${prune.mustPassBound || 0} mustCrossBound=${prune.mustCrossBound || 0} failedStateHit=${prune.failedStateHit || 0} deadEnd=${prune.deadEnd || 0} other=${prune.other || 0}`
        ];
        if (Array.isArray(debug?.invalidReasons) && debug.invalidReasons.length > 0) {
            lines[0] = `Level ${levelNumber}: UNSOLVED (INVALID) reasons: ${debug.invalidReasons.join('; ')}`;
        }
        if (debug?.depth0 && (debug.nodesExpanded === 0 || debug.maxDepth === 0 || debug.status === 'no-solution')) {
            lines.push(`depth0Prune: ${debug.depth0.reason} ${debug.depth0.details}`);
        }
        if (Array.isArray(debug?.notes) && debug.notes.length > 0) {
            lines.push(...debug.notes);
        }
        return lines.join('\n');
    }

    // ======================================================
    // H) Solver
    // ======================================================



    // ======================================================
    // D) Rules / ValidationAndWin
    // ======================================================
    function areWinMetricsSatisfied(state = APP.State.ENGINE, level = (state.mode === PLAY ? state.level : state.editor.workingLevel)) { if (!level || !state.path.length) return false; const curLen = APP.Engine.getRealLength(state); if (curLen !== level.reqLen || state.intersections !== level.reqInt) return false; const allMustPass = level.mustPassKeys.every(k => state.visitedCounts.get(k) > 0); const allMustCross = level.mustCrossKeys.every(k => (state.visitedCounts.get(k) || 0) >= 2); return allMustPass && allMustCross; }

    function isModalActive() { return APP.UI.isModalOpen('guideModal') || APP.UI.isModalOpen('editorHelpModal') || APP.UI.isModalOpen('winModal') || APP.UI.isModalOpen('megaModal') || APP.UI.isModalOpen('themeModal') || APP.UI.isModalOpen('unsavedModal'); }

    APP.State.ENGINE.ui.gamepadGridPrimaryAction = () => {};

    function getFocusableGroups() {
        const groups = [
            { name: 'GRID', elements: [document.getElementById('gameCanvas')] },
            { name: 'CONTROLS', elements: Array.from(document.querySelectorAll('#playControls button, #playControls [role="button"], #openThemeModalBtn, #muteBtn')).filter(el => !el.classList.contains('hidden') && el.offsetParent !== null) },
            { name: 'LEVEL', elements: [document.getElementById('prevLevelBtn'), document.getElementById('nextLevelBtn')].filter(Boolean) }
        ];
        if (APP.State.ENGINE.mode === EDITOR) groups.push({ name: 'METRICS', elements: [document.getElementById('editReqLen'), document.getElementById('editReqInt')].filter(Boolean) });
        return groups.filter(g => g.elements.length > 0);
    }

    function applyFocusVisual(el) {
        document.querySelectorAll('.gamepad-focus').forEach(node => APP.UI.removeClasses(node, ['gamepad-focus', 'ring-4', 'ring-sky-400', 'ring-offset-2']));
        if (!APP.State.ENGINE.ui.gamepadFocusEnabled || !el) return;
        APP.UI.addClasses(el, ['gamepad-focus', 'ring-4', 'ring-sky-400', 'ring-offset-2']);
        if (typeof el.focus === 'function') el.focus({ preventScroll: true });
    }

    function setFocusGroup(groupName, index = 0, forceVisual = false) {
        const groups = getFocusableGroups();
        const gIdx = Math.max(0, groups.findIndex(g => g.name === groupName));
        const group = groups[gIdx] || groups[0];
        if (!group) return;
        APP.State.ENGINE.ui.focusGroup = group.name;
        APP.State.ENGINE.ui.focusIndex = Math.max(0, Math.min(index, group.elements.length - 1));
        if (forceVisual) APP.State.ENGINE.ui.gamepadFocusEnabled = true;
        applyFocusVisual(group.elements[APP.State.ENGINE.ui.focusIndex]);
    }

    function cycleFocusGroup() {
        const groups = getFocusableGroups();
        if (!groups.length) return;
        const idx = groups.findIndex(g => g.name === APP.State.ENGINE.ui.focusGroup);
        const next = groups[(idx + 1 + groups.length) % groups.length];
        setFocusGroup(next.name, 0, true);
    }

    function moveFocusWithinGroup(delta) {
        const groups = getFocusableGroups();
        const group = groups.find(g => g.name === APP.State.ENGINE.ui.focusGroup);
        if (!group || !group.elements.length) return;
        APP.State.ENGINE.ui.focusIndex = (APP.State.ENGINE.ui.focusIndex + delta + group.elements.length) % group.elements.length;
        applyFocusVisual(group.elements[APP.State.ENGINE.ui.focusIndex]);
    }

    function activateFocusedControl() {
        const groups = getFocusableGroups();
        const group = groups.find(g => g.name === APP.State.ENGINE.ui.focusGroup);
        const el = group?.elements?.[APP.State.ENGINE.ui.focusIndex];
        if (!el) return;
        if (el.id === 'gameCanvas') {
            APP.State.ENGINE.ui.gamepadGridPrimaryAction();
            return;
        }
        el.click();
    }

    function dismissGuideOrHelpModal() {
        if (APP.UI.isModalOpen('guideModal')) { APP.UI.closeModal('guideModal'); return true; }
        if (APP.UI.isModalOpen('editorHelpModal')) { APP.UI.closeModal('editorHelpModal'); return true; }
        return false;
    }




    function updateViewport() { const canvas = APP.Renderer.getCanvas(); const rect = canvas.getBoundingClientRect(); if (rect.width === 0) return; const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel; if (!l) return; const swaps = [1, 3, 6, 7]; APP.State.ENGINE.viewport.swapped = swaps.includes(APP.State.ENGINE.variant); const gridW = APP.State.ENGINE.viewport.swapped ? l.grid.h : l.grid.w, gridH = APP.State.ENGINE.viewport.swapped ? l.grid.w : l.grid.h; APP.State.ENGINE.viewport.cellW = canvas.width / gridW; APP.State.ENGINE.viewport.cellH = canvas.height / gridH; }


    function showMessage(t, c) { return APP.UI.showMessage(t, c); }

    // ======================================================
    // F/G/H) Input + UI Wiring + Solver Boot
    // ======================================================
    APP.Input = (() => {
        let initialized = false;
        const init = () => {
            if (initialized) return;
            initialized = true;
        const tryNavigate = (actionFn) => { if (APP.State.ENGINE.mode === EDITOR && APP.State.ENGINE.editor.isModified) { APP.State.ENGINE.runtime.pendingAction = actionFn; APP.UI.openModal('unsavedModal'); } else { actionFn(); } };
        document.getElementById('unsavedStayBtn').onclick = () => { APP.UI.closeAllModals(); APP.State.ENGINE.runtime.pendingAction = null; APP.UI.closeModal('unsavedModal'); };
        document.getElementById('unsavedLeaveBtn').onclick = () => { APP.UI.closeAllModals(); APP.UI.closeModal('unsavedModal'); if (APP.State.ENGINE.runtime.pendingAction) APP.State.ENGINE.runtime.pendingAction(); };

        const handleGridPressAtPoint = (clientX, clientY) => handleDown({ clientX, clientY });
        APP.State.ENGINE.ui.gamepadGridPrimaryAction = () => {
            const canvas = APP.Renderer.getCanvas(); const rect = canvas.getBoundingClientRect();
            handleGridPressAtPoint(rect.left + rect.width / 2, rect.top + rect.height / 2);
        };

        const handleDown = (e) => {
            if (APP.State.ENGINE.activeSolverController || [RESOLVED, HAZARD_TRIGGERED].includes(APP.State.ENGINE.logicState) || [HINT_ANIMATING, FALSE_GOAL_ANIMATING, SOLVER_RUNNING].includes(APP.State.ENGINE.overlayState)) return;
            const p = APP.LevelUtils.getGridCoord(e); const k = APP.LevelUtils.PACK(p.x, p.y); const activeLevel = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel;
            APP.State.ENGINE.resetStreak = 0;
            if (APP.State.ENGINE.mode === EDITOR && !APP.State.ENGINE.editor.isPencilMode) {
                const occupied = activeLevel.gateKeys.includes(k) || activeLevel.goalKey === k || activeLevel.falseGoalKeys.has(k) || activeLevel.blockSet.has(k) || activeLevel.gooseSet.has(k) || activeLevel.filterMap.has(k) || activeLevel.flippingFilterMap.has(k) || activeLevel.portalMap.has(k) || activeLevel.mustPassKeys.includes(k) || activeLevel.mustCrossKeys.includes(k);
                if (occupied) { APP.State.ENGINE.editor.emptyClickCount = 0; APP.State.ENGINE.editor.draggedObject = APP.Editor.pickUpObject(k); if (APP.State.ENGINE.editor.draggedObject) { APP.Engine.setLogicState(EDIT_DRAG); APP.UI.EditorDragGhost.update({ visible: true, cellSize: APP.State.ENGINE.viewport.cellW, type: APP.State.ENGINE.editor.draggedObject.type }); } } else if (APP.State.ENGINE.editor.selectedTool) { APP.State.ENGINE.editor.emptyClickCount = 0; APP.Editor.placeEditorObject(k); } else { APP.State.ENGINE.editor.emptyClickCount++; if (APP.State.ENGINE.editor.emptyClickCount >= 2) { showMessage("Click pencil to draw.", "text-white font-bold"); } } return;
            }
            if (APP.State.ENGINE.path.length > 0) {
                if (APP.State.ENGINE.path.length === 1 && activeLevel.gateKeys.includes(k) && k !== APP.State.ENGINE.activeGateKey) {
                    APP.Engine.PathNavigator.clear(APP.State.ENGINE);
                    APP.State.ENGINE.activeGateKey = k;
                    APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, k, false);
                    APP.Engine.setLogicState(DRAGGING);
                    return;
                }
                if (APP.State.ENGINE.mode === EDITOR && APP.State.ENGINE.editor.isPencilMode) {
                    const idx = APP.State.ENGINE.path.indexOf(k); let shouldReverse = false;
                    if (idx !== -1) { if (idx < APP.State.ENGINE.path.length / 2) shouldReverse = true; } else { const headP = APP.LevelUtils.UNPACK(APP.State.ENGINE.path[APP.State.ENGINE.path.length - 1]); const tailP = APP.LevelUtils.UNPACK(APP.State.ENGINE.path[0]); const distHead = Math.abs(p.x - headP.x) + Math.abs(p.y - headP.y); const distTail = Math.abs(p.x - tailP.x) + Math.abs(p.y - tailP.y); if (distTail < distHead) shouldReverse = true; }
                    if (shouldReverse) { APP.State.ENGINE.path.reverse(); const newJumps = new Set(); APP.State.ENGINE.isPortalJump.forEach(jIdx => newJumps.add(APP.State.ENGINE.path.length - jIdx)); APP.State.ENGINE.isPortalJump = newJumps; APP.Engine.rebuildDerivedPathState(APP.State.ENGINE); }
                }
                const lastIdx = APP.State.ENGINE.path.lastIndexOf(k); if (lastIdx !== -1 && lastIdx < APP.State.ENGINE.path.length - 1) { APP.Engine.PathNavigator.truncateTo(APP.State.ENGINE, lastIdx); APP.Engine.setLogicState(DRAGGING); return; }
                APP.Engine.setLogicState(DRAGGING); APP.Engine.handlePrimaryGridInput(p);
            } else {
                if (!activeLevel) return;
                if (APP.State.ENGINE.mode === EDITOR && APP.State.ENGINE.editor.isPencilMode) { APP.State.ENGINE.activeGateKey = null; APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, k, false); APP.Engine.setLogicState(DRAGGING); APP.Engine.handlePrimaryGridInput(p); } else {
                    let bestGate = null; if (activeLevel.gateKeys.includes(k)) { bestGate = k; } else { let minDist = Infinity; for (let i = 0; i < activeLevel.gateKeys.length; i++) { const gk = activeLevel.gateKeys[i]; const gp = APP.LevelUtils.UNPACK(gk); if (p.x === gp.x || p.y === gp.y) { const dist = Math.abs(p.x - gp.x) + Math.abs(p.y - gp.y); if (dist > 0 && dist < minDist) { minDist = dist; bestGate = gk; } } } }
                    if (bestGate !== null) { APP.State.ENGINE.activeGateKey = bestGate; APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, bestGate, false); APP.Engine.setLogicState(DRAGGING); if (bestGate !== k) { APP.Engine.handlePrimaryGridInput(p); } }
                }
            }
        };

        const handleUp = (e) => {
            if (APP.State.ENGINE.logicState === THEME_DRAG) {
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                const dragState = APP.UI.ThemeEditor.getDragState();
                let isSameElement = (dropTarget && dropTarget.dataset.themeColor === dragState.color);
                if (dropTarget && dropTarget.dataset.themeColor && !isSameElement && dropTarget.dataset.category === dragState.category) {
                    replaceThemeColor(dragState.theme, dropTarget.dataset.themeColor, dragState.color, dropTarget.dataset.category);
                }
                APP.Engine.setLogicState(IDLE); APP.UI.ThemeEditor.clearDragState(); APP.UI.ThemeEditor.setDragGhost({ visible: false });
                if (!APP.UI.ThemeEditor.hasTapSelection()) APP.UI.ThemeEditor.setSwatchSelected(null);
            }
            if (APP.State.ENGINE.logicState === EDIT_DRAG && APP.State.ENGINE.mode === EDITOR) { const canvas = APP.Renderer.getCanvas(); const crect = canvas.getBoundingClientRect(); if (e.clientX >= crect.left && e.clientX <= crect.right && e.clientY >= crect.top && e.clientY <= crect.bottom) { APP.Editor.placeEditorObject(APP.LevelUtils.PACK(APP.LevelUtils.getGridCoord(e).x, APP.LevelUtils.getGridCoord(e).y)); } else { if (APP.State.ENGINE.editor.draggedFromGrid) { APP.State.ENGINE.editor.draggedObject = null; APP.Editor.saveEditorState(); showMessage("Deleted", "text-white font-black"); } } APP.State.ENGINE.editor.draggedObject = null; APP.Engine.setLogicState(IDLE); } if (APP.State.ENGINE.logicState === DRAGGING) APP.Engine.setLogicState(IDLE);
        };

        APP.Renderer.getCanvas().addEventListener('pointerdown', e => { if (e.button !== 0 && e.pointerType === 'mouse') return; if (APP.State.ENGINE.runtime.activePointerId !== null) return; e.preventDefault(); APP.State.ENGINE.runtime.activePointerId = e.pointerId; APP.Renderer.getCanvas().setPointerCapture(APP.State.ENGINE.runtime.activePointerId); handleDown(e); });
        window.addEventListener('pointermove', e => {
            if (APP.State.ENGINE.logicState === THEME_DRAG) { const dragState = APP.UI.ThemeEditor.getDragState(); APP.UI.ThemeEditor.setDragGhost({ visible: true, color: dragState.color, x: e.clientX, y: e.clientY }); e.preventDefault(); return; }
            if (APP.State.ENGINE.mode === EDITOR && (APP.State.ENGINE.editor.draggedObject || (APP.State.ENGINE.editor.selectedTool && APP.State.ENGINE.logicState === EDIT_DRAG))) {
                const type = APP.State.ENGINE.editor.draggedObject ? APP.State.ENGINE.editor.draggedObject.type : APP.State.ENGINE.editor.selectedTool;
                const isOverPalette = APP.UI.EditorDragGhost.isPointerOverPalette(e.clientX, e.clientY);
                APP.UI.EditorDragGhost.update({
                    visible: true,
                    x: e.clientX,
                    y: e.clientY,
                    cellSize: APP.State.ENGINE.viewport.cellW,
                    type,
                    isOverPalette
                });
            } else {
                APP.UI.EditorDragGhost.update({ visible: false });
            }
            if (e.pointerId !== APP.State.ENGINE.runtime.activePointerId && APP.State.ENGINE.logicState !== EDIT_DRAG) return;
            e.preventDefault();
            if (APP.State.ENGINE.logicState === DRAGGING) APP.Engine.handlePrimaryGridInput(APP.LevelUtils.getGridCoord(e));
        });
        window.addEventListener('pointerup', e => { handleUp(e); if (APP.State.ENGINE.runtime.activePointerId !== null && APP.Renderer.getCanvas().hasPointerCapture(APP.State.ENGINE.runtime.activePointerId)) APP.Renderer.getCanvas().releasePointerCapture(APP.State.ENGINE.runtime.activePointerId); APP.State.ENGINE.runtime.activePointerId = null; });

        [APP.Renderer.getCanvas(), document.getElementById('hintBtn'), document.getElementById('editCopyMetrics')].forEach(el => { if (!el) return; if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex', '0'); });

        const GAMEPAD_MAP = { A: 0, B: 1, UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15 };
        const GAMEPAD_REPEAT_INITIAL = 220;
        const GAMEPAD_REPEAT_RATE = 100;

        function gamepadMoveGrid(dx, dy) {
            if (isModalActive()) return;
            const l = APP.State.ENGINE.mode === PLAY ? APP.State.ENGINE.level : APP.State.ENGINE.editor.workingLevel;
            if (!l) return;
            if (!APP.State.ENGINE.path.length) {
                const firstGate = l.gateKeys && l.gateKeys.length ? APP.LevelUtils.UNPACK(l.gateKeys[0]) : null;
                if (!firstGate) return;
                APP.State.ENGINE.activeGateKey = l.gateKeys[0];
                APP.Engine.PathNavigator.pushStep(APP.State.ENGINE, l.gateKeys[0], false);
                APP.Engine.setLogicState(DRAGGING);
            }
            const head = APP.LevelUtils.UNPACK(APP.State.ENGINE.path[APP.State.ENGINE.path.length - 1]);
            APP.Engine.attemptMoveTo({ x: head.x + dx, y: head.y + dy });
        }

        function handleGamepadDirection(dir) {
            if (APP.State.ENGINE.ui.focusGroup === 'GRID') {
                if (dir === 'UP') gamepadMoveGrid(0, -1);
                if (dir === 'DOWN') gamepadMoveGrid(0, 1);
                if (dir === 'LEFT') gamepadMoveGrid(-1, 0);
                if (dir === 'RIGHT') gamepadMoveGrid(1, 0);
                return;
            }
            moveFocusWithinGroup((dir === 'LEFT' || dir === 'UP') ? -1 : 1);
        }

        function handleBPress() {
            const now = Date.now();
            if (now - APP.State.ENGINE.ui.bLastPressTime <= 320) {
                if (APP.State.ENGINE.ui.bSingleTimer) { clearTimeout(APP.State.ENGINE.ui.bSingleTimer); APP.State.ENGINE.ui.bSingleTimer = null; }
                cycleFocusGroup();
                APP.State.ENGINE.ui.bLastPressTime = 0;
                return;
            }
            APP.State.ENGINE.ui.bLastPressTime = now;
            APP.State.ENGINE.ui.bSingleTimer = setTimeout(() => { dismissGuideOrHelpModal(); APP.State.ENGINE.ui.bSingleTimer = null; }, 320);
        }

        function pollGamepadInput() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            const pad = pads && pads[0];
            if (!pad) return;
            APP.State.ENGINE.gamepad.hasPad = true;
            const now = Date.now();

            const pressed = idx => !!pad.buttons[idx] && pad.buttons[idx].pressed;
            const wasPressed = idx => !!APP.State.ENGINE.gamepad.lastButtons[idx];
            const anyPressed = pad.buttons.some(b => !!b && b.pressed);
            if (anyPressed) APP.State.ENGINE.gamepad.hasPad = true;

            if (pressed(GAMEPAD_MAP.A) && !wasPressed(GAMEPAD_MAP.A)) activateFocusedControl();
            if (pressed(GAMEPAD_MAP.B) && !wasPressed(GAMEPAD_MAP.B)) handleBPress();

            const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
            let activeDir = null;
            for (const dir of dirs) {
                const idx = GAMEPAD_MAP[dir];
                if (pressed(idx)) { activeDir = dir; if (!wasPressed(idx)) { handleGamepadDirection(dir); APP.State.ENGINE.gamepad.nextMoveAt = now + GAMEPAD_REPEAT_INITIAL; } }
            }
            if (activeDir && now >= APP.State.ENGINE.gamepad.nextMoveAt) {
                handleGamepadDirection(activeDir);
                APP.State.ENGINE.gamepad.nextMoveAt = now + GAMEPAD_REPEAT_RATE;
            }

            APP.State.ENGINE.gamepad.lastButtons = pad.buttons.map(b => b.pressed);
        }

        function hasConnectedGamepad() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            return !!(pads && Array.from(pads).some(pad => !!pad));
        }

        function stopGamepadPollingLoop() {
            if (APP.State.ENGINE.gamepad.rafId !== null) cancelAnimationFrame(APP.State.ENGINE.gamepad.rafId);
            APP.State.ENGINE.gamepad.rafId = null;
            APP.State.ENGINE.gamepad.rafActive = false;
        }

        function gamepadPollingTick() {
            pollGamepadInput();
            if (!hasConnectedGamepad()) {
                APP.State.ENGINE.gamepad.hasPad = false;
                APP.State.ENGINE.gamepad.lastButtons = [];
                stopGamepadPollingLoop();
                return;
            }
            APP.State.ENGINE.gamepad.rafId = requestAnimationFrame(gamepadPollingTick);
        }

        function startGamepadPollingLoop() {
            if (APP.State.ENGINE.gamepad.rafActive) return;
            APP.State.ENGINE.gamepad.rafActive = true;
            APP.State.ENGINE.gamepad.rafId = requestAnimationFrame(gamepadPollingTick);
        }

        window.addEventListener('gamepadconnected', () => {
            APP.State.ENGINE.gamepad.hasPad = true;
            pollGamepadInput();
            startGamepadPollingLoop();
            setFocusGroup(APP.State.ENGINE.ui.focusGroup || 'GRID', APP.State.ENGINE.ui.focusIndex || 0);
        });
        window.addEventListener('gamepaddisconnected', () => {
            if (hasConnectedGamepad()) return;
            APP.State.ENGINE.gamepad.hasPad = false;
            APP.State.ENGINE.gamepad.lastButtons = [];
            APP.State.ENGINE.ui.gamepadFocusEnabled = false;
            applyFocusVisual(null);
            stopGamepadPollingLoop();
        });
        if (hasConnectedGamepad()) startGamepadPollingLoop();
        setFocusGroup('CONTROLS', 0);

        const viewportUpdateHandler = () => {
            updateAppScale();
            setFocusGroup(APP.State.ENGINE.ui.focusGroup || 'GRID', APP.State.ENGINE.ui.focusIndex || 0);
        };
        window.addEventListener('resize', viewportUpdateHandler);
        window.addEventListener('orientationchange', viewportUpdateHandler);
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', viewportUpdateHandler);
            window.visualViewport.addEventListener('scroll', viewportUpdateHandler);
        }
        updateAppScale();

        document.getElementById('gridRotateBtn').onclick = () => { APP.UI.closeAllModals(); if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || !APP.State.ENGINE.editor.workingLevel) return; const l = APP.State.ENGINE.editor.workingLevel; APP.LevelUtils.transformLevel(l, (x, y) => ({ x: l.grid.h - 1 - y, y: x }), l.grid.h, l.grid.w, (a) => a === H ? V : H); showMessage("Rotated", "text-white font-black"); };
        document.getElementById('gridMirrorBtn').onclick = () => { APP.UI.closeAllModals(); if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || !APP.State.ENGINE.editor.workingLevel) return; const l = APP.State.ENGINE.editor.workingLevel; APP.State.ENGINE.editor.mirrorHorizontal = !APP.State.ENGINE.editor.mirrorHorizontal; APP.UI.setInlineStyle('mirrorIconSvg', 'transform', APP.State.ENGINE.editor.mirrorHorizontal ? 'rotate(90deg)' : 'rotate(0deg)'); if (APP.State.ENGINE.editor.mirrorHorizontal) { APP.LevelUtils.transformLevel(l, (x, y) => ({ x: l.grid.w - 1 - x, y: y }), l.grid.w, l.grid.h, (a) => a); } else { APP.LevelUtils.transformLevel(l, (x, y) => ({ x: x, y: l.grid.h - 1 - y }), l.grid.w, l.grid.h, (a) => a); } showMessage("Mirrored", "text-white font-black"); };
        document.getElementById('gridSizeMinusBtn').onclick = () => { APP.UI.closeAllModals(); APP.LevelUtils.changeGridSize(-1); };
        document.getElementById('gridSizePlusBtn').onclick = () => { APP.UI.closeAllModals(); APP.LevelUtils.changeGridSize(1); };
        document.getElementById('muteBtn').onclick = () => { APP.UI.closeAllModals(); APP.State.ENGINE.muted = !APP.State.ENGINE.muted; APP.UI.setInlineStyle('muteSlash', 'display', APP.State.ENGINE.muted ? 'block' : 'none'); };
        document.getElementById('orientationToggleBtn').onclick = () => { APP.UI.closeAllModals(); APP.State.ENGINE.ui.forceLandscapeLayout = !APP.State.ENGINE.ui.forceLandscapeLayout; updateLayoutMode(); updateAppScale(); updateViewport(); showMessage(APP.State.ENGINE.ui.forceLandscapeLayout ? 'Landscape layout on.' : 'Standard layout on.', 'text-sky-600'); };

        const perspectiveAction = () => { APP.UI.closeAllModals(); if (APP.State.ENGINE.activeSolverController) return; APP.State.ENGINE.variant = (APP.State.ENGINE.variant + 1) % 8; updateViewport(); APP.Engine.rebuildDerivedPathState(APP.State.ENGINE); SOUND_BUS.play("D5", "32n"); };
        document.getElementById('whoaBtn').onclick = perspectiveAction;

        document.getElementById('resetBtn').onclick = () => {
            APP.UI.closeAllModals();
            if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || APP.State.ENGINE.activeSolverController) return;
            if (APP.State.ENGINE.cheatActive) {
                if (APP.State.ENGINE.cheatTimer) clearTimeout(APP.State.ENGINE.cheatTimer);
                APP.State.ENGINE.cheatTimer = setTimeout(() => { APP.State.ENGINE.cheatActive = false; }, 3000);
            } else {
                APP.State.ENGINE.resetStreak++;
                if (APP.State.ENGINE.resetStreak >= 5) {
                    APP.State.ENGINE.cheatActive = true;
                    SOUND_BUS.play("F5", "8n");
                    if (APP.State.ENGINE.cheatTimer) clearTimeout(APP.State.ENGINE.cheatTimer);
                    APP.State.ENGINE.cheatTimer = setTimeout(() => {
                        APP.State.ENGINE.cheatActive = false;
                        APP.State.ENGINE.resetStreak = 0;
                    }, 3000);
                }
            }
            APP.Engine.loadLevel(APP.State.ENGINE.levelIdx, { keepVariant: true });
        };

        document.getElementById('undoBtn').onclick = () => { APP.UI.closeAllModals(); if(APP.State.ENGINE.undoStack.length) APP.Engine.applySnapshot(APP.State.ENGINE.undoStack.pop()); };
        document.getElementById('devGenBtn').onclick = async () => { APP.UI.closeAllModals(); const hints = APP.State.ENGINE.foundHintsSinceLoad || []; if (!hints.length) { showMessage("No hints found yet.", ""); return; } const hintText = JSON.stringify(hints).replace(/\s/g, ''); APP.UI.setSolutionOutput(hintText); await APP.UI.copyText(hintText, { fallbackElId: 'solutionOutput' }); showMessage(`Copied ${hints.length} hint${hints.length === 1 ? '' : 's'}`, ""); };
        document.getElementById('editGenBtn').onclick = () => { APP.UI.closeAllModals(); APP.Editor.generateLevelString(); };
        document.getElementById('devCopyBtn').onclick = async () => { APP.UI.closeAllModals(); const outValue = APP.UI.getValue('solutionOutput'); if (outValue) { if (await APP.UI.copyText(outValue, { fallbackElId: 'solutionOutput' })) showMessage("Copied", "text-white font-black"); } };
        document.getElementById('editCopyBtn').onclick = async () => { APP.UI.closeAllModals(); if (APP.State.ENGINE.path.length > 0) { const pathStr = JSON.stringify(APP.State.ENGINE.path).replace(/\s/g, ''); APP.UI.setSolutionOutput(pathStr); await APP.UI.copyText(pathStr, { fallbackElId: 'solutionOutput' }); showMessage("Path Copied", "text-white font-black"); } };

        const hintBtn = document.getElementById('hintBtn'); const hintTopHalf = document.getElementById('hintTopHalf');
        const toggleHint = () => {
            if (APP.State.ENGINE.runtime.isHintExpanded) {
                APP.UI.setClassState(hintTopHalf, 'hidden', true);
                APP.UI.setClassState(hintTopHalf, 'flex', false);
                APP.UI.setInlineStyle(hintBtn, 'height', '2.5rem');
                APP.UI.setInlineStyle(hintBtn, 'marginTop', '0');
            } else {
                APP.UI.setClassState(hintTopHalf, 'hidden', false);
                APP.UI.setClassState(hintTopHalf, 'flex', true);
                APP.UI.setInlineStyle(hintBtn, 'height', '5.275rem');
                APP.UI.setInlineStyle(hintBtn, 'marginTop', '-2.775rem');
            }
            APP.State.ENGINE.runtime.isHintExpanded = !APP.State.ENGINE.runtime.isHintExpanded;
        };
        const updateHintLabel = () => { const hasSaved = APP.State.ENGINE.level && APP.State.ENGINE.level.hints && APP.State.ENGINE.level.hints.length > 0; const mainLabel = document.getElementById('hintMainLabel'); if (APP.State.ENGINE.runtime.isHintExpanded) { APP.UI.setTextContent(mainLabel, 'Saved Hint'); APP.UI.setInlineStyle(mainLabel, 'color', hasSaved ? 'white' : '#cbd5e1'); } else { APP.UI.setTextContent(mainLabel, 'Hint'); APP.UI.setInlineStyle(mainLabel, 'color', 'white'); } };
        hintBtn.onclick = async (e) => {
            APP.UI.closeAllModals();
            if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || APP.State.ENGINE.activeSolverController) return;
            if (!APP.State.ENGINE.runtime.isHintExpanded) { toggleHint(); updateHintLabel(); } else {
                const rect = hintBtn.getBoundingClientRect(); const clickY = e.clientY - rect.top; const isTopHalf = clickY < rect.height / 2;
                if (isTopHalf) {
                    try {
                        await APP.Solver.runGameSolver('hint');
                    } catch (err) {
                        console.error('Hint solve failed:', err);
                        showMessage(`Hint failed: ${err?.message || 'Unexpected solver error.'}`, 'text-red-500 font-bold');
                        APP.Engine.setOverlayState(OVERLAY_NONE);
                    }
                } else { if (APP.State.ENGINE.level?.hints?.length > 0) { APP.State.ENGINE.hinter.pathList = APP.State.ENGINE.level.hints; APP.State.ENGINE.hinter.currentPathIdx = (APP.State.ENGINE.hinter.source === 'saved' ? (APP.State.ENGINE.hinter.currentPathIdx + 1) % APP.State.ENGINE.hinter.pathList.length : 0); APP.State.ENGINE.hinter.source = 'saved'; APP.Solver.startHintAnimation(); } else showMessage("No saved hint.", "text-white font-black"); }
                toggleHint(); updateHintLabel();
            }
        };
        document.addEventListener('click', (e) => { if (APP.State.ENGINE.runtime.isHintExpanded && !hintBtn.contains(e.target)) { toggleHint(); updateHintLabel(); } });

        document.getElementById('solverCloseBtn').onclick = () => {
            if (!APP.Solver.isRunning()) {
                APP.Engine.setOverlayState(OVERLAY_NONE);
                return;
            }
            showMessage('Stopping solver…', 'text-amber-400 font-bold');
            APP.Solver.cancel();
        };
        document.addEventListener('keydown', (e) => {
            if (!APP.State.ENGINE.isDevMode) return;
            if (e.shiftKey && e.key.toLowerCase() === 'r') {
                APP.State.ENGINE.flags.useRefereeSolver = !APP.State.ENGINE.flags.useRefereeSolver;
                showMessage(`Referee solver ${APP.State.ENGINE.flags.useRefereeSolver ? 'ON' : 'OFF'}`, 'text-white font-black');
            }
        });
        const handleWinClose = (callback) => { const circle = document.getElementById('winCircle'); circle.classList.add('animate-spin-grow-fade'); setTimeout(() => { circle.classList.remove('animate-spin-grow-fade'); APP.UI.closeModal('winModal'); callback(); }, 1000); };
        document.getElementById('copyWinDataBtn').onclick = async () => { if (winOutEl.value) await APP.UI.copyText(winOutEl.value, { fallbackElId: 'winSolutionOutput' }); };
        document.getElementById('prevLevelBtn').onclick = () => tryNavigate(() => { APP.UI.closeAllModals(); if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || APP.State.ENGINE.activeSolverController) return; const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; APP.Engine.loadLevel(APP.State.ENGINE.levelIdx > 0 ? APP.State.ENGINE.levelIdx - 1 : levels.length - 1); APP.UI.setSolutionOutput(''); });
        document.getElementById('nextLevelBtn').onclick = () => tryNavigate(() => { APP.UI.closeAllModals(); if (APP.State.ENGINE.overlayState !== OVERLAY_NONE || APP.State.ENGINE.activeSolverController) return; const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; APP.Engine.loadLevel(APP.State.ENGINE.levelIdx < levels.length - 1 ? APP.State.ENGINE.levelIdx + 1 : 0); APP.UI.setSolutionOutput(''); });
        document.getElementById('nextLevelModalBtn').onclick = () => { const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; handleWinClose(() => { if (APP.State.ENGINE.levelIdx < levels.length - 1) APP.Engine.loadLevel(APP.State.ENGINE.levelIdx + 1); }); };
        document.getElementById('dismissWinModalBtn').onclick = () => handleWinClose(() => { APP.Engine.setLogicState(IDLE); });

        document.getElementById('guideBtn').onclick = () => {
            const isVisible = APP.UI.isModalOpen('guideModal');
            APP.UI.closeAllModals();
            if (!isVisible) APP.UI.openModal('guideModal');
        };
        document.getElementById('closeGuideX').onclick = () => APP.UI.closeModal('guideModal');
        document.getElementById('megaSolverBtn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.run(); };
        document.getElementById('closeMegaModalBtn').onclick = () => { APP.UI.closeModal('megaModal'); };
        document.getElementById('copyMegaDataBtn').onclick = async () => { const out = APP.UI.getMegaOutputText(); if (out) await APP.UI.copyText(out, { fallbackElId: 'megaOutput' }); };
        document.getElementById('megaRetry30Btn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.retryFailed({ timeLimitMs: 30000, variant: 'default' }); };
        document.getElementById('megaRetry60Btn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.retryFailed({ timeLimitMs: 60000, variant: 'default' }); };
        document.getElementById('megaRetry120Btn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.retryFailed({ timeLimitMs: 120000, variant: 'default' }); };
        document.getElementById('megaRetryAltBtn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.retryFailed({ timeLimitMs: 60000, variant: 'altOrder' }); };
        document.getElementById('megaGeminiRetryBtn').onclick = () => { APP.UI.closeAllModals(); APP.Solver.Mega.askGeminiForFailed(); };

        const tModal = document.getElementById('themeModal');
        document.getElementById('openThemeModalBtn').onclick = () => { APP.UI.closeAllModals(); updateLayoutMode(); refreshThemeFooter(); APP.UI.openModal('themeModal'); };
        document.getElementById('closeThemeModalBtn').onclick = () => { APP.UI.closeModal('themeModal'); closeEditor(); };
        document.getElementById('dismissThemeModalBtn').onclick = () => { APP.UI.closeModal('themeModal'); closeEditor(); };
        document.getElementById('openThemeEditorBtn').onclick = () => { APP.UI.ThemeEditor.openEditorView(); };
        const closeEditor = () => { APP.UI.ThemeEditor.closeEditorView(); refreshThemeFooter(); };
        const refreshThemeFooter = () => {
            const editBtn = document.getElementById('openThemeEditorBtn');
            const footer = document.getElementById('themeSelectFooter');
            const dismissBtn = document.getElementById('dismissThemeModalBtn');
            const canModify = APP.State.ENGINE.isDevMode || APP.State.ENGINE.mode === EDITOR;
            if (editBtn) editBtn.classList.toggle('hidden', !canModify);
            if (footer) footer.classList.toggle('justify-center', !canModify);
            if (footer) footer.classList.toggle('justify-between', canModify);
            if (dismissBtn) dismissBtn.classList.remove('hidden');
        };
        document.getElementById('backToThemeSelectBtn').onclick = closeEditor;
        document.getElementById('doneThemeEditBtn').onclick = closeEditor;
        document.getElementById('devToggleBtn').onclick = () => { APP.State.ENGINE.isDevMode = !APP.State.ENGINE.isDevMode; APP.Engine.updatePlayModeLayout(); APP.UI.showMessage(APP.State.ENGINE.isDevMode ? "Dev Enabled" : "Player Enabled", "text-white font-black"); };
        APP.UI.bindAll('.editor-input', 'input', () => { APP.Editor.markEditorInputsDirty(); });
        document.getElementById('modeToggleBtn').onclick = () => { APP.UI.closeAllModals(); APP.Editor.enterEditorMode(); };
        document.getElementById('editModeToggleBtn').onclick = () => tryNavigate(() => { APP.UI.closeAllModals(); APP.Editor.exitEditorMode(); });

        document.getElementById('editTrapSpotsBtn').onclick = async () => {
            const isVisible = APP.UI.isModalOpen('editorHelpModal');
            if (isVisible) { APP.UI.closeModal('editorHelpModal'); return; }
            APP.UI.closeAllModals();
            if (APP.Solver.isRunning()) return;
            APP.Solver.stopHintAnimation();
            const l = APP.State.ENGINE.editor.workingLevel; APP.Editor.applyMetricsFromUI();
            const res = await APP.Solver.findTrapSpots(l, { timeLimit: 8000 });
            APP.Editor.setTrapSpots(res.spots || new Set());
            APP.Renderer.render();
            if (APP.State.ENGINE.editor.validTrapSpots.size > 0) APP.UI.showMessage(`Found ${APP.State.ENGINE.editor.validTrapSpots.size} spots.`, "text-white font-black");
            else if (res.status !== 'aborted') APP.UI.showMessage("No spots found.", "text-white font-black");
            APP.Engine.setOverlayState(OVERLAY_NONE);
        };
        APP.UI.bindAll('.palette-item[data-type]', 'pointerdown', (e, el) => { APP.Editor.handlePaletteToolPointerDown(el.dataset.type); });
        document.getElementById('editPencilBtn').onclick = () => { APP.UI.closeAllModals(); APP.Editor.togglePencilMode(); };

        const eraserBtn = document.getElementById('editEraserBtn'); let eraserTimer = null, eraserFired = false;
        eraserBtn.addEventListener('pointerdown', (e) => { if (APP.State.ENGINE.mode !== EDITOR) return; eraserTimer = setTimeout(() => { APP.Engine.PathNavigator.clear(APP.State.ENGINE); showMessage("Cleared", "text-white font-black"); eraserFired = true; }, 1500); });
        const handleEraserRelease = () => { if (eraserTimer) { clearTimeout(eraserTimer); if (!eraserFired) { if (APP.State.ENGINE.path.length > 1) APP.Engine.PathNavigator.truncateTo(APP.State.ENGINE, APP.State.ENGINE.path.length - 2); else APP.Engine.PathNavigator.clear(APP.State.ENGINE); } eraserTimer = null; eraserFired = false; } };
        eraserBtn.addEventListener('pointerup', handleEraserRelease); eraserBtn.addEventListener('pointerleave', handleEraserRelease);

        document.getElementById('editUndoGridBtn').onclick = () => { APP.UI.closeAllModals(); APP.Editor.restoreEditorState(); };
        document.getElementById('editResetGrid').onclick = () => { APP.UI.closeAllModals(); APP.Editor.resetWorkingGrid(); APP.UI.showMessage("Reset", "text-white font-black"); };
        document.getElementById('editNewLevel').onclick = () => tryNavigate(() => {
            APP.UI.closeAllModals();
            APP.Editor.createNewLevel();
            APP.UI.showMessage("New Level Created", "text-white font-black");
        });
        document.getElementById('editHelpBtn').onclick = () => {
            const isVisible = APP.UI.isModalOpen('editorHelpModal');
            APP.UI.closeAllModals();
            if (!isVisible) APP.UI.openModal('editorHelpModal');
        };
        document.getElementById('closeEditorHelpX').onclick = () => APP.UI.closeModal('editorHelpModal');
        document.getElementById('editMegaSolver').onclick = async () => {
            APP.UI.closeAllModals();
            if (!APP.State.ENGINE.editor.workingLevel) return;
            APP.Editor.applyMetricsFromUI();
            try {
                await APP.Solver.runGameSolver('solve');
            } catch (err) {
                console.error('Editor solve failed:', err);
                showMessage(`Solve failed: ${err?.message || 'Unexpected solver error.'}`, 'text-red-500 font-bold');
                APP.Engine.setOverlayState(OVERLAY_NONE);
            }
        };
        document.getElementById('editCopyMetrics').onclick = () => { APP.UI.closeAllModals(); if (APP.State.ENGINE.path.length > 0) { const len = APP.Engine.getRealLength(); APP.UI.setInputValue('editReqLen', len); APP.UI.setInputValue('editReqInt', APP.State.ENGINE.intersections); APP.Editor.applyMetricsFromUI(); APP.UI.showMessage("Metrics Set", "text-white font-black"); } };

        };
        return { init };
    })();

    // APP.Boot lifecycle guarantees:
    // - start() is the single authoritative init entrypoint.
    // - loader/init errors route through APP.Loader.fail(...) and stop further boot progression.
    // - successful path reaches APP.Loader.finish() exactly once.
    // APP.Boot Public API: start().
    // Owns the single initialization entrypoint and orchestrates auth/progress sync, loader completion, and post-load system startup.
    APP.Boot = (() => {
        let started = false;

        const start = async () => {
            if (started) return;
            started = true;

            APP.UI.initDom();
            APP.UI.ThemeEditor.init();
            APP.Themes.ensureThemeLeaveColors();
            APP.Themes.applyTheme('classic');

            try {
                try {
                    if (APP.Persistence.hasConfig) await APP.Persistence.initAuth();
                } catch (e) {}
                APP.Persistence.syncProgress(APP.Persistence.getCurrentUser());

                const mode = await APP.Loader.init();
                if (mode !== 'ready' && mode !== 'fallback') {
                    APP.Loader.fail('boot', { message: `Unexpected loader mode: ${mode}` });
                    return;
                }
                if (APP.Loader.getStatus().phase === 'failed') return;

                APP.Engine.loadLevel(0);
                APP.Engine.updatePlayModeLayout();
                APP.Engine.loop();
                APP.Loader.finish();
            } catch (error) {
                APP.Loader.fail('boot', error);
            }
        };

        return { start };
    })();

    window.onload = () => {
        APP.Input.init();
        APP.Boot.start();
    };
</script>
</body>
</html>
