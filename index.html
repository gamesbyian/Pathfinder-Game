<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pathfinder</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 9 9'><rect width='9' height='9' fill='%23f8fafc'/><g stroke='%2394a3b8' stroke-width='0.05'><line x1='0' y1='0' x2='9' y2='0'/><line x1='0' y1='2' x2='9' y2='2'/><line x1='0' y1='4' x2='9' y2='4'/><line x1='0' y1='6' x2='9' y2='6'/><line x1='0' y1='8' x2='9' y2='8'/><line x1='2' y1='0' x2='2' y2='9'/><line x1='4' y1='0' x2='4' y2='9'/><line x1='6' y1='0' x2='6' y2='9'/><line x1='8' y1='0' x2='8' y2='9'/></g><path d='M2.5 5H6.5V2H3.5V7' fill='none' stroke='%233b82f6' stroke-width='0.9' stroke-linecap='round' stroke-linejoin='round'/><circle cx='2.5' cy='5' r='0.525' fill='%233b82f6'/><circle cx='3.5' cy='7' r='0.525' fill='%23ef4444'/></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital@0;1&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        :root { font-size: var(--app-scale, min(2vh, 3.5vw)); --theme-gate: #3b82f6; --theme-goal: #ef4444; --theme-block: #cbd5e1; --theme-block-dot: #94a3b8; --theme-pin: #64748b; --theme-portal: #d946ef; --theme-filter: #000000; --theme-cross: #000000; --theme-modal-bg: rgba(248,250,252,0.95); --theme-modal-panel: #ffffff; --theme-modal-border: #cbd5e1; --theme-modal-text: #334155; --theme-modal-muted: #64748b; --theme-modal-accent: #0f172a; --theme-win-bg: #ffffff; --theme-win-border: #3b82f6; --theme-win-text: #64748b; --theme-win-accent: #1e3a8a; --theme-win-accent: #1e3a8a; --theme-alert-bg: #1e40af; --theme-alert-stroke: #93c5fd; --theme-alert-text: #ffffff; --theme-logo-bg: #ffffff; --theme-logo-grid: #94a3b8; --theme-logo-path: #3b82f6; --theme-logo-gate: #3b82f6; --theme-logo-goal: #ef4444; --theme-burst: #fde047; --theme-check: #1e293b; --theme-leave-bg: #dc2626; --theme-leave-hover: #b91c1c; --theme-leave-text: #ffffff; --theme-leave-border: #b91c1c; }
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; user-select: none; -webkit-user-select: none; transition: background-color 0.3s ease; }
        canvas { cursor: crosshair; width: 100%; height: auto; aspect-ratio: 1/1; display: block; touch-action: none; background-color: white; }
        canvas:focus { outline: none; }
        .modal { background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); }
        .modal-content { transition: all 0.3s ease; }
        #winSubMessage { font-family: 'Caveat', cursive; }
        button:active:not(:disabled) { transform: translateY(1px); }
        button:focus-visible { outline: none; box-shadow: none; }
        button:disabled { cursor: not-allowed; opacity: 0.5; filter: grayscale(1); background-color: #94a3b8 !important; }
        .searching-dot { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        textarea { font-family: monospace; font-size: 0.7rem; line-height: 1.2; resize: none; transition: all 0.2s ease; }
        .serif-desc { font-family: 'Merriweather', serif; font-style: italic; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .hand-drawn { font-family: 'Permanent Marker', cursive; text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both infinite; }
        @keyframes shake { 10%, 90% { transform: translate3d(-4px, 0, 0) rotate(-1deg); } 20%, 80% { transform: translate3d(6px, 0, 0) rotate(2deg); } 30%, 50%, 70% { transform: translate3d(-8px, 0, 0) rotate(-2deg); } 40%, 60% { transform: translate3d(8px, 0, 0) rotate(1deg); } }
        @keyframes spin-grow-fade { 0% { transform: scale(1) rotate(0deg); opacity: 1; } 100% { transform: scale(3) rotate(360deg); opacity: 0; } }
        .animate-spin-grow-fade { animation: spin-grow-fade 1s forwards cubic-bezier(0.4, 0, 0.2, 1); }
        .app-layout { max-width: 65vh; }
        #headerLeft { width: clamp(3.9rem, 9.5vw, 4.1rem); flex: 0 0 clamp(3.9rem, 9.5vw, 4.1rem); }
        #headerMiddle { width: clamp(9.75rem, 20vw, 11.25rem); min-width: 9.75rem; flex: 0 0 clamp(9.75rem, 20vw, 11.25rem); }
        #headerRight { min-width: clamp(14.5rem, 34vw, 20rem); flex: 1 1 auto; }
        #headerMiddleContent { --header-middle-col-pad: 0.6rem; width: 100%; display: grid; grid-template-columns: max-content max-content max-content; justify-content: center; align-items: center; }
        .header-middle-col { padding: 0 var(--header-middle-col-pad); display: flex; align-items: center; }
        #headerMiddleColLeft { justify-content: flex-end; }
        #headerMiddleColCenter { justify-content: center; }
        #headerMiddleColRight { justify-content: center; }
        #playMetrics, #editorMetrics { margin: 0 auto; justify-content: center; }
        #levelInfoWrap { display: flex; flex-direction: column; align-items: center; justify-content: center; min-width: 3ch; }
        #levelTitle { min-width: 3ch; text-align: center; }
        #levelNavigator { display: flex; flex-direction: column; gap: 0.25rem; flex-shrink: 0; align-items: center; }
        #headerRight > div { width: 100%; justify-content: center; margin: 0 auto; }
        @media (orientation: landscape) and (min-width: 900px) {
            .app-layout { max-width: min(98vw, 180vh); display: flex; flex-direction: row-reverse; align-items: flex-start; gap: 2vh; }
            .layout-left-pane { width: clamp(21rem, 34vw, 30rem); max-height: 96vh; overflow: hidden; padding-right: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
            .layout-right-pane { width: min(58vh, 52vw); flex-shrink: 0; }
            #gameButtonGrid:not(.hidden), #editorButtonGrid:not(.hidden) { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0.35rem; }
            #solutionOutput { flex: 0 1 14rem; max-width: 14rem; }
            .landscape-editor-tools .palette-grid { grid-template-columns: repeat(4, 3rem); }
        }
        .app-layout.forced-landscape { max-width: min(98vw, 180vh); display: flex; flex-direction: row-reverse; align-items: flex-start; gap: 2vh; }
        .app-layout.forced-landscape .layout-left-pane { width: clamp(21rem, 34vw, 30rem); max-height: 96vh; overflow: hidden; padding-right: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
        .app-layout.forced-landscape .layout-right-pane { width: min(58vh, 52vw); flex-shrink: 0; }
        .app-layout.forced-landscape #gameButtonGrid:not(.hidden), .app-layout.forced-landscape #editorButtonGrid:not(.hidden) { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0.35rem; }
        .app-layout.forced-landscape #solutionOutput { flex: 0 1 14rem; max-width: 14rem; }
        .app-layout.forced-landscape .landscape-editor-tools .palette-grid { grid-template-columns: repeat(4, 3rem); }
        .landscape-editor-tools { width: 100%; }
        .landscape-editor-tools .palette-grid { flex-grow: 0; margin-left: 0; }
        .landscape-editor-tools .palette-grid .palette-item { height: 3rem; }
        .landscape-editor-tools #editUndoGridBtn { width: 3rem !important; height: calc((2 * 3rem) + (1 * 0.35rem)) !important; }
        .landscape-editor-tools #editorPaletteLayout { display: grid; grid-template-columns: auto 1fr; grid-template-areas: "line palette"; gap: 0.75rem; align-items: stretch; }
        .landscape-editor-tools #editorLineGridPanel { grid-area: line; border-top: 0; border-right: 1px solid #cbd5e1; padding: 0 0.65rem 0 0; justify-content: flex-start; align-items: stretch; flex-direction: column; }
        .landscape-editor-tools #editorItemPalettePanel { grid-area: palette; }
        .landscape-editor-tools #lineGridTools { display: flex; flex-direction: column; gap: 0.35rem; align-items: stretch; width: 7rem; }
        .landscape-editor-tools #lineToolRow, .landscape-editor-tools #lineSetRow, .landscape-editor-tools #gridRotateMirrorRow, .landscape-editor-tools #gridSizeButtonsRow { justify-content: center; }
        .landscape-editor-tools #lineSetRow #editCopyMetrics { width: 100%; min-width: 0; }
        .landscape-editor-tools #gridControlArea { flex-direction: column; gap: 0.35rem; align-items: stretch; max-width: none; flex-grow: 0; padding: 0.35rem; margin-top: 0.15rem; }
        .landscape-editor-tools #gridLabelRow { justify-content: center; padding: 0; }
        .landscape-editor-tools #gridSizeLabel { margin-right: 0; }
        .landscape-editor-tools #gridSizeButtonsRow { display: flex; gap: 0.35rem; padding: 0; }
        .landscape-editor-tools #gridSizeButtonsRow #gridSizePlusBtn { margin-left: 0; }
        .landscape-editor-tools #gridRotateMirrorRow { padding-right: 0; }

        .grid-area-modal { position: fixed; inset: auto; left: var(--grid-modal-left, 0px); top: var(--grid-modal-top, 0px); width: var(--grid-modal-width, 100vw); height: var(--grid-modal-height, 100vh); align-items: stretch; justify-content: stretch; padding: 0; }
        .grid-area-modal > .grid-area-modal-panel { width: 100%; height: 100%; max-width: none; max-height: none; border-radius: 0; border-width: 0; box-shadow: none; padding: 0.75rem; }
        .grid-area-modal textarea { min-height: 0; }
        
        .palette-grid { display: grid; grid-template-columns: repeat(6, 2.2rem); gap: 0.35rem; width: max-content; margin: 0; }
        .palette-item { width: 100%; height: 2.2rem; border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; cursor: pointer; border: 2px solid #cbd5e1; transition: transform 0.1s, border-color 0.2s, background-color 0.2s; touch-action: none; }
        .palette-item svg { width: 65%; height: 65%; }
        .palette-item.selected { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .palette-item:active { transform: scale(0.95); }
        
        .editor-input { background: rgba(0,0,0,0.15); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 0.5rem; width: 4rem; text-align: center; font-weight: 800; font-size: 1.5rem; line-height: 1; padding: 0.25rem 0; outline: none; transition: border-color 0.2s; }
        .editor-input:focus { border-color: white; }
        
        #dragGhost { position: fixed; pointer-events: none; z-index: 1000; opacity: 0.9; transform: translate(-50%, -50%); filter: drop-shadow(0 8px 12px rgba(0,0,0,0.4)); display: none; }
        #dragGhost svg { width: 100%; height: 100%; }
        #alertOverlay { pointer-events: none; transition: opacity 0.2s ease; }
    </style>
</head>
<body class="bg-slate-100 text-gray-900 flex flex-col items-center justify-start min-h-[100dvh] w-full overflow-y-auto overflow-x-hidden p-[1.5vh]">
<svg style="display:none;" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <g id="def-gate"><g transform="rotate(-45 50 50)" fill="none" stroke="currentColor" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"><path d="M25 30 L50 55 L25 80" /><path d="M55 30 L80 55 L55 80" /></g></g>
        <g id="def-goal"><circle cx="50" cy="50" r="32" fill="none" stroke="currentColor" stroke-width="10" /><circle cx="50" cy="50" r="14" fill="currentColor" /></g>
        <g id="def-falsegoal"><circle cx="50" cy="60" r="25" fill="#334155"/><path d="M 50 35 Q 60 20 75 15" fill="none" stroke="#94a3b8" stroke-width="4"/><circle cx="75" cy="15" r="5" fill="#ef4444"/><circle cx="75" cy="15" r="2.5" fill="#fde047"/><path d="M 45 35 L 55 35 L 55 45 L 45 45 Z" fill="#64748b"/></g>
        <g id="def-block"><rect x="5" y="5" width="90" height="90" rx="20" fill="currentColor" /><g fill="var(--theme-block-dot)"><circle cx="25" cy="25" r="5" /><circle cx="50" cy="25" r="5" /><circle cx="75" cy="25" r="5" /><circle cx="25" cy="50" r="5" /><circle cx="50" cy="50" r="5" /><circle cx="75" cy="50" r="5" /><circle cx="25" cy="75" r="5" /><circle cx="50" cy="75" r="5" /><circle cx="75" cy="75" r="5" /></g></g>
        <g id="def-mustcross"><g stroke="currentColor" stroke-width="8" opacity="0.4" fill="none"><path d="M15 35 L35 35 L35 15" /><path d="M85 35 L65 35 L65 15" /><path d="M15 65 L35 65 L35 85" /><path d="M85 65 L65 65 L65 85" /></g></g>
        <g id="def-goose"><path d="M30 0 L70 0 L100 30 L100 70 L70 100 L30 100 L0 70 L0 30" fill="#000" /><path d="M25 60 Q25 45 45 45 L65 45 Q75 45 75 55 Q75 65 65 65 L40 65 Q25 65 25 60" fill="#fff" /><path d="M25 55 L15 45 L30 55 Z" fill="#fff" /><path d="M60 45 L60 25 Q60 18 68 18 Q75 18 75 25 L75 35 L68 35 L68 35 L68 45 Z" fill="#fff" /><circle cx="70" cy="23" r="2" fill="#000" /><path d="M75 29 L88 32 L75 35 Z" fill="#f97316" /><path d="M45 65 L40 78 L52 78 Z M58 65 L53 78 L65 78 Z" fill="#f97316" /></g>
        <g id="def-portal"><circle cx="50" cy="50" r="30" fill="none" stroke="currentColor" stroke-width="10" stroke-dasharray="10, 8" /><circle cx="50" cy="50" r="20" fill="currentColor" opacity="0.15" /></g>
        <g id="def-mustpass"><g transform="translate(50, 75) rotate(-15) scale(2.4)"><path d="M-1 0 L1 0 L1.5 -12 L-1.5 -12 Z" fill="#94a3b8" /><circle cx="0" cy="-18" r="7" fill="currentColor" /></g></g>
        <g id="def-filterH"><rect x="10" y="25" width="80" height="15" fill="currentColor" opacity="0.3" /><rect x="10" y="60" width="80" height="15" fill="currentColor" opacity="0.3" /></g>
        <g id="def-filterV"><rect x="25" y="10" width="15" height="80" fill="currentColor" opacity="0.3" /><rect x="60" y="10" width="15" height="80" fill="currentColor" opacity="0.3" /></g>
        <g id="def-flipH"><use href="#def-filterH"/><text x="50" y="55" font-size="45" font-weight="900" font-family="sans-serif" text-anchor="middle" fill="currentColor">↺</text></g>
        <g id="def-flipV"><use href="#def-filterV"/><text x="50" y="55" font-size="45" font-weight="900" font-family="sans-serif" text-anchor="middle" fill="currentColor">↺</text></g>
        <g id="def-close"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></g>
        <g id="def-completion">
            <path d="M88.558,49.96c0-0.885-0.435-1.663-1.097-2.151l0.014-0.024l-9.324-5.383l5.367-9.296l-0.018-0.011c0.328-0.752,0.315-1.643-0.127-2.408c-0.443-0.766-1.208-1.223-2.025-1.314v-0.026H70.58V18.61h-0.022c-0.092-0.816-0.549-1.58-1.314-2.022c-0.767-0.443-1.658-0.456-2.412-0.125l-0.013-0.023l-9.481,5.474l-5.25-9.094l-0.019,0.011c-0.488-0.66-1.265-1.094-2.149-1.094c-0.885,0-1.664,0.435-2.151,1.097l-0.024-0.014l-5.337,9.244l-9.19-5.306l-0.011,0.019c-0.753-0.328-1.643-0.315-2.408,0.127c-0.767,0.442-1.223,1.208-1.315,2.025h-0.027v10.674H18.845v0.021c-0.816,0.092-1.58,0.549-2.022,1.314c-0.442,0.766-0.455,1.657-0.126,2.41l-0.023,0.014l5.246,9.087l-9.394,5.424l0.011,0.019c-0.66,0.488-1.094,1.265-1.094,2.149c0,0.885,0.435,1.664,1.097,2.151l-0.014,0.024l9.324,5.383l-5.367,9.296l0.019,0.011c-0.328,0.753-0.315,1.643,0.127,2.408c0.443,0.766,1.208,1.223,2.025,1.314v0.027H29.42V81.39h0.022c0.092,0.816,0.549,1.58,1.314,2.022c0.767,0.443,1.658,0.455,2.412,0.125l0.013,0.023l9.481-5.474l5.25,9.094l0.019-0.011c0.488,0.66,1.265,1.094,2.149,1.094c0.885,0,1.664-0.435,2.151-1.096l0.023,0.013l5.337-9.244l9.191,5.306l0.011-0.019c0.753,0.328,1.643,0.315,2.408-0.127c0.767-0.442,1.223-1.208,1.315-2.025h0.027V70.398h10.613v-0.021c0.816-0.092,1.58-0.549,2.022-1.314c0.442-0.766,0.455-1.658,0.126-2.411l0.023-0.013l-5.246-9.087l9.394-5.424l-0.011-0.019C88.124,51.622,88.558,50.844,88.558,49.96z" fill="var(--theme-burst)"/>
            <path d="M35 48 L45 58 L65 38" fill="none" stroke="var(--theme-check)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
        </g>
    </defs>
</svg>

<div id="dragGhost" class="flex items-center justify-center bg-white rounded-lg border-2 border-sky-500 border-dashed"></div>

<div id="loadingOverlay" class="fixed inset-0 z-[100] bg-slate-900/60 backdrop-blur-sm flex items-center justify-center p-8 transition-opacity duration-500">
    <div class="w-full max-w-xs bg-slate-900 p-6 rounded-2xl border border-slate-700 shadow-2xl">
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="text-white font-black text-xl tracking-tighter uppercase leading-none">Pathfinder</h1>
                <p id="loadStatusLabel" class="text-sky-400 text-[0.6rem] font-bold uppercase tracking-widest mt-1">Initing Systems...</p>
            </div>
            <p id="loadPercent" class="text-white font-mono text-sm">0%</p>
        </div>
        <div class="w-full h-1.5 bg-slate-800 rounded-full overflow-hidden"><div id="loadProgressBar" class="h-full bg-sky-500 w-0 transition-all duration-200"></div></div>
        <p id="loadErrorMessage" class="mt-4 text-sky-300 text-[0.6rem] font-medium hidden text-center italic leading-relaxed">Remote resource unavailable. Engaging local fallback array.</p>
    </div>
</div>

<div id="appLayout" class="app-layout mx-auto flex flex-col h-full w-full justify-start relative gap-[1.5vh] pb-[2vh]">
    <div id="gamePane" class="layout-right-pane">
    <div class="bg-white rounded-2xl overflow-hidden shadow-2xl border border-slate-300 flex flex-col shrink-0">
        <div id="headerBar" class="flex h-20 border-b border-slate-200">
            <div id="headerLeft" class="flex-shrink-0 flex items-center justify-center border-r border-slate-200 transition-colors duration-300 bg-[var(--theme-logo-bg)] aspect-square">
                <svg viewBox="0 0 9 9" class="h-full w-auto p-3">
                    <rect width="9" height="9" fill="var(--theme-logo-bg)"/>
                    <g stroke="var(--theme-logo-grid)" stroke-width="0.05">
                        <line x1="0" y1="0" x2="9" y2="0"/><line x1="0" y1="2" x2="9" y2="2"/><line x1="0" y1="4" x2="9" y2="4"/><line x1="0" y1="6" x2="9" y2="6"/><line x1="0" y1="8" x2="9" y2="8"/>
                        <line x1="0" y1="0" x2="0" y2="9"/><line x1="2" y1="0" x2="2" y2="9"/><line x1="4" y1="0" x2="4" y2="9"/><line x1="6" y1="0" x2="6" y2="9"/><line x1="8" y1="0" x2="8" y2="9"/>
                    </g>
                    <path d="M2.5 5H6.5V2H3.5V7" fill="none" stroke="var(--theme-logo-path)" stroke-width="0.9" stroke-linecap="round" stroke-linejoin="round"/>
                    <circle cx="2.5" cy="5" r="0.525" fill="var(--theme-logo-gate)"/>
                    <circle cx="3.5" cy="7" r="0.525" fill="var(--theme-logo-goal)"/>
                </svg>
            </div>
            <div id="headerMiddle" class="flex-shrink-0 bg-red-700 flex items-center transition-colors duration-300 relative border-r border-slate-200/20">
                <div id="headerMiddleContent">
                    <div id="headerMiddleColLeft" class="header-middle-col">
                        <svg id="completionBurst" viewBox="0 0 100 100" class="w-8 h-8 hidden shrink-0"><use href="#def-completion"/></svg>
                    </div>
                    <div id="headerMiddleColCenter" class="header-middle-col">
                        <div id="levelInfoWrap" class="min-w-0">
                            <span id="levelLabelText" class="text-[0.6rem] font-black text-red-100/60 uppercase tracking-widest leading-none mb-1">Level</span>
                            <p id="levelTitle" class="text-white font-black text-4xl uppercase cursor-pointer select-none tracking-tighter leading-none">1</p>
                        </div>
                    </div>
                    <div id="headerMiddleColRight" class="header-middle-col">
                        <div id="levelNavigator">
                            <button id="prevLevelBtn" class="bg-white/20 text-white w-6 h-6 rounded flex items-center justify-center hover:bg-white/30 transition shadow-sm text-[0.6rem]">◄</button>
                            <button id="nextLevelBtn" class="bg-white/20 text-white w-6 h-6 rounded flex items-center justify-center hover:bg-white/30 transition shadow-sm text-[0.6rem]">►</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="headerRight" class="bg-blue-700 flex items-center justify-center transition-colors duration-300">
                <div id="playMetrics" class="flex gap-6 items-center justify-center w-full">
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Length</p><p id="lengthInfo" class="text-2xl font-black text-white tabular-nums leading-none">0/0</p></div>
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Crosses</p><p id="intersectionInfo" class="text-2xl font-black text-white tabular-nums leading-none">0/0</p></div>
                </div>
                <div id="editorMetrics" class="hidden gap-6 items-center justify-center w-full">
                     <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Length</p><input id="editReqLen" type="number" class="editor-input" value="0"></div>
                    <div class="flex flex-col items-center"><p class="metric-label text-[0.6rem] uppercase font-bold tracking-widest leading-none mb-1 opacity-70">Crosses</p><input id="editReqInt" type="number" class="editor-input" value="0"></div>
                </div>
            </div>
        </div>
        
        <div id="canvasContainer" class="relative overflow-hidden bg-white">
            <canvas id="gameCanvas" width="800" height="800"></canvas>
            <div id="gooseJumpScare" class="absolute inset-0 z-40 hidden flex-col items-center justify-center bg-black/40 backdrop-blur-sm overflow-hidden pointer-events-none">
                <div class="relative w-full h-full flex flex-col items-center justify-center">
                    <div class="absolute top-[15%] z-50 transform rotate-[-25deg] -translate-x-4"><p class="hand-drawn text-white text-4xl mb-2">YOU RAN INTO</p></div>
                    <div id="scaryGoose" class="w-[75%] aspect-square shake z-40 drop-shadow-2xl"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-goose"/></svg></div>
                    <div class="absolute bottom-[15%] z-50 transform -rotate-[-25deg] translate-x-4"><p class="hand-drawn text-white text-5xl font-bold italic">A GOOSE</p></div>
                </div>
            </div>
            <div id="bombJumpScare" class="absolute inset-0 z-40 hidden flex-col items-center justify-center bg-black/60 backdrop-blur-md overflow-hidden pointer-events-none">
                <div class="relative w-full h-full flex flex-col items-center justify-center">
                    <div class="absolute top-[15%] z-50 transform rotate-[15deg] -translate-x-2"><p class="hand-drawn text-yellow-400 text-5xl mb-2 drop-shadow-lg">Bamboozled!</p></div>
                    <div id="scaryBomb" class="w-[65%] aspect-square shake z-40 drop-shadow-2xl"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-falsegoal"/></svg></div>
                    <div class="absolute bottom-[15%] z-50 transform -rotate-[10deg] translate-x-2"><p class="hand-drawn text-orange-500 text-6xl font-bold drop-shadow-xl">BOOBY TRAP</p></div>
                </div>
            </div>
            <div id="searchIndicator" class="absolute inset-0 flex items-center justify-center bg-slate-900/90 backdrop-blur-sm hidden z-20">
                <div class="flex flex-col items-center gap-4 w-full px-8">
                    <div id="megaStatus" class="hidden text-fuchsia-300 font-bold text-sm text-center animate-pulse whitespace-pre-line mb-2 tracking-widest border-b border-fuchsia-500/30 pb-2 w-full"></div>
                    <div class="flex flex-col items-center gap-3">
                        <span id="searchLabel" class="text-sm font-black uppercase tracking-widest text-center text-sky-300">Finding Solutions...</span>
                        <div class="flex gap-1"><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0s"></div><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0.2s"></div><div class="w-2 h-2 bg-sky-400 rounded-full searching-dot" style="animation-delay: 0.4s"></div></div>
                    </div>
                    <div id="solverTimer" class="text-5xl font-mono text-white font-bold tracking-tighter tabular-nums">0.0s</div>
                    <button id="solverCloseBtn" class="absolute top-4 right-4 text-white/40 hover:text-white hover:scale-110 transition p-2"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
            </div>
            <div id="guideModal" class="absolute inset-0 z-30 bg-[var(--theme-modal-bg)] backdrop-blur-md hidden flex flex-col modal-content">
                <div class="flex justify-between items-start p-8 shrink-0">
                    <div class="flex-grow text-center pr-2"><p class="serif-desc text-[1.1rem] font-bold leading-tight text-[var(--theme-modal-accent)]">Please draw a line from a Gate to a Goal that's precisely as long and as twisty as specified.</p></div>
                    <button id="closeGuideX" class="transition p-1 rounded-full shrink-0 text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
                <div class="flex-grow overflow-y-auto px-6 pb-2">
                    <div class="flex flex-wrap justify-center gap-4 mb-6">
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-gate)"><use href="#def-gate"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Gate</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Start point.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-goal)"><use href="#def-goal"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Goal</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Destination.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-block)"><use href="#def-block"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Block</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Obstacle.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full drop-shadow-sm" style="color: var(--theme-pin)"><use href="#def-mustpass"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Req.</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Visit cell.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-filter)"><use href="#def-filterH"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Filter</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">One-way street.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-portal)"><use href="#def-portal"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Portal</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Teleport.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0"><svg viewBox="0 0 100 100" class="w-full h-full" style="color: var(--theme-cross)"><use href="#def-mustcross"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Cross</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Visit cell twice.</p></div></div>
                        <div class="flex flex-col items-center text-center gap-2 p-3 rounded-lg shadow-sm border border-[var(--theme-modal-border)] bg-[var(--theme-modal-panel)] w-[30%] min-w-[8rem]"><div class="w-10 h-10 flex items-center justify-center shrink-0" id="legendGooseContainer"><svg viewBox="0 0 100 100" class="w-full h-full"><use href="#def-goose"/></svg></div><div class="flex flex-col"><span class="font-bold text-[0.8rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Goose</span><p class="serif-desc text-[0.7rem] leading-tight text-[var(--theme-modal-text)]">Danger!</p></div></div>
                    </div>
                    <div class="pb-4 border-t border-[var(--theme-modal-border)] pt-3"><p id="devToggleBtn" class="text-center text-[0.8rem] uppercase font-black text-[var(--theme-modal-muted)] tracking-wider cursor-pointer select-none hover:text-[var(--theme-modal-accent)] transition">PATHFINDER GAME BY IAN WALLACE, GEMINI AND CHATGPT. &copy;2025</p></div>
                </div>
            </div>
            <div id="editorHelpModal" class="absolute inset-0 z-30 bg-[var(--theme-modal-bg)] backdrop-blur-md hidden flex flex-col modal-content border border-[var(--theme-modal-border)]">
                <div class="flex justify-between items-start p-4 shrink-0">
                     <div class="flex-grow pr-2"><h3 class="serif-desc text-[1.1rem] font-bold leading-tight text-[var(--theme-modal-accent)] text-left w-full">Editor Guide</h3></div>
                    <button id="closeEditorHelpX" class="transition p-1 rounded-full shrink-0 text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
                </div>
                <div class="flex-grow overflow-y-auto px-4 pb-4 space-y-4 pt-2 text-left">
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Building & Testing</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Pick a tool from the palette to start building! You can tap the grid to place objects or even drag them directly into position. Use the <strong>Pencil</strong> to sketch out paths and see how your level plays. Dragging items off the grid will remove them.</p></section>
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Solving</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Click <strong>Solve Logic</strong> to automatically find valid solutions. It requires target metrics (Length/Crosses) to be properly set beforehand.</p></section>
                    <section><h4 class="font-bold mb-1 text-[1rem] uppercase tracking-wider text-[var(--theme-modal-accent)]">Exporting Level Data</h4><p class="serif-desc leading-relaxed text-[0.95rem] text-[var(--theme-modal-text)]">Once you've built something great, click <strong>Generate</strong> to export your level data. If you've drawn a valid solution or used the solver, it will automatically include that as a helpful hint for players! You can also use <strong>Copy Path</strong> to grab the raw coordinate array anytime.</p></section>
                </div>
            </div>
            <div id="winModal" class="absolute inset-0 z-30 bg-[var(--theme-modal-bg)] backdrop-blur-md hidden flex flex-col items-center justify-center p-4 modal-content">
                <div id="winModalContent" class="w-full h-full flex flex-col justify-center gap-3">
                    <div id="winCircle" class="bg-[var(--theme-win-bg)] flex-1 flex flex-col items-center justify-center text-center p-6 transition-all duration-300">
                        <h2 class="text-3xl font-black tracking-tighter uppercase leading-none mb-2 text-[var(--theme-win-accent)]">PATH FOUND</h2>
                        <p id="winSubMessage" class="text-4xl mb-4 text-[var(--theme-win-text)]">well done</p>
                        <div class="flex flex-col items-center gap-1 w-full">
                            <button id="nextLevelModalBtn" class="font-black text-2xl uppercase transition leading-none text-[var(--theme-win-accent)] hover:brightness-125">Next Level</button>
                            <span class="text-[0.675rem] font-black uppercase text-[var(--theme-win-text)]">- or -</span>
                            <button id="dismissWinModalBtn" class="font-black text-2xl uppercase transition leading-none text-[var(--theme-win-accent)] hover:brightness-125">Rest Here</button>
                        </div>
                    </div>
                    <div id="winExportArea" class="bg-[var(--theme-modal-panel)] p-4 w-full hidden">
                        <div class="flex justify-between items-center mb-2"><label class="text-[0.65rem] uppercase font-black tracking-widest text-[var(--theme-modal-accent)]">Winning Path Data</label><button id="copyWinDataBtn" class="text-[0.65rem] bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] px-3 py-1 rounded-full font-black transition active:scale-95 hover:brightness-90">COPY ARRAY</button></div>
                        <textarea id="winSolutionOutput" readonly class="w-full h-20 p-3 rounded-xl border border-slate-700 text-[0.65rem] font-mono leading-relaxed" placeholder="Solution data..."></textarea>
                    </div>
                </div>
            </div>
            <div id="unsavedModal" class="absolute inset-0 z-30 bg-[var(--theme-modal-bg)] backdrop-blur-md hidden flex flex-col items-center justify-center p-4 modal-content">
                <div class="bg-[var(--theme-modal-panel)] p-6 rounded-2xl shadow-2xl border border-[var(--theme-modal-border)] w-full max-w-sm flex flex-col text-center">
                    <h2 class="text-xl font-black uppercase tracking-widest mb-2 text-[var(--theme-modal-accent)]">Unsaved Changes</h2>
                    <p class="mb-6 font-medium text-[var(--theme-modal-text)]">Do you need to export this level?</p>
                    <div class="flex justify-center gap-4">
                        <button id="unsavedStayBtn" class="font-bold uppercase tracking-widest transition px-4 py-2 rounded-lg bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] hover:brightness-95">Stay</button>
                        <button id="unsavedLeaveBtn" class="px-6 py-2 rounded-lg font-black transition uppercase tracking-widest shadow-md border bg-[var(--theme-leave-bg)] text-[var(--theme-leave-text)] border-[var(--theme-leave-border)] hover:bg-[var(--theme-leave-hover)]">Leave</button>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="editorPalette" class="hidden w-full p-4 rounded-2xl bg-white shadow-xl border border-slate-200 shrink-0 transition-all">
        <div id="editorPaletteLayout" class="flex flex-col gap-4">
            <div id="editorItemPalettePanel" class="flex items-stretch gap-1.5">
                <div class="palette-grid flex-grow grid grid-cols-6 gap-1.5">
                    <div class="palette-item" data-type="gate" title="Gate"><svg viewBox="0 0 100 100" style="color: var(--theme-gate)"><use href="#def-gate"/></svg></div>
                    <div class="palette-item" data-type="goal" title="Goal"><svg viewBox="0 0 100 100" style="color: var(--theme-goal)"><use href="#def-goal"/></svg></div>
                    <div class="palette-item" data-type="falseGoal" title="Bomb"><svg viewBox="0 0 100 100"><use href="#def-falsegoal"/></svg></div>
                    <div class="palette-item" data-type="block" title="Block"><svg viewBox="0 0 100 100" style="color: var(--theme-block)"><use href="#def-block"/></svg></div>
                    <div class="palette-item" data-type="mustCross" title="Must Cross"><svg viewBox="0 0 100 100" style="color: var(--theme-cross)"><use href="#def-mustcross"/></svg></div>
                    <div class="palette-item" data-type="goose" title="Goose"><svg viewBox="0 0 100 100"><use href="#def-goose"/></svg></div>
                    <div class="palette-item" data-type="portal" title="Portal"><svg viewBox="0 0 100 100" style="color: var(--theme-portal)"><use href="#def-portal"/></svg></div>
                    <div class="palette-item" data-type="mustPass" title="Required"><svg viewBox="0 0 100 100" style="color: var(--theme-pin)"><use href="#def-mustpass"/></svg></div>
                    <div class="palette-item" data-type="filterH" title="H-Filter"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-filterH"/></svg></div>
                    <div class="palette-item" data-type="filterV" title="V-Filter"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-filterV"/></svg></div>
                    <div class="palette-item" data-type="flipH" title="Flip-H"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-flipH"/></svg></div>
                    <div class="palette-item" data-type="flipV" title="Flip-V"><svg viewBox="0 0 100 100" style="color: var(--theme-filter)"><use href="#def-flipV"/></svg></div>
                </div>
                <div class="w-12 flex-shrink-0 flex items-center justify-center">
                    <div id="editUndoGridBtn" class="palette-item palette-tool !w-10 !h-[4.75rem]" title="Undo Grid Action"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg></div>
                </div>
            </div>
            <div id="editorLineGridPanel" class="flex items-center justify-center pt-3 border-t border-slate-100 gap-1.5">
                <div id="lineGridTools" class="flex gap-1">
                    <div id="lineToolRow" class="flex gap-1">
                    <div id="editPencilBtn" class="palette-item palette-tool !w-10 !h-10" title="Pencil"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg></div>
                    <div id="editEraserBtn" class="palette-item palette-tool !w-10 !h-10" title="Undo Step"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg></div>
                    </div>
                    <div id="lineSetRow" class="flex">
                    <div id="editCopyMetrics" class="bg-red-700 text-white px-4 h-10 flex items-center justify-center rounded-lg text-[0.65rem] font-bold uppercase tracking-wider cursor-pointer hover:brightness-110 active:scale-95 transition-all whitespace-nowrap min-w-[6rem]">Set (0/0)</div>
                    </div>
                </div>
                <div id="gridControlArea" class="flex items-center gap-1.5 p-1 rounded-xl border border-slate-200 bg-slate-50 flex-grow max-w-[200px] justify-center">
                    <div id="gridLabelRow" class="flex items-center px-1.5"><span id="gridSizeLabel" class="text-[0.6rem] font-black uppercase tracking-widest text-slate-400 mr-1.5">GRID:</span></div>
                    <div id="gridSizeButtonsRow" class="flex items-center px-1.5">
                        <button id="gridSizeMinusBtn" class="w-8 h-8 rounded-lg font-black transition flex items-center justify-center border border-slate-200">-</button>
                        <button id="gridSizePlusBtn" class="w-8 h-8 rounded-lg font-black transition flex items-center justify-center border border-slate-200 ml-1">+</button>
                    </div>
                    <div id="gridRotateMirrorRow" class="flex gap-1 pr-1">
                        <button id="gridRotateBtn" class="w-8 h-8 rounded-lg transition flex items-center justify-center border border-slate-200"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path></svg></button>
                        <button id="gridMirrorBtn" class="w-8 h-8 rounded-lg transition flex items-center justify-center border border-slate-200"><svg id="mirrorIconSvg" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(90deg)"><polyline points="8 18 3 12 8 6"></polyline><polyline points="16 6 21 12 16 18"></polyline><line x1="3" y1="12" x2="21" y2="12"></line></svg></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <div id="controlsPane" class="layout-left-pane">
    <div id="playControls" class="bg-white p-3 rounded-2xl shadow-xl border border-slate-200 relative">
        <div class="relative">
            <div id="gameButtonGrid" class="flex gap-1.5">
                <div id="hintBtn" class="flex-1 h-10 bg-orange-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 text-[0.65rem] uppercase tracking-wider flex flex-col z-20 overflow-hidden cursor-pointer relative">
                    <div id="hintTopHalf" class="flex-1 w-full items-center justify-center border-b border-white/20 hidden hover:bg-black/10 transition-colors text-[0.65rem] text-center">New Hint</div>
                    <div id="hintBottomHalf" class="flex-1 w-full items-center justify-center flex hover:bg-black/10 transition-colors text-center"><span id="hintMainLabel" class="w-full text-center">Hint</span></div>
                </div>
                <button id="resetBtn" class="flex-1 h-10 bg-red-500 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Reset</button>
                <button id="undoBtn" class="flex-1 h-10 bg-slate-600 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Undo</button>
                <button id="whoaBtn" class="flex-1 h-10 bg-blue-500 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Whoa</button>
                <button id="guideBtn" class="flex-1 h-10 bg-purple-600 text-white font-bold rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Guide</button>
                <button id="megaSolverBtn" class="hidden flex-1 h-10 bg-fuchsia-600 text-white font-black rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Mega</button>
                <button id="modeToggleBtn" class="flex-1 h-10 bg-slate-900 text-white font-black rounded-lg shadow-md transition-all text-[0.65rem] uppercase tracking-wider">Edit</button>
            </div>
            <div id="editorButtonGrid" class="hidden flex gap-1.5">
                <button id="editResetGrid" class="flex-1 h-10 bg-red-600 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">Clear</button>
                <button id="editNewLevel" class="flex-1 h-10 bg-emerald-600 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">New</button>
                <button id="editMegaSolver" class="flex-1 h-10 bg-fuchsia-600 text-white font-black rounded-lg text-[0.65rem] uppercase tracking-wider">Solve</button>
                <button id="editTrapSpotsBtn" class="flex-1 h-10 bg-orange-500 text-white font-black rounded-lg text-[0.65rem] uppercase tracking-wider">BOMBS?</button>
                <button id="editHelpBtn" class="flex-1 h-10 bg-slate-500 text-white font-bold rounded-lg text-[0.65rem] uppercase tracking-wider">Guide</button>
                <button id="editModeToggleBtn" class="flex-1 h-10 bg-slate-900 text-white font-black rounded-lg shadow-md text-[0.65rem] uppercase tracking-wider">Play</button>
            </div>
            <div id="alertOverlay" class="absolute inset-0 z-[60] bg-[var(--theme-alert-bg)] border-2 border-white/20 rounded-lg flex items-center justify-center text-center px-4 shadow-2xl opacity-0 pointer-events-none">
                <p id="message" class="font-black text-[0.9rem] uppercase tracking-tighter architectural-tight leading-tight drop-shadow-lg"></p>
            </div>
        </div>
        <div class="flex flex-col gap-2 hidden mt-3 pt-3 border-t border-slate-100" id="exportArea">
            <div class="flex justify-between items-center px-1"><label id="exportLabel" class="text-[0.6rem] uppercase font-black text-slate-400 tracking-widest">Level Data Export</label></div>
            <div class="flex gap-2 items-stretch w-full">
                <textarea id="solutionOutput" readonly class="flex-grow h-[5rem] p-3 bg-slate-900 text-sky-300 rounded-xl border border-slate-700 text-[0.6rem] font-mono leading-tight" placeholder="Solution data..."></textarea>
                <div id="exportBtnStack" class="flex flex-col gap-1 w-24 shrink-0">
                    <button id="devCopyBtn" class="flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.55rem] hover:bg-slate-300 transition uppercase px-1 leading-none">Copy Path</button>
                    <button id="devGenBtn" class="flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.6rem] hover:bg-slate-300 transition uppercase">Copy Hints</button>
                    <button id="editCopyBtn" class="hidden flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.55rem] transition uppercase px-1 leading-none">Copy Path</button>
                    <button id="editGenBtn" class="hidden flex-1 bg-slate-200 text-slate-600 rounded-lg font-black text-[0.6rem] transition uppercase">Generate</button>
                </div>
            </div>
        </div>
    </div>

    <div class="flex w-full items-center justify-end gap-1.5 shrink-0 pt-2 landscape-editor-tools">
        <button id="orientationToggleBtn" class="px-3 bg-slate-300/60 backdrop-blur-md rounded-lg h-10 border border-white/20 shadow-md text-slate-700 font-black uppercase tracking-wider hover:bg-slate-400/60 transition text-[0.65rem] flex items-center justify-center min-w-[5.25rem]">Landscape</button>
        <button id="openThemeModalBtn" class="px-3 bg-slate-300/60 backdrop-blur-md rounded-lg h-10 border border-white/20 shadow-md text-slate-700 font-black uppercase tracking-wider hover:bg-slate-400/60 transition text-[0.65rem] flex items-center justify-center min-w-[4.75rem]">Themes</button>
        <button id="muteBtn" class="bg-white/50 backdrop-blur-md text-slate-500 w-10 h-10 rounded-lg flex items-center justify-center hover:bg-white/80 transition shrink-0 shadow-md border border-white/20">
            <svg id="muteIcon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v1a7 7 0 0 1-14 0v-1"></path><line x1="12" y1="19" x2="12" y2="22"></line><line id="muteSlash" x1="2" y1="2" x2="22" y2="22"></line></svg>
        </button>
    </div>
    </div>
</div>

<div id="themeModal" class="fixed inset-0 z-50 hidden flex flex-col modal-content border border-[var(--theme-modal-border)] bg-[var(--theme-modal-bg)] backdrop-blur-md grid-area-modal">
    <div id="themeModalPanel" class="w-full h-full flex flex-col modal-content transition-all duration-300 overflow-hidden p-4 grid-area-modal-panel">
        <div id="themeSelectView" class="flex flex-col w-full h-full min-h-0">
            <div class="flex justify-between items-center mb-4 shrink-0 px-2">
                <h2 class="text-lg font-black text-[var(--theme-modal-accent)] uppercase tracking-widest">Select Theme</h2>
                <button id="closeThemeModalBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-1 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
            </div>
            <div id="themeGrid" class="flex-grow overflow-y-auto grid grid-cols-3 gap-4 px-2 pb-4 content-start min-h-0"></div>
            <div id="themeSelectFooter" class="pt-4 border-t border-[var(--theme-modal-border)] flex justify-center gap-2 shrink-0">
                <button id="openThemeEditorBtn" class="hidden text-[0.75rem] font-black uppercase tracking-widest text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] transition bg-black/5 px-4 py-2 rounded-lg hover:bg-black/10">Modify Themes</button>
                <button id="dismissThemeModalBtn" class="text-[0.75rem] font-black uppercase tracking-widest text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] transition bg-black/5 px-4 py-2 rounded-lg hover:bg-black/10">Dismiss</button>
            </div>
        </div>
        <div id="themeEditView" class="hidden flex-col w-full h-full min-h-0">
            <div class="flex justify-between items-center mb-4 shrink-0 px-2">
                <h2 class="text-lg font-black text-[var(--theme-modal-accent)] uppercase tracking-widest">Modify Themes</h2>
                <button id="backToThemeSelectBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-1 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                </button>
            </div>
            <div id="themeEditList" class="flex-grow overflow-y-auto flex flex-col gap-6 px-1 sm:px-2 pb-4 min-h-0"></div>
            <div class="pt-4 border-t border-[var(--theme-modal-border)] flex justify-end shrink-0">
                <button id="doneThemeEditBtn" class="bg-[var(--theme-modal-accent)] text-[var(--theme-modal-panel)] px-6 py-2 rounded-lg font-black tracking-widest shadow-md hover:brightness-110 transition text-xs uppercase">Done</button>
            </div>
        </div>
    </div>
</div>

<div id="megaModal" class="fixed inset-0 z-50 flex items-center justify-center hidden modal px-4 grid-area-modal">
    <div id="megaModalContent" class="bg-[var(--theme-modal-bg)] backdrop-blur-md p-6 rounded-2xl shadow-2xl border border-[var(--theme-modal-border)] w-full max-w-2xl h-[80vh] flex flex-col modal-content grid-area-modal-panel">
        <div class="flex justify-between items-center mb-4">
            <div><h2 id="megaModalTitle" class="text-2xl font-black uppercase tracking-tighter text-[var(--theme-modal-accent)]">Mega Solver Results</h2><p id="megaModalSub" class="text-xs font-bold uppercase tracking-widest text-[var(--theme-modal-muted)]">Bulk Solution Generation</p></div>
            <button id="closeMegaModalBtn" class="text-[var(--theme-modal-muted)] hover:text-[var(--theme-modal-accent)] hover:bg-black/5 p-2 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><use href="#def-close"/></svg></button>
        </div>
        <textarea id="megaOutput" readonly class="flex-grow p-4 bg-slate-900 text-fuchsia-300 rounded-xl border border-slate-700 text-xs font-mono leading-relaxed resize-none focus:outline-none focus:ring-2 focus:ring-fuchsia-500" placeholder="Mega solver results will appear here..."></textarea>
        <div class="mt-4 flex justify-end"><button id="copyMegaDataBtn" class="bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] px-6 py-3 rounded-lg font-black hover:brightness-95 transition uppercase tracking-widest shadow-lg active:scale-95">Copy All</button></div>
    </div>
</div>

<script type="module">
    const APP = {};

    // ======================================================
    // A) Core / ConstantsAndUtils
    // ======================================================
    APP.Core = (() => {
        const $ = id => document.getElementById(id);
        const AXIS = { NONE: 0, H: 1, V: 2 };
        const { H, V, NONE } = AXIS;
        const MODES = { PLAY: 0, EDITOR: 1 };
        const { PLAY, EDITOR } = MODES;

        const LogicStatus = {
            IDLE: "IDLE",
            DRAGGING: "DRAGGING",
            PORTAL_PAUSE: "PORTAL_PAUSE",
            RESOLVED: "RESOLVED",
            HAZARD_TRIGGERED: "HAZARD_TRIGGERED",
            EDIT_DRAG: "EDIT_DRAG",
            THEME_DRAG: "THEME_DRAG"
        };
        const { IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG } = LogicStatus;

        const OverlayStatus = {
            NONE: "NONE",
            HINT_ANIMATING: "HINT_ANIMATING",
            FALSE_GOAL_ANIMATING: "FALSE_GOAL_ANIMATING",
            GOOSE_OVERLAY: "GOOSE_OVERLAY",
            SOLVER_RUNNING: "SOLVER_RUNNING"
        };
        const { NONE: OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING } = OverlayStatus;

        return { $, AXIS, H, V, NONE, MODES, PLAY, EDITOR, LogicStatus, IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG, OverlayStatus, OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING };
    })();

    const { $, AXIS, H, V, NONE, MODES, PLAY, EDITOR, LogicStatus, IDLE, DRAGGING, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED, EDIT_DRAG, THEME_DRAG, OverlayStatus, OVERLAY_NONE, HINT_ANIMATING, FALSE_GOAL_ANIMATING, GOOSE_OVERLAY, SOLVER_RUNNING } = APP.Core;
    window.AXIS = AXIS;

    // ======================================================
    // B) State / Engine
    // ======================================================
    APP.State = (() => {
        const ENGINE = {
        mode: PLAY, 
        logicState: IDLE,
        overlayState: OVERLAY_NONE,
        isDevMode: false, 
        levelIdx: 0, 
        variant: 0, 
        level: null, 
        path: [], 
        isPortalJump: new Set(), 
        visitedCounts: new Map(), 
        cellUsage: new Map(), 
        intersections: 0, 
        activeGateKey: null, 
        flipCount: 0, 
        visualFlipCount: 0, 
        crossedFlippingFilters: new Map(), 
        detonatedFalseGoals: new Set(), 
        armedFalseGoals: new Set(), 
        undoStack: [], 
        revealedGeese: new Set(), 
        ripples: [], 
        gooseEncounteredThisLevel: false, 
        muted: true, 
        rainbowActive: true, 
        titleClickCount: 0, 
        titleClickTimer: null, 
        resetStreak: 0, 
        lastFlipTime: 0, 
        cheatTimer: null, 
        hinter: { pathList: [], currentPathIdx: 0, alpha: 0, index: 0, source: 'none' }, 
        activeSolverController: null, 
        viewport: { cellW: 0, cellH: 0, swapped: false, lastWidth: 0 }, 
        themeDragColor: null, 
        themeDragTheme: null, 
        themeDragCategory: null, 
        themeTapSelectedColor: null, 
        themeTapSelectedTheme: null, 
        themeTapCategory: null, 
        progressSet: new Set(),
        foundHintsSinceLoad: [],
        editor: { workingLevel: null, draggedObject: null, draggedFromGrid: false, selectedTool: null, isPencilMode: false, pendingPortal: null, paletteColors: ['#d946ef', '#0ea5e9', '#10b981', '#f59e0b', '#ef4444'], undoStack: [], validTrapSpots: new Set(), isModified: false, emptyClickCount: 0, mirrorHorizontal: true } 
        ,ui: { isLandscapeLayout: false, forceLandscapeLayout: false, focusGroup: 'GRID', focusIndex: 0, bLastPressTime: 0, bSingleTimer: null, gamepadFocusEnabled: false }
        ,gamepad: { lastButtons: [], lastAxes: [0, 0], nextMoveAt: 0, hasPad: false }
    };
        return { ENGINE };
    })();
    const { ENGINE } = APP.State;

    // ======================================================
    // J) Persistence
    // ======================================================
    const firebaseConfigRaw = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
    let auth = null;
    let db = null;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'pathfinder-standalone';

    if (firebaseConfigRaw) {
        try {
            const config = JSON.parse(firebaseConfigRaw);
            firebase.initializeApp(config);
            auth = firebase.auth();
            db = firebase.firestore();
        } catch (e) {}
    }

    async function initAuth() {
        if (!auth) return;
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await auth.signInWithCustomToken(__initial_auth_token);
            } else {
                await auth.signInAnonymously();
            }
        } catch (e) {}
    }

    function syncProgress(user) {
        const localData = localStorage.getItem(`pathfinder_progress_${appId}`);
        if (localData) {
            ENGINE.progressSet = new Set(JSON.parse(localData));
            updateCompletionUI();
        }

        if (user && db) {
            const progressDoc = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('levelProgress');
            progressDoc.onSnapshot((doc) => {
                if (doc.exists) {
                    const data = doc.data();
                    const cloudSet = new Set(data.completedLevels || []);
                    ENGINE.progressSet = new Set([...ENGINE.progressSet, ...cloudSet]);
                    updateCompletionUI();
                    localStorage.setItem(`pathfinder_progress_${appId}`, JSON.stringify(Array.from(ENGINE.progressSet)));
                }
            }, (err) => {});
        }
    }

    async function markLevelComplete(idx) {
        ENGINE.progressSet.add(idx);
        updateCompletionUI();
        localStorage.setItem(`pathfinder_progress_${appId}`, JSON.stringify(Array.from(ENGINE.progressSet)));

        const user = auth?.currentUser;
        if (user && db) {
            const progressDoc = db.collection('artifacts').doc(appId).collection('users').doc(user.uid).collection('data').doc('levelProgress');
            await progressDoc.set({ completedLevels: Array.from(ENGINE.progressSet) }, { merge: true });
        }
    }

    function updateCompletionUI() {
        const isComplete = ENGINE.progressSet.has(ENGINE.levelIdx);
        const isPlayMode = ENGINE.mode === PLAY;
        const burst = $('completionBurst');
        if (burst) burst.classList.toggle('hidden', !isComplete || !isPlayMode);
    }

    function updateAppScale() {
        if (window.innerWidth === ENGINE.viewport.lastWidth) {
            updateLayoutMode();
            return;
        }
        ENGINE.viewport.lastWidth = window.innerWidth;
        const scale = Math.min(window.innerHeight * 0.02, window.innerWidth * 0.035);
        document.documentElement.style.setProperty('--app-scale', `${scale}px`);
        updateLayoutMode();
        updateViewport();
    }

    function updateLayoutMode() {
        const naturalLandscape = window.matchMedia('(orientation: landscape)').matches && window.innerWidth >= 900;
        ENGINE.ui.isLandscapeLayout = naturalLandscape || ENGINE.ui.forceLandscapeLayout;
        const appLayout = $('appLayout');
        if (appLayout) appLayout.classList.toggle('forced-landscape', ENGINE.ui.forceLandscapeLayout && !naturalLandscape);
        const canvasContainer = $('canvasContainer');
        const modalRectSource = canvasContainer || appLayout;
        if (modalRectSource) {
            const modalRect = modalRectSource.getBoundingClientRect();
            document.documentElement.style.setProperty('--grid-modal-left', `${modalRect.left}px`);
            document.documentElement.style.setProperty('--grid-modal-top', `${modalRect.top}px`);
            document.documentElement.style.setProperty('--grid-modal-width', `${modalRect.width}px`);
            document.documentElement.style.setProperty('--grid-modal-height', `${modalRect.height}px`);
        }
        const orientationBtn = $('orientationToggleBtn');
        if (orientationBtn) orientationBtn.innerText = ENGINE.ui.forceLandscapeLayout ? 'Standard' : 'Landscape';
        syncEditorPalettePlacement();
    }

    function syncEditorPalettePlacement() {
        const pal = $('editorPalette');
        const gamePane = $('gamePane');
        const controlsPane = $('controlsPane');
        if (!pal || !gamePane || !controlsPane) return;
        const inLandscape = ENGINE.ui.isLandscapeLayout;
        if (inLandscape && ENGINE.mode === EDITOR) {
            if (pal.parentElement !== controlsPane) controlsPane.insertBefore(pal, controlsPane.firstChild);
            pal.classList.add('landscape-editor-tools');
        } else {
            if (pal.parentElement !== gamePane.parentElement) gamePane.parentElement.insertBefore(pal, controlsPane);
            pal.classList.remove('landscape-editor-tools');
        }
    }

    const VALID_LOGIC_TRANSITIONS = {
        [IDLE]: [DRAGGING, EDIT_DRAG, THEME_DRAG, RESOLVED],
        [DRAGGING]: [IDLE, PORTAL_PAUSE, RESOLVED, HAZARD_TRIGGERED],
        [PORTAL_PAUSE]: [DRAGGING, IDLE],
        [RESOLVED]: [IDLE],
        [HAZARD_TRIGGERED]: [IDLE],
        [EDIT_DRAG]: [IDLE],
        [THEME_DRAG]: [IDLE]
    };

    function setLogicState(newState) {
        if (!VALID_LOGIC_TRANSITIONS[ENGINE.logicState].includes(newState) && newState !== IDLE) {
            console.warn(`Blocked Logic Transition: ${ENGINE.logicState} -> ${newState}`);
            return false;
        }

        if (ENGINE.logicState === EDIT_DRAG && newState !== EDIT_DRAG) {
            ghostEl.style.display = 'none';
            ghostEl.innerHTML = '';
        }

        ENGINE.logicState = newState;
        return true;
    }

    function setOverlayState(newState) {
        if (ENGINE.overlayState === SOLVER_RUNNING && newState !== SOLVER_RUNNING) {
            $('searchIndicator').classList.add('hidden');
            setSolversActive(true);
        }
        if (ENGINE.overlayState === HINT_ANIMATING && newState !== HINT_ANIMATING) {
            ENGINE.hinter.alpha = 0;
            setSolversActive(true);
        }

        ENGINE.overlayState = newState;

        if (newState === SOLVER_RUNNING) {
            $('searchIndicator').classList.remove('hidden');
            setSolversActive(false);
        }
        if (newState === HINT_ANIMATING) {
            setSolversActive(true);
        }

        return true;
    }

    const FALLBACK_RAW_LEVELS = [ { grid: {w:10, h:10}, gates: [{x:2,y:2}, {x:2,y:4}], goal: {x:9,y:9}, reqLen: 14, reqInt: 0, blocks: [{x:4,y:4}, {x:5,y:4}, {x:4,y:5}, {x:5,y:5}], mustPass: [{x:6,y:6}], geese: [{x:6,y:7}], flippingFilters: [{x:8, y:2, axis: 2}, {x:3, y:8, axis: 1}, {x:5, y:2, axis: 1}, {x:7, y:2, axis: 1}], falseGoals: [{x:2, y:8}], hints: [] } ];
    
    const PACK = (x, y) => (y << 16) | x;
    const UNPACK = (k) => ({ x: k & 0xFFFF, y: k >> 16 });
    const inBounds = (x, y, w, h) => x >= 0 && x < w && y >= 0 && y < h;
    const expCoords = (items) => (Array.isArray(items) ? items : Array.from(items)).map(k => { const p = UNPACK(k); return {x: p.x + 1, y: p.y + 1}; });
    
    const setSolversActive = (active) => { 
        ['editMegaSolver', 'editTrapSpotsBtn'].forEach(id => { const el = $(id); if(el) el.disabled = !active; }); 
        const hintEl = $('hintBtn');
        if (hintEl) {
            hintEl.style.pointerEvents = active ? 'auto' : 'none';
            hintEl.style.opacity = active ? '1' : '0.5';
        }
    };
    
    function resolvePortal(level, key) { return level.portalMap.has(key) ? level.portalMap.get(key) : null; }
    
    const SOUND_BUS = { play(freq, dur = "16n") { if (!ENGINE.muted && window.Tone && Tone.context.state === 'running') { new Tone.Synth().toDestination().triggerAttackRelease(freq, dur); } } };
    
    function loop() {
        if (ENGINE.overlayState === HINT_ANIMATING && ENGINE.hinter.pathList.length) {
            ENGINE.hinter.index += 0.5; const hPath = ENGINE.hinter.pathList[ENGINE.hinter.currentPathIdx];
            if (ENGINE.hinter.index >= hPath.length + 40) { 
                ENGINE.hinter.alpha -= 0.05; 
                if (ENGINE.hinter.alpha <= 0) { 
                    setOverlayState(OVERLAY_NONE); 
                    showMessage("", ""); 
                } 
            }
        }
        if (ENGINE.visualFlipCount !== undefined) {
            if (ENGINE.visualFlipCount < ENGINE.flipCount) { ENGINE.visualFlipCount = Math.min(ENGINE.flipCount, ENGINE.visualFlipCount + 0.15); }
            else if (ENGINE.visualFlipCount > ENGINE.flipCount) { ENGINE.visualFlipCount = Math.max(ENGINE.flipCount, ENGINE.visualFlipCount - 0.15); }
        }
        render(); requestAnimationFrame(loop);
    }
    
    const MEGA = { 
        active: false, results: {}, 
        async run() { 
            if (this.active) return; const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : (typeof FALLBACK_RAW_LEVELS !== 'undefined' ? FALLBACK_RAW_LEVELS : null); if (!levels) return; 
            this.active = true; this.results = {}; const targets = []; for (let i = 0; i < levels.length; i++) { if (!levels[i].hints || levels[i].hints.length === 0) { targets.push(i); } } 
            if (targets.length === 0) { showMessage("All levels have hints!", "text-green-600"); this.active = false; return; } 
            
            const btn = $('megaSolverBtn'); const originalText = btn.innerText; btn.disabled = true; 
            const statusEl = $('megaStatus'); statusEl.classList.remove('hidden'); 
            const uiTimer = $('solverTimer'); const searchLabel = $('searchLabel'); const megaStartTime = Date.now();
            
            setOverlayState(SOLVER_RUNNING);
            ENGINE.activeSolverController = new AbortController();

            for (let i = 0; i < targets.length; i++) { 
                const idx = targets[i]; statusEl.innerText = `BATCH PROGRESS: ${i + 1}/${targets.length}\nSCANNING LEVEL ${idx + 1}`; const l = normalizeLevel(idx); 
                try { 
                    const solutions = await PathfinderSolver.solve(l, { 
                        timeLimit: 15000, 
                        signal: ENGINE.activeSolverController.signal, 
                        onStateUpdate: (msg) => { searchLabel.innerText = msg; }, 
                        onProgress: () => { uiTimer.innerText = ((Date.now() - megaStartTime) / 1000).toFixed(1) + 's'; } 
                    }); 
                    if (solutions && solutions.length > 0) { const simplified = solutions.map(s => s.path); this.results[idx + 1] = simplified; } 
                } catch(e) { if (e.name === 'AbortError') break; console.log(`Skipped level ${idx+1}`); } 
            } 
            ENGINE.activeSolverController = null; statusEl.classList.add('hidden'); 
            setOverlayState(OVERLAY_NONE);
            this.showReport(); this.active = false; btn.disabled = false; btn.innerText = originalText; 
        }, 
        showReport() { let text = ""; for (const [lvl, paths] of Object.entries(this.results)) { text += `/* Level ${lvl} */\n${JSON.stringify(paths)}\n\n`; } $('megaOutput').value = text; $('megaModal').classList.remove('hidden'); } 
    };
    
    function rc() { return `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; }
    
    const THEMES = {
        classic: { bodyBg: '#e0f2fe', canvasBg: '#ffffff', grid: '#94a3b8', headerLeft: '#dc2626', headerRight: '#2563eb', path: 'rainbow', controls: 'rgba(255, 255, 255, 0.7)', metricText: '#ffffff', btns: { undo: '#4c566a', reset: '#d12929', guide: '#8c33db', whoa: '#2563eb', hint: '#cf6b17', saved: '#0a8a65', mega: '#ba29c9', mute: '#e1e7f0', muteIcon: '#64748b', copy: '#e1e7f0', gen: '#e1e7f0', modeToggle: '#1a2438', orient: '#1a2438', solve: '#ba29c9', editClear: '#d12929', editBombs: '#ef4444', editNew: '#0a8a65' }, modal: { bg: 'rgba(248, 250, 252, 0.95)', panelBg: '#ffffff', border: '#cbd5e1', text: '#334155', textMuted: '#64748b', accent: '#0f172a' }, output: { bg: '#0f172a', text: '#38bdf8' }, colors: { gate: '#3b82f6', goal: '#ef4444', block: '#cbd5e1', pin: '#ef4444', pinUnflipped: '#000000', filter: '#000000', portal: '#d946ef', cross: '#000000' }, palette: { bg: '#f8fafc', border: '#cbd5e1', itemBg: '#ffffff', itemBorder: '#cbd5e1', toolBg: '#f1f5f9' }, headerLeftText: '#ffffff', headerLeftLabel: 'rgba(255, 255, 255, 0.7)', ghostBg: '#ffffff', ghostBorder: '#0ea5e9', win: { bg: '#ffffff', border: '#3b82f6', text: '#64748b', accent: '#1e3a8a' }, alert: { bg: '#1e40af', stroke: '#93c5fd' }, ctrlArea: { bg: '#f1f5f9', border: '#cbd5e1' }, burst: '#ffe135', check: '#1e293b' },
        dark: { bodyBg: '#020617', canvasBg: '#111827', grid: '#475569', headerLeft: '#7f1d1d', headerRight: '#1e3a8a', path: '#22c55e', controls: 'rgba(30, 41, 59, 0.9)', metricText: '#f1f5f9', btns: { undo: '#374151', reset: '#7f1d1d', guide: '#4c1d95', whoa: '#1e3a8a', hint: '#b45309', saved: '#064e3b', mega: '#701a75', mute: '#1e293b', muteIcon: '#94a3b8', copy: '#1e293b', gen: '#1e293b', modeToggle: '#000000', orient: '#000000', solve: '#374151', editClear: '#7f1d1d', editBombs: '#f43f5e', editNew: '#064e3b' }, modal: { bg: 'rgba(15, 23, 42, 0.95)', panelBg: '#1e293b', border: '#334155', text: '#f8fafc', textMuted: '#94a3b8', accent: '#38bdf8' }, output: { bg: '#020617', text: '#22c55e' }, colors: { gate: '#38bdf8', goal: '#f43f5e', block: '#1e293b', pin: '#f43f5e', pinUnflipped: '#64748b', filter: '#94a3b8', portal: '#d946ef', cross: '#94a3b8' }, palette: { bg: '#0f172a', border: '#334155', itemBg: '#1e293b', itemBorder: '#334155', toolBg: '#0f172a' }, headerLeftText: '#f1f5f9', headerLeftLabel: 'rgba(241, 245, 249, 0.7)', ghostBg: '#1e293b', ghostBorder: '#38bdf8', win: { bg: '#1e293b', border: '#38bdf8', text: '#94a3b8', accent: '#f8fafc' }, alert: { bg: '#7f1d1d', stroke: '#fca5a5' }, ctrlArea: { bg: '#0f172a', border: '#334155' }, burst: '#334155', check: '#f1f5f9' },
        tron: { bodyBg: '#000000', canvasBg: '#001d3d', grid: '#00d9ff66', headerLeft: '#00d9ff', headerRight: '#ff00ff', path: '#00d9ff', controls: 'rgba(0, 8, 20, 0.95)', metricText: '#000000', btns: { undo: '#003366', reset: '#990099', guide: '#004080', whoa: '#005099', hint: '#008080', saved: '#006600', mega: '#ff9900', mute: '#001d3d', muteIcon: '#00d9ff', copy: '#001d3d', gen: '#001d3d', modeToggle: '#001122', orient: '#001122', solve: '#003366', editClear: '#990099', editBombs: '#ff00ff', editNew: '#006600' }, modal: { bg: 'rgba(0, 8, 20, 0.95)', panelBg: '#001d3d', border: '#00d9ff', text: '#00d9ff', textMuted: '#004e64', accent: '#ff00ff' }, output: { bg: '#000814', text: '#ff00ff' }, colors: { gate: '#00d9ff', goal: '#ff00ff', block: '#001d3d', pin: '#ff00ff', pinUnflipped: '#004e64', filter: '#00d9ff', portal: '#ff00ff', cross: '#00d9ff' }, palette: { bg: '#000814', border: '#00d9ff', itemBg: '#001d3d', itemBorder: '#00d9ff', toolBg: '#000814' }, headerLeftText: '#000000', headerLeftLabel: 'rgba(0, 0, 0, 0.7)', ghostBg: '#001d3d', ghostBorder: '#ff00ff', win: { bg: '#000814', border: '#ff00ff', text: '#00d9ff', accent: '#ff00ff' }, alert: { bg: '#001d3d', stroke: '#00d9ff' }, ctrlArea: { bg: '#000814', border: '#00d9ff' }, burst: '#00d9ff', check: '#1e293b' },
        paper: { bodyBg: '#fdf6e3', canvasBg: '#fffaf0', grid: '#3b3b3b66', headerLeft: '#000000', headerRight: '#555555', path: '#000000', controls: 'rgba(255, 250, 240, 0.9)', metricText: '#fdf6e3', btns: { undo: '#5a5a5a', reset: '#333333', guide: '#4a4a4a', whoa: '#3d3d3d', hint: '#6b6b6b', saved: '#2e4a3d', mega: '#2b2b2b', mute: '#eee8d5', muteIcon: '#000000', copy: '#eee8d5', gen: '#eee8d5', modeToggle: '#1a1a1a', orient: '#1a1a1a', solve: '#5a5a5a', editClear: '#333333', editBombs: '#000000', editNew: '#2e4a3d' }, modal: { bg: 'rgba(245, 230, 196, 0.95)', panelBg: '#fdf6e3', border: '#3b3b3b', text: '#1a1a1a', textMuted: '#5a5a5a', accent: '#000000' }, output: { bg: '#eee8d5', text: '#000000' }, colors: { gate: '#000000', goal: '#000000', block: '#cccccc', pin: '#000000', pinUnflipped: '#999999', filter: '#000000', portal: '#555555', cross: '#000000' }, palette: { bg: '#eee8d5', border: '#3b3b3b', itemBg: '#fdf6e3', itemBorder: '#3b3b3b', toolBg: '#eee8d5' }, headerLeftText: '#fdf6e3', headerLeftLabel: 'rgba(253, 246, 227, 0.7)', ghostBg: '#fdf6e3', ghostBorder: '#000000', win: { bg: '#fdf6e3', border: '#3b82f6', text: '#5a5a5a', accent: '#1a1a1a' }, alert: { bg: '#3b3b3b', stroke: '#fdf6e3' }, ctrlArea: { bg: '#eee8d5', border: '#3b3b3b' }, burst: '#eee8d5', check: '#000000' },
        winter: { bodyBg: '#e0f2fe', canvasBg: '#f0f9ff', grid: '#7dd3fcaa', headerLeft: '#0ea5e9', headerRight: '#0284c7', path: '#2563eb', controls: 'rgba(240, 249, 255, 0.9)', metricText: '#f0f9ff', btns: { undo: '#0369a1', reset: '#be123c', guide: '#6d28d9', whoa: '#1d4ed8', hint: '#0f766e', saved: '#15803d', mega: '#db2777', mute: '#bae6fd', muteIcon: '#0369a1', copy: '#bae6fd', gen: '#bae6fd', modeToggle: '#075985', orient: '#075985', solve: '#0284c7', editClear: '#be123c', editBombs: '#2563eb', editNew: '#15803d' }, modal: { bg: 'rgba(255, 255, 255, 0.95)', panelBg: '#f0f9ff', border: '#0ea5e9', text: '#0c4a6e', textMuted: '#0284c7', accent: '#0369a1' }, output: { bg: '#0c4a6e', text: '#f0f9ff' }, colors: { gate: '#0ea5e9', goal: '#2563eb', block: '#bae6fd', pin: '#2563eb', pinUnflipped: '#7dd3fc', filter: '#0ea5e9', portal: '#38bdf8', cross: '#0ea5e9' }, palette: { bg: '#e0f2fe', border: '#0ea5e9', itemBg: '#f0f9ff', itemBorder: '#0ea5e9', toolBg: '#e0f2fe' }, headerLeftText: '#ffffff', headerLeftLabel: 'rgba(255, 255, 255, 0.7)', ghostBg: '#f0f9ff', ghostBorder: '#0284c7', win: { bg: '#f0f9ff', border: '#0ea5e9', text: '#0284c7', accent: '#0369a1' }, alert: { bg: '#0ea5e9', stroke: '#ffffff' }, ctrlArea: { bg: '#e0f2fe', border: '#0ea5e9' }, burst: '#e0f2fe', check: '#0369a1' },
        summer: { bodyBg: '#fff7ed', canvasBg: '#ffedd5', grid: '#fb923caa', headerLeft: '#ea580c', headerRight: '#f97316', path: '#16a34a', controls: 'rgba(255, 237, 213, 0.9)', metricText: '#fff7ed', btns: { undo: '#c2410c', reset: '#b91c1c', guide: '#b45309', whoa: '#be185d', hint: '#ca8a04', saved: '#15803d', mega: '#ef4444', mute: '#fed7aa', muteIcon: '#9a3412', copy: '#fed7aa', gen: '#fed7aa', modeToggle: '#431407', orient: '#431407', solve: '#b45309', editClear: '#991b1b', editBombs: '#16a34a', editNew: '#15803d' }, modal: { bg: 'rgba(254, 243, 199, 0.95)', panelBg: '#fff7ed', border: '#ea580c', text: '#431407', textMuted: '#9a3412', accent: '#ea580c' }, output: { bg: '#431407', text: '#fb923c' }, colors: { gate: '#ea580c', goal: '#16a34a', block: '#fed7aa', pin: '#16a34a', pinUnflipped: '#fb923c', filter: '#ea580c', portal: '#f97316', cross: '#ea580c' }, palette: { bg: '#fff7ed', border: '#ea580c', itemBg: '#ffedd5', itemBorder: '#ea580c', toolBg: '#fff7ed' }, headerLeftText: '#fff7ed', headerLeftLabel: 'rgba(255, 247, 237, 0.7)', ghostBg: '#ffedd5', ghostBorder: '#ea580c', win: { bg: '#ffedd5', border: '#ea580c', text: '#9a3412', accent: '#431407' }, alert: { bg: '#ea580c', stroke: '#ffedd5' }, ctrlArea: { bg: '#fff7ed', border: '#ea580c' }, burst: '#fef9c3', check: '#ea580c' },
        glf: { bodyBg: '#bdc3c7', canvasBg: '#ecf0f1', grid: '#95a5a6', headerLeft: '#D21F1B', headerRight: '#4A90E2', path: '#F4D03F', controls: 'rgba(236, 240, 241, 0.8)', metricText: '#ecf0f1', btns: { undo: '#34495e', reset: '#D21F1B', guide: '#558735', whoa: '#2a6ebd', hint: '#d35400', saved: '#27ae60', mega: '#a51815', mute: '#bdc3c7', muteIcon: '#2c3e50', copy: '#bdc3c7', gen: '#bdc3c7', modeToggle: '#2c3e50', orient: '#2c3e50', solve: '#c4a112', editClear: '#a51815', editBombs: '#F4D03F', editNew: '#27ae60' }, modal: { bg: 'rgba(213, 219, 219, 0.95)', panelBg: '#ecf0f1', border: '#95a5a6', text: '#2c3e50', textMuted: '#7f8c8d', accent: '#D21F1B' }, output: { bg: '#2c3e50', text: '#93C572' }, colors: { gate: '#D21F1B', goal: '#F4D03F', block: '#bdc3c7', pin: '#D21F1B', pinUnflipped: '#7f8c8d', filter: '#2c3e50', portal: '#4A90E2', cross: '#D21F1B' }, palette: { bg: '#ecf0f1', border: '#D21F1B', itemBg: '#bdc3c7', itemBorder: '#95a5a6', toolBg: '#ecf0f1' }, headerLeftText: '#ffffff', headerLeftLabel: 'rgba(255, 255, 255, 0.7)', ghostBg: '#bdc3c7', ghostBorder: '#D21F1B', win: { bg: '#ecf0f1', border: '#D21F1B', text: '#7f8c8d', accent: '#2c3e50' }, alert: { bg: '#2c3e50', stroke: '#ecf0f1' }, ctrlArea: { bg: '#ecf0f1', border: '#95a5a6' }, burst: '#ecf0f1', check: '#D21F1B' }
    };

    function isValidHexColor(value) {
        return typeof value === 'string' && /^#[0-9a-fA-F]{6}$/.test(value.trim());
    }

    function parseGeminiSuggestionsPayload(data) {
        const textParts = [];
        const candidates = Array.isArray(data?.candidates) ? data.candidates : [];
        candidates.forEach(candidate => {
            const parts = candidate?.content?.parts;
            if (Array.isArray(parts)) {
                parts.forEach(part => {
                    if (typeof part?.text === 'string') textParts.push(part.text);
                });
            }
        });

        const parseCandidates = [];
        textParts.forEach(text => {
            parseCandidates.push(text);
            const fencedMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
            if (fencedMatch?.[1]) parseCandidates.push(fencedMatch[1]);
        });

        let parsed = null;
        let parseError = null;
        for (const candidateText of parseCandidates) {
            try {
                parsed = JSON.parse(candidateText);
                parseError = null;
                break;
            } catch (err) {
                parseError = err;
            }
        }
        if (!parsed) return { colors: null, error: parseError ? `Invalid JSON response: ${parseError.message}` : 'No JSON response text returned.' };

        if (!Array.isArray(parsed.suggestions)) return { colors: null, error: 'Invalid schema: suggestions must be an array.' };
        const normalized = [];
        for (const raw of parsed.suggestions) {
            const color = typeof raw === 'string' ? raw.trim() : '';
            if (isValidHexColor(color)) normalized.push(color.toUpperCase());
        }
        const unique = Array.from(new Set(normalized));
        if (unique.length < 6) return { colors: null, error: 'Invalid schema: need 6 valid #RRGGBB colors.' };
        return { colors: unique.slice(0, 6), error: null };
    }

    async function fetchGeminiThemeColors(themeName, themeObj) {
        const apiKey = "AIzaSyC7rfddVJfU4X9qziTa1le6Q2AWDRCTzn4";
        const systemPrompt = "You are a professional UI/UX color palette specialist. Your goal is to analyze the provided Pathfinder game theme and suggest exactly 6 new hex colors that expand the existing palette while maintaining visual consistency and accessibility.";
        const userPrompt = `Theme Name: ${themeName}
Current Colors: ${JSON.stringify(themeObj)}

Suggest 6 complementary hex colors in #RRGGBB format.`;
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const payload = {
            systemInstruction: { parts: [{ text: systemPrompt }] },
            contents: [{ parts: [{ text: userPrompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        suggestions: {
                            type: "ARRAY",
                            items: { type: "STRING", pattern: "^#[0-9A-Fa-f]{6}$" },
                            minItems: 6,
                            maxItems: 6
                        }
                    },
                    required: ["suggestions"]
                }
            }
        };

        const delays = [1000, 2000, 4000, 8000, 16000];
        let lastError = null;
        for (let i = 0; i < 6; i++) {
            try {
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const body = await res.json().catch(() => ({}));

                if (res.status === 429) {
                    lastError = `Rate limited (${res.status}).`;
                    throw new Error('Rate Limit');
                }
                if (!res.ok) {
                    const apiMessage = body?.error?.message || `HTTP ${res.status}`;
                    return { colors: null, error: `Gemini API error: ${apiMessage}` };
                }

                const parsed = parseGeminiSuggestionsPayload(body);
                if (parsed.colors) return { colors: parsed.colors, error: null };
                lastError = parsed.error;
            } catch (err) {
                if (err.message !== 'Rate Limit') lastError = err?.message || 'Unknown request failure.';
            }
            if (i < delays.length) await new Promise(r => setTimeout(r, delays[i]));
        }
        return { colors: null, error: lastError || 'Unable to generate suggestions.' };
    }

    APP.Themes = APP.Themes || {};
    APP.Themes.THEMES = THEMES;
    let currentTheme = 'classic';
    // ======================================================
    // I) Themes
    // ======================================================

    const CLASSIC_LEAVE = { bg: '#dc2626', hover: '#b91c1c', text: '#ffffff', border: '#b91c1c' };

    function toRgb(hex, fallback = { r: 220, g: 38, b: 38 }) {
        const normalized = (hex || '').replace('#', '');
        if (!/^[0-9a-fA-F]{6}$/.test(normalized)) return fallback;
        return { r: parseInt(normalized.slice(0, 2), 16), g: parseInt(normalized.slice(2, 4), 16), b: parseInt(normalized.slice(4, 6), 16) };
    }

    function darkenHex(hex, factor = 0.85) {
        const { r, g, b } = toRgb(hex);
        return `#${Math.max(0, Math.floor(r * factor)).toString(16).padStart(2, '0')}${Math.max(0, Math.floor(g * factor)).toString(16).padStart(2, '0')}${Math.max(0, Math.floor(b * factor)).toString(16).padStart(2, '0')}`;
    }

    function getLeaveThemeColors(theme, isClassic = false) {
        if (isClassic) return { ...CLASSIC_LEAVE };
        const fallbackBase = theme.headerRight || theme.btns?.editClear || theme.btns?.reset || theme.colors?.goal || '#7f1d1d';
        const leave = theme.leave || {};
        let bg = leave.bg || fallbackBase;
        if (bg.toLowerCase() === CLASSIC_LEAVE.bg) bg = theme.headerLeft || theme.colors?.goal || '#7f1d1d';
        let hover = leave.hover || darkenHex(bg, 0.85);
        if (hover.toLowerCase() === CLASSIC_LEAVE.hover) hover = darkenHex(bg, 0.78);
        const { r, g, b } = toRgb(bg);
        const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        const text = leave.text || (luminance > 0.55 ? '#0f172a' : '#ffffff');
        const border = leave.border || hover;
        return { bg, hover, text, border };
    }

    function normalizeTheme(theme, key = 'theme') {
        const t = theme || {};
        t.btns = t.btns || {};
        t.modal = t.modal || {};
        t.output = t.output || {};
        t.colors = t.colors || {};
        t.palette = t.palette || {};
        t.win = t.win || {};
        t.alert = t.alert || {};
        t.ctrlArea = t.ctrlArea || {};

        t.bodyBg = t.bodyBg || '#e0f2fe';
        t.canvasBg = t.canvasBg || '#ffffff';
        t.grid = t.grid || '#94a3b8';
        t.headerLeft = t.headerLeft || '#dc2626';
        t.headerRight = t.headerRight || '#2563eb';
        t.path = t.path || '#2563eb';
        t.controls = t.controls || 'rgba(255, 255, 255, 0.7)';
        t.metricText = t.metricText || '#ffffff';
        t.headerLeftText = t.headerLeftText || '#ffffff';
        t.headerLeftLabel = t.headerLeftLabel || 'rgba(255, 255, 255, 0.7)';
        t.ghostBg = t.ghostBg || t.canvasBg;
        t.ghostBorder = t.ghostBorder || t.headerRight;

        const btnFallbacks = { undo: t.grid, reset: t.headerLeft, guide: t.headerRight, whoa: t.headerRight, hint: t.headerRight, saved: t.headerRight, mega: t.headerRight, mute: t.canvasBg, muteIcon: t.headerRight, copy: t.canvasBg, gen: t.canvasBg, modeToggle: t.headerRight, orient: t.headerRight, solve: t.headerRight, editClear: t.headerLeft, editBombs: t.colors.goal || t.headerLeft, editNew: t.headerRight };
        Object.keys(btnFallbacks).forEach(btnKey => { t.btns[btnKey] = t.btns[btnKey] || btnFallbacks[btnKey]; });

        t.modal.bg = t.modal.bg || 'rgba(248, 250, 252, 0.95)';
        t.modal.panelBg = t.modal.panelBg || t.canvasBg;
        t.modal.border = t.modal.border || t.grid;
        t.modal.text = t.modal.text || t.headerRight;
        t.modal.textMuted = t.modal.textMuted || t.grid;
        t.modal.accent = t.modal.accent || t.headerLeft;

        t.output.bg = t.output.bg || t.bodyBg;
        t.output.text = t.output.text || t.modal.text;

        t.colors.gate = t.colors.gate || t.headerRight;
        t.colors.goal = t.colors.goal || t.headerLeft;
        t.colors.block = t.colors.block || t.canvasBg;
        t.colors.pin = t.colors.pin || t.colors.goal;
        t.colors.pinUnflipped = t.colors.pinUnflipped || t.grid;
        t.colors.filter = t.colors.filter || t.modal.text;
        t.colors.portal = t.colors.portal || t.headerRight;
        t.colors.cross = t.colors.cross || t.colors.filter;

        t.palette.bg = t.palette.bg || t.bodyBg;
        t.palette.border = t.palette.border || t.grid;
        t.palette.itemBg = t.palette.itemBg || t.canvasBg;
        t.palette.itemBorder = t.palette.itemBorder || t.grid;
        t.palette.toolBg = t.palette.toolBg || t.palette.bg;

        t.win.bg = t.win.bg || t.canvasBg;
        t.win.border = t.win.border || t.headerRight;
        t.win.text = t.win.text || t.modal.textMuted;
        t.win.accent = t.win.accent || t.modal.accent;

        t.alert.bg = t.alert.bg || t.headerLeft;
        t.alert.stroke = t.alert.stroke || t.grid;

        t.ctrlArea.bg = t.ctrlArea.bg || t.palette.bg;
        t.ctrlArea.border = t.ctrlArea.border || t.palette.border;

        t.burst = t.burst || t.palette.itemBg;
        t.check = t.check || t.colors.filter;
        t.leave = getLeaveThemeColors(t, key === 'classic');
        return t;
    }

    function ensureThemeLeaveColors() {
        Object.keys(THEMES).forEach(key => {
            THEMES[key] = normalizeTheme(THEMES[key], key);
        });
    }

    function applyTheme(name) {
        if (name === 'chaos') { THEMES.chaos = normalizeTheme({ bodyBg: rc(), canvasBg: rc(), grid: rc(), headerLeft: rc(), headerRight: rc(), path: rc(), controls: rc(), metricText: rc(), btns: { undo: rc(), reset: rc(), guide: rc(), whoa: rc(), hint: rc(), saved: rc(), mega: rc(), mute: rc(), muteIcon: rc(), copy: rc(), gen: rc(), modeToggle: rc(), orient: rc(), solve: rc(), editClear: rc(), editBombs: rc(), editNew: rc() }, modal: { bg: rc(), panelBg: rc(), border: rc(), text: rc(), textMuted: rc(), accent: rc() }, output: { bg: rc(), text: rc() }, colors: { gate: rc(), goal: rc(), block: rc(), pin: rc(), pinUnflipped: rc(), filter: rc(), portal: rc(), cross: rc() }, palette: { bg: rc(), border: rc(), itemBg: rc(), itemBorder: rc(), toolBg: rc() }, headerLeftText: rc(), headerLeftLabel: rc(), ghostBg: rc(), ghostBorder: rc(), win: { bg: rc(), border: rc(), text: rc(), accent: rc() }, alert: { bg: rc(), stroke: rc() }, ctrlArea: { bg: rc(), border: rc() }, burst: rc(), check: rc(), leave: { bg: rc(), hover: rc(), text: rc(), border: rc() } }, 'chaos'); }
        currentTheme = name; APP.Themes.currentTheme = currentTheme; const t = THEMES[name]; const root = document.documentElement; 
        root.style.setProperty('--theme-gate', t.colors.gate); root.style.setProperty('--theme-goal', t.colors.goal); root.style.setProperty('--theme-block', t.colors.block); root.style.setProperty('--theme-block-dot', t.grid); root.style.setProperty('--theme-pin', t.colors.pin); root.style.setProperty('--theme-portal', t.colors.portal); root.style.setProperty('--theme-filter', t.colors.filter); root.style.setProperty('--theme-cross', t.colors.cross); root.style.setProperty('--theme-modal-bg', t.modal.bg); root.style.setProperty('--theme-modal-panel', t.modal.panelBg); root.style.setProperty('--theme-modal-border', t.modal.border); root.style.setProperty('--theme-modal-text', t.modal.text); root.style.setProperty('--theme-modal-muted', t.modal.textMuted); root.style.setProperty('--theme-modal-accent', t.modal.accent); root.style.setProperty('--theme-win-bg', t.win.bg); root.style.setProperty('--theme-win-border', t.win.border); root.style.setProperty('--theme-win-text', t.win.text); root.style.setProperty('--theme-win-accent', t.win.accent); root.style.setProperty('--theme-alert-bg', t.alert?.bg || '#1e40af'); root.style.setProperty('--theme-alert-stroke', t.alert?.stroke || '#93c5fd');
        const alertBg = (t.alert?.bg || '#1e40af');
        const hex = alertBg.replace('#','');
        let r = 30, g = 64, b = 175;
        if (/^[0-9a-fA-F]{6}$/.test(hex)) { r = parseInt(hex.slice(0,2),16); g = parseInt(hex.slice(2,4),16); b = parseInt(hex.slice(4,6),16); }
        const luminance = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
        const alertText = name === 'classic' ? '#ffffff' : (luminance > 0.55 ? '#0f172a' : '#ffffff');
        root.style.setProperty('--theme-alert-text', alertText);
        root.style.setProperty('--theme-logo-bg', t.canvasBg); root.style.setProperty('--theme-logo-grid', t.grid); root.style.setProperty('--theme-logo-path', t.path === 'rainbow' ? '#3b82f6' : t.path); root.style.setProperty('--theme-logo-gate', t.colors.gate); root.style.setProperty('--theme-logo-goal', t.colors.goal);
        root.style.setProperty('--theme-burst', t.burst || '#fef9c3'); root.style.setProperty('--theme-check', t.check || '#1e293b');
        const leave = getLeaveThemeColors(t, name === 'classic');
        root.style.setProperty('--theme-leave-bg', leave.bg); root.style.setProperty('--theme-leave-hover', leave.hover); root.style.setProperty('--theme-leave-text', leave.text); root.style.setProperty('--theme-leave-border', leave.border);
        
        document.body.style.backgroundColor = t.bodyBg; cvs.style.backgroundColor = t.canvasBg; 
        $('headerLeft').style.backgroundColor = t.canvasBg;
        $('headerMiddle').style.backgroundColor = t.headerLeft;
        $('headerRight').style.backgroundColor = t.headerRight;

        $('headerBar').style.borderColor = t.grid; 
        $('levelTitle').style.color = t.headerLeftText; 
        $('levelLabelText').style.color = t.headerLeftLabel; 
        const ghost = $('dragGhost'); ghost.style.backgroundColor = t.ghostBg; ghost.style.borderColor = t.ghostBorder; const pal = $('editorPalette'); pal.style.backgroundColor = t.palette.bg; pal.style.borderColor = t.palette.border; document.querySelectorAll('.palette-item').forEach(item => { if (item.classList.contains('palette-tool')) { item.style.backgroundColor = t.palette.toolBg; } else if (item.id !== 'editCopyMetrics') { item.style.backgroundColor = t.palette.itemBg; } item.style.borderColor = t.palette.itemBorder; }); $('editCopyMetrics').style.backgroundColor = t.headerLeft; $('editCopyMetrics').style.borderColor = t.palette.itemBorder; const pc = $('playControls'); pc.style.backgroundColor = t.controls; pc.style.borderColor = t.grid; $('undoBtn').style.backgroundColor = t.btns.undo; $('resetBtn').style.backgroundColor = t.btns.reset; $('guideBtn').style.backgroundColor = t.btns.guide; $('whoaBtn').style.backgroundColor = t.btns.whoa;
        
        const isDark = (t.bodyBg === '#020617' || t.bodyBg === '#000000');
        const neutralBtn = isDark ? '#334155' : '#e2e8f0';
        const neutralText = isDark ? '#f8fafc' : '#475569';
        
        $('openThemeModalBtn').style.backgroundColor = neutralBtn;
        $('openThemeModalBtn').style.color = neutralText;
        $('openThemeModalBtn').style.borderColor = t.modal.border;
        $('orientationToggleBtn').style.backgroundColor = t.btns.orient || t.btns.modeToggle || t.headerRight || '#1e293b';
        $('orientationToggleBtn').style.color = '#ffffff';
        $('orientationToggleBtn').style.borderColor = t.grid;

        $('megaSolverBtn').style.backgroundColor = t.btns.mega || t.btns.solve || '#c026d3'; $('editResetGrid').style.backgroundColor = t.btns.editClear || t.btns.reset || '#dc2626'; $('editNewLevel').style.backgroundColor = t.btns.editNew || t.btns.saved || '#0a8a65'; $('editHelpBtn').style.backgroundColor = t.btns.guide; $('editMegaSolver').style.backgroundColor = t.btns.solve || t.headerRight || '#c026d3'; $('editTrapSpotsBtn').style.backgroundColor = t.btns.editBombs || t.colors.goal || '#ef4444'; $('modeToggleBtn').style.backgroundColor = t.btns.modeToggle || t.headerRight || '#1e293b'; $('editModeToggleBtn').style.backgroundColor = t.btns.modeToggle || t.headerRight || '#1e293b'; const muteBtn = $('muteBtn'); muteBtn.style.backgroundColor = neutralBtn; muteBtn.style.color = neutralText; muteBtn.style.borderColor = t.modal.border; $('muteIcon').style.color = neutralText; $('muteSlash').style.color = neutralText; $('devCopyBtn').style.backgroundColor = t.btns.copy; $('editCopyBtn').style.backgroundColor = t.btns.copy; $('devGenBtn').style.backgroundColor = t.btns.gen; $('editGenBtn').style.backgroundColor = t.btns.gen; $('devCopyBtn').style.color = t.btns.muteIcon; $('editCopyBtn').style.color = t.btns.muteIcon; $('devGenBtn').style.color = t.btns.muteIcon; $('editGenBtn').style.color = t.btns.muteIcon; $('exportLabel').style.color = t.btns.muteIcon; document.querySelectorAll('.metric-label').forEach(el => el.style.color = t.metricText); [$('solutionOutput'), $('winSolutionOutput'), $('megaOutput')].forEach(el => { if(el) { el.style.backgroundColor = t.output?.bg || '#0f172a'; el.style.color = t.output?.text || '#38bdf8'; el.style.borderColor = t.modal.border; }}); $('gridSizeMinusBtn').style.backgroundColor = t.btns.copy; $('gridSizeMinusBtn').style.color = t.btns.muteIcon; $('gridSizeMinusBtn').style.borderColor = t.palette.itemBorder; $('gridSizePlusBtn').style.backgroundColor = t.btns.copy; $('gridSizePlusBtn').style.color = t.btns.muteIcon; $('gridSizePlusBtn').style.borderColor = t.palette.itemBorder; $('gridRotateBtn').style.backgroundColor = t.btns.copy; $('gridRotateBtn').style.color = t.btns.muteIcon; $('gridRotateBtn').style.borderColor = t.palette.itemBorder; $('gridMirrorBtn').style.backgroundColor = t.btns.copy; $('gridMirrorBtn').style.color = t.btns.muteIcon; $('gridMirrorBtn').style.borderColor = t.palette.itemBorder; $('gridSizeLabel').style.color = t.btns.muteIcon;
        const gArea = $('gridControlArea'); if(gArea) { gArea.style.backgroundColor = t.ctrlArea?.bg || '#f8fafc'; gArea.style.borderColor = t.ctrlArea?.border || '#cbd5e1'; }
        const winModalContent = $('winModalContent'); $('winCircle').style.backgroundColor = t.win.bg; $('winCircle').style.borderColor = t.win.border; winModalContent.querySelector('h2').style.color = t.win.border; winModalContent.querySelector('p').style.color = t.win.text; $('nextLevelModalBtn').style.color = t.headerRight; $('dismissWinModalBtn').style.color = t.headerRight; ENGINE.rainbowActive = (name === 'classic');
    }
    
    function populateThemes() {
        if (!window.ORIGINAL_THEMES) {
            window.ORIGINAL_THEMES = JSON.parse(JSON.stringify(THEMES));
            delete window.ORIGINAL_THEMES['chaos'];
        }
        const grid = $('themeGrid'); grid.innerHTML = ''; const themeKeys = Object.keys(THEMES); if(!themeKeys.includes('chaos')) themeKeys.push('chaos');
        themeKeys.forEach(key => { const t = THEMES[key] || THEMES.classic; const btn = document.createElement('div'); btn.className = "flex flex-col items-center gap-2 cursor-pointer transition-transform hover:scale-105 active:scale-95 p-2 rounded-xl hover:bg-slate-100"; btn.onclick = () => { applyTheme(key); $('themeModal').classList.add('hidden'); }; const circle = document.createElement('div'); circle.className = "w-12 h-12 rounded-full border-4 shadow-md"; circle.style.backgroundColor = t.headerRight || '#000'; circle.style.borderColor = t.canvasBg || '#fff'; const label = document.createElement('span'); label.className = "text-[0.65rem] font-black text-slate-600 uppercase tracking-widest"; label.innerText = key; btn.appendChild(circle); btn.appendChild(label); grid.appendChild(btn); });
    }
    
    function replaceThemeColor(themeKey, oldColor, newColor, category) {
        if (!window.THEME_UNDO_STACKS) window.THEME_UNDO_STACKS = {};
        if (!window.THEME_UNDO_STACKS[themeKey]) window.THEME_UNDO_STACKS[themeKey] = [];
        window.THEME_UNDO_STACKS[themeKey].push(JSON.parse(JSON.stringify(THEMES[themeKey])));
        
        const t = THEMES[themeKey];
        function replaceDeep(obj, targetScope = null) {
            for (let k in obj) {
                if (typeof obj[k] === 'object' && obj[k] !== null) {
                    if (targetScope && k !== targetScope) continue;
                    replaceDeep(obj[k]);
                } else if (obj[k] === oldColor) {
                    obj[k] = newColor;
                }
            }
        }

        if (category === "Buttons") replaceDeep(t.btns);
        else if (category === "Grid Items") { replaceDeep(t.colors); if (t.grid === oldColor) t.grid = newColor; if (t.path === oldColor) t.path = newColor; }
        else if (category === "Misc") { 
            if (t.bodyBg === oldColor) t.bodyBg = newColor;
            if (t.canvasBg === oldColor) t.canvasBg = newColor;
            if (t.headerLeft === oldColor) t.headerLeft = newColor;
            if (t.headerRight === oldColor) t.headerRight = newColor;
            replaceDeep(t.modal);
            replaceDeep(t.palette);
            replaceDeep(t.win);
            replaceDeep(t.alert);
            replaceDeep(t.ctrlArea);
            if (t.burst === oldColor) t.burst = newColor;
            if (t.check === oldColor) t.check = newColor;
        } else {
            replaceDeep(t);
        }
        
        renderThemeEditors();
        populateThemes();
    }
    
    function createThemeEditorBlock(themeKey) {
        const container = document.createElement('div');
        container.className = "flex flex-col gap-2";
        
        const header = document.createElement('h4');
        header.className = "font-black text-[var(--theme-modal-accent)] uppercase tracking-widest text-sm";
        header.innerText = themeKey.replace('_', ' ');
        container.appendChild(header);

        const t = THEMES[themeKey];
        const btnColors = new Set(Object.values(t.btns || {}));
        const gridColorsArr = [ t.colors.gate, t.colors.goal, t.colors.block, t.colors.pin, t.colors.pinUnflipped, t.colors.filter, t.colors.portal, t.colors.cross, t.grid ];
        if (t.path !== 'rainbow') gridColorsArr.push(t.path);
        const gridColors = new Set(gridColorsArr.filter(Boolean));

        const miscColors = new Set();
        const skipMiscKeys = ['btns', 'colors', 'path', 'grid'];
        function extractMisc(obj, isRoot=false) {
            for(let k in obj) {
                if (isRoot && skipMiscKeys.includes(k)) continue;
                if (typeof obj[k] === 'object' && obj[k] !== null) extractMisc(obj[k], false);
                else if (typeof obj[k] === 'string' && (obj[k].startsWith('#') || obj[k].startsWith('rgb') || obj[k].startsWith('rgba'))) {
                    miscColors.add(obj[k]);
                }
            }
        }
        extractMisc(t, true);

        let arrBtns = Array.from(btnColors);
        let arrGrid = Array.from(gridColors);
        let arrMisc = Array.from(miscColors);

        const hl = t.headerLeft;
        const hr = t.headerRight;
        arrMisc = arrMisc.filter(c => c !== hl && c !== hr);
        if (hr) arrMisc.unshift(hr);
        if (hl) arrMisc.unshift(hl);

        const columnsContainer = document.createElement('div');
        columnsContainer.className = "flex w-full justify-between items-stretch gap-0.5 mb-1";

        const buildSwatch = (c, isOverflow, category) => {
            const swatch = document.createElement('div');
            swatch.className = "w-9 h-9 md:w-10 md:h-10 rounded shadow-sm border cursor-pointer hover:scale-110 transition-transform box-border shrink-0";
            swatch.style.backgroundColor = c;
            swatch.style.pointerEvents = 'auto';
            swatch.classList.add('border-slate-300');
            
            swatch.draggable = false;
            swatch.dataset.themeColor = c;
            swatch.dataset.themeKey = themeKey;
            swatch.dataset.category = category;
            swatch.style.touchAction = 'none';
            
            swatch.onpointerdown = e => {
                e.preventDefault();
                e.stopPropagation();

                if (ENGINE.themeTapSelectedColor && ENGINE.themeTapSelectedTheme === themeKey) {
                    const sourceColor = ENGINE.themeTapSelectedColor;
                    const targetColor = c;
                    const sourceCategory = ENGINE.themeTapCategory;
                    const targetCategory = swatch.dataset.category;
                    
                    if (sourceColor !== targetColor && sourceCategory === targetCategory) {
                        replaceThemeColor(themeKey, targetColor, sourceColor, targetCategory);
                    } else if (sourceCategory !== targetCategory) {
                        showMessage("Mismatched Categories", "text-white font-black");
                    }
                    
                    ENGINE.themeTapSelectedColor = null;
                    ENGINE.themeTapSelectedTheme = null;
                    ENGINE.themeTapCategory = null;
                    document.querySelectorAll('.theme-swatch-selected').forEach(el => el.classList.remove('ring-4', 'ring-[var(--theme-modal-accent)]', 'theme-swatch-selected', 'z-10', 'scale-110'));
                    
                    setLogicState(IDLE);
                    ghostEl.style.display = 'none';
                    return;
                }

                ENGINE.themeTapSelectedColor = c;
                ENGINE.themeTapSelectedTheme = themeKey;
                ENGINE.themeTapCategory = category;
                
                document.querySelectorAll('.theme-swatch-selected').forEach(el => el.classList.remove('ring-4', 'ring-[var(--theme-modal-accent)]', 'theme-swatch-selected', 'z-10', 'scale-110'));
                swatch.classList.add('ring-4', 'ring-[var(--theme-modal-accent)]', 'theme-swatch-selected', 'z-10', 'scale-110');

                ENGINE.themeDragColor = c;
                ENGINE.themeDragTheme = themeKey;
                ENGINE.themeDragCategory = category;
                setLogicState(THEME_DRAG);
                ghostEl.style.width = '32px';
                ghostEl.style.height = '32px';
                ghostEl.style.backgroundColor = c;
                ghostEl.style.borderColor = '#000';
                ghostEl.className = 'flex items-center justify-center rounded shadow-lg border-2 border-black border-dashed fixed pointer-events-none z-[1000]';
                ghostEl.innerHTML = '';
                ghostEl.style.display = 'flex';
                ghostEl.style.left = e.clientX + 'px';
                ghostEl.style.top = e.clientY + 'px';
            };
            return swatch;
        };

        const buildCol = (title, colorArr) => {
            const col = document.createElement('div');
            col.className = "flex-1 flex flex-col items-center p-0.5 rounded bg-black/5";
            const ctitle = document.createElement('div');
            ctitle.className = "text-[0.6rem] font-black uppercase text-[var(--theme-modal-muted)] mb-1.5 tracking-widest text-center";
            ctitle.innerText = title;
            col.appendChild(ctitle);

            const grid = document.createElement('div');
            grid.className = "grid grid-cols-3 gap-0.5 w-full justify-items-center";
            colorArr.forEach(c => {
                grid.appendChild(buildSwatch(c, false, title));
            });
            col.appendChild(grid);
            return col;
        };

        columnsContainer.appendChild(buildCol("Buttons", arrBtns));
        const div1 = document.createElement('div'); div1.className = "w-[2px] bg-[var(--theme-modal-border)] opacity-30 mx-0.5 flex-shrink-0 my-2 rounded-full";
        columnsContainer.appendChild(div1);
        columnsContainer.appendChild(buildCol("Grid Items", arrGrid));
        const div2 = document.createElement('div'); div2.className = "w-[2px] bg-[var(--theme-modal-border)] opacity-30 mx-0.5 flex-shrink-0 my-2 rounded-full";
        columnsContainer.appendChild(div2);
        columnsContainer.appendChild(buildCol("Misc", arrMisc));
        
        container.appendChild(columnsContainer);

        const aiColorsContainer = document.createElement('div');
        aiColorsContainer.className = "flex flex-col items-center w-full mt-1 bg-black/5 rounded p-1.5";
        
        const aiTitle = document.createElement('div');
        aiTitle.className = "text-[0.55rem] font-black uppercase text-[var(--theme-modal-accent)] mb-1 tracking-widest";
        aiTitle.innerText = "Complementary Palette (AI)";
        aiColorsContainer.appendChild(aiTitle);

        const aiGrid = document.createElement('div');
        aiGrid.className = "flex justify-center gap-1.5 w-full min-h-[2.5rem] flex-wrap items-center";
        aiColorsContainer.appendChild(aiGrid);

        const handleAiGeneration = async () => {
            aiGrid.innerHTML = '<span class="text-[0.55rem] font-bold text-[var(--theme-modal-muted)] animate-pulse uppercase tracking-widest">Calling Specialist...</span>';
            const { colors, error } = await fetchGeminiThemeColors(themeKey, t);
            if (colors && colors.length >= 6) {
                if (!window.THEME_AI_COLORS) window.THEME_AI_COLORS = {};
                window.THEME_AI_COLORS[themeKey] = colors.slice(0, 6);
                aiGrid.innerHTML = '';
                window.THEME_AI_COLORS[themeKey].forEach(c => aiGrid.appendChild(buildSwatch(c, false, "Misc")));
            } else {
                aiGrid.innerHTML = '';
                const failWrap = document.createElement('div');
                failWrap.className = "flex flex-col items-center gap-1";
                const failBtn = document.createElement('button');
                failBtn.className = "text-[0.55rem] text-red-500 font-bold uppercase tracking-widest hover:scale-105 transition-transform";
                failBtn.innerText = "Generation Failed - Retry?";
                failBtn.onclick = handleAiGeneration;
                const detail = document.createElement('div');
                detail.className = "text-[0.5rem] text-[var(--theme-modal-muted)] max-w-[16rem] text-center leading-tight";
                detail.innerText = error || "Unknown Gemini error.";
                failWrap.appendChild(failBtn);
                failWrap.appendChild(detail);
                aiGrid.appendChild(failWrap);
            }
        };

        if (!window.THEME_AI_COLORS) window.THEME_AI_COLORS = {};
        if (window.THEME_AI_COLORS[themeKey]) {
            window.THEME_AI_COLORS[themeKey].forEach(c => aiGrid.appendChild(buildSwatch(c, false, "Misc")));
        } else {
            const genBtn = document.createElement('button');
            genBtn.className = "bg-[var(--theme-modal-panel)] border border-[var(--theme-modal-border)] text-[var(--theme-modal-text)] px-4 py-2 rounded-lg font-black text-[0.6rem] uppercase tracking-widest shadow-sm hover:brightness-95 transition active:scale-95";
            genBtn.innerText = "Generate Suggestions";
            genBtn.onclick = handleAiGeneration;
            aiGrid.appendChild(genBtn);
        }
        container.appendChild(aiColorsContainer);

        const controlsRow = document.createElement('div');
        controlsRow.className = "flex gap-2 items-center mt-2";

        const textarea = document.createElement('textarea');
        textarea.className = "flex-grow h-8 bg-[var(--theme-modal-panel)] text-[var(--theme-modal-text)] border border-[var(--theme-modal-border)] rounded px-2 py-1.5 text-[0.6rem] font-mono no-scrollbar whitespace-nowrap overflow-x-auto resize-none leading-tight";
        textarea.readOnly = true;
        textarea.placeholder = "Export code will appear here...";

        const exportBtn = document.createElement('button');
        exportBtn.className = "bg-[var(--theme-modal-panel)] border border-[var(--theme-modal-border)] text-[var(--theme-modal-text)] px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:brightness-95 transition shrink-0";
        exportBtn.innerText = "Export";
        exportBtn.onclick = () => {
            const code = `${themeKey}: ${JSON.stringify(THEMES[themeKey])},`;
            textarea.value = code;
            textarea.select();
            document.execCommand('copy');
            const origText = exportBtn.innerText;
            exportBtn.innerText = "Copied!";
            setTimeout(() => exportBtn.innerText = origText, 1500);
        };

        const undoBtn = document.createElement('button');
        undoBtn.className = "bg-slate-500 text-white px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:bg-slate-600 transition shadow-sm shrink-0";
        undoBtn.innerText = "Undo";
        const canUndo = window.THEME_UNDO_STACKS && window.THEME_UNDO_STACKS[themeKey] && window.THEME_UNDO_STACKS[themeKey].length > 0;
        if (!canUndo) { undoBtn.disabled = true; undoBtn.classList.add('opacity-50', 'cursor-not-allowed'); }
        undoBtn.onclick = () => {
            if (canUndo) {
                const prev = window.THEME_UNDO_STACKS[themeKey].pop();
                THEMES[themeKey] = JSON.parse(JSON.stringify(prev));
                renderThemeEditors();
                populateThemes();
            }
        };

        const resetBtn = document.createElement('button');
        resetBtn.className = "bg-red-600 text-white px-3 py-1 rounded font-black text-[0.6rem] uppercase tracking-wider hover:bg-red-700 transition shadow-sm shrink-0";
        resetBtn.innerText = "Reset";
        resetBtn.onclick = () => {
            if (window.ORIGINAL_THEMES && window.ORIGINAL_THEMES[themeKey]) {
                THEMES[themeKey] = JSON.parse(JSON.stringify(window.ORIGINAL_THEMES[themeKey]));
                if (!window.THEME_UNDO_STACKS) window.THEME_UNDO_STACKS = {};
                window.THEME_UNDO_STACKS[themeKey] = [];
                renderThemeEditors();
                populateThemes();
            }
        };

        controlsRow.appendChild(textarea);
        controlsRow.appendChild(exportBtn);
        controlsRow.appendChild(undoBtn);
        controlsRow.appendChild(resetBtn);
        container.appendChild(controlsRow);

        return container;
    }
    
    function renderThemeEditors() {
        const list = $('themeEditList');
        list.innerHTML = '';
        const keys = Object.keys(window.ORIGINAL_THEMES).filter(k => k !== 'classic');
        keys.forEach((key, idx) => {
            list.appendChild(createThemeEditorBlock(key));
            if (idx < keys.length - 1) {
                const hr = document.createElement('hr');
                hr.className = "border-[var(--theme-modal-border)] opacity-30 my-4";
                list.appendChild(hr);
            }
        });
    }

    function closeAllModals() {
        $('guideModal').classList.add('hidden');
        $('editorHelpModal').classList.add('hidden');
        $('winModal').classList.add('hidden');
        $('megaModal').classList.add('hidden');
        $('themeModal').classList.add('hidden');
        $('unsavedModal').classList.add('hidden');
    }
    
    function getRealLength(state = ENGINE) { return state.path.length > 0 ? state.path.length - 1 - state.isPortalJump.size : 0; }
    
    function rebuildDerivedPathState(state = ENGINE) {
        const oldFlipCount = state.flipCount;
        state.visitedCounts.clear(); state.cellUsage.clear(); state.intersections = 0; state.flipCount = 0; state.crossedFlippingFilters.clear(); const l = state.mode === PLAY ? state.level : state.editor.workingLevel; if (state.path.length === 0) { if (oldFlipCount !== 0) state.lastFlipTime = Date.now(); return; }
        for (let i = 0; i < state.path.length; i++) {
            const k = state.path[i]; const c = state.visitedCounts.get(k) || 0; if (c > 0 && k !== state.activeGateKey && (l && k !== l.goalKey)) { state.intersections++; } state.visitedCounts.set(k, c + 1);
            if (i > 0 && !state.isPortalJump.has(i)) { const prevK = state.path[i-1]; const p1 = UNPACK(prevK), p2 = UNPACK(k); const axis = (p2.y === p1.y) ? H : V; let uPrev = state.cellUsage.get(prevK) || { h: false, v: false }; if (axis === H) uPrev.h = true; else uPrev.v = true; state.cellUsage.set(prevK, uPrev); let uCur = state.cellUsage.get(k) || { h: false, v: false }; if (axis === H) uCur.h = true; else uCur.v = true; state.cellUsage.set(k, uCur); }
            if (l && l.flippingFilterMap.has(k) && !state.crossedFlippingFilters.has(k)) { state.crossedFlippingFilters.set(k, state.flipCount); state.flipCount++; }
        }
        if (state.flipCount !== oldFlipCount) state.lastFlipTime = Date.now();
    }
    
    function assertStateConsistency(state = ENGINE) { if (!state.isDevMode) return; const l = state.mode === PLAY ? state.level : state.editor.workingLevel; if (!l) return; const originalIntersections = state.intersections; const originalCounts = new Map(state.visitedCounts); rebuildDerivedPathState(state); if (originalIntersections !== state.intersections) { console.error("Invariant broken: Intersections mismatch."); } originalCounts.forEach((v, k) => { if (state.visitedCounts.get(k) !== v) console.error("Invariant broken: Visited count mismatch."); }); }
    function assertLevelShape(level) { if (!level) throw new Error("Level object is null"); if (level.goalKey === undefined || level.goalKey === -1) throw new Error("Level missing goal"); if (!Array.isArray(level.gateKeys) || level.gateKeys.length === 0) throw new Error("Level missing gates"); if (!level.grid || !level.grid.w || !level.grid.h) throw new Error("Grid dimensions missing"); }
    function getLevelBounds(l) { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; const update = (k) => { if (k === -1) return; const p = UNPACK(k); if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y; if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y; }; if (l.goalKey !== -1) update(l.goalKey); l.gateKeys.forEach(update); l.falseGoalKeys.forEach(update); l.blockSet.forEach(update); l.gooseSet.forEach(update); l.mustPassKeys.forEach(update); l.mustCrossKeys.forEach(update); l.filterMap.forEach((v, k) => update(k)); l.flippingFilterMap.forEach((v, k) => update(k)); l.portalMap.forEach((v, k) => update(k)); if (minX === Infinity) return null; return { minX, minY, maxX, maxY }; }
    
    function shiftLevel(l, dx, dy) { if (dx === 0 && dy === 0) return; const shift = (k) => { if (k === -1) return -1; const p = UNPACK(k); return PACK(p.x + dx, p.y + dy); }; l.goalKey = shift(l.goalKey); l.gateKeys = l.gateKeys.map(shift); l.falseGoalKeys = new Set(Array.from(l.falseGoalKeys).map(shift)); l.blockSet = new Set(Array.from(l.blockSet).map(shift)); l.gooseSet = new Set(Array.from(l.gooseSet).map(shift)); l.mustPassKeys = l.mustPassKeys.map(shift); l.mustCrossKeys = l.mustCrossKeys.map(shift); const newFilterMap = new Map(); l.filterMap.forEach((v, k) => newFilterMap.set(shift(k), v)); l.filterMap = newFilterMap; const newFlipMap = new Map(); l.flippingFilterMap.forEach((v, k) => newFlipMap.set(shift(k), v)); l.flippingFilterMap = newFlipMap; const newPortalMap = new Map(); l.portalMap.forEach((v, k) => { newPortalMap.set(shift(k), { dest: v.dest === -1 ? -1 : shift(v.dest), color: v.color }); }); l.portalMap = newPortalMap; l.portalVisuals = l.portalVisuals.map(pv => ({ k1: shift(pv.k1), k2: shift(pv.k2), color: pv.color })); if (ENGINE.editor.pendingPortal) { ENGINE.editor.pendingPortal = shift(ENGINE.editor.pendingPortal); } ENGINE.path = ENGINE.path.map(shift); rebuildDerivedPathState(ENGINE); l.hints = []; ENGINE.hinter.pathList = []; }
    
    function changeGridSize(delta) { if (ENGINE.overlayState !== OVERLAY_NONE || !ENGINE.editor.workingLevel) return; const l = ENGINE.editor.workingLevel; const newSize = l.grid.w + delta; if (newSize < 6 || newSize > 15) { showMessage("Size limit reached", "text-amber-500 font-bold"); return; } const bounds = getLevelBounds(l); let shiftX = 0, shiftY = 0; if (bounds) { const width = bounds.maxX - bounds.minX + 1; const height = bounds.maxY - bounds.minY + 1; if (newSize < width || newSize < height) { showMessage("Cannot shrink: items blocking", "text-red-500 font-bold"); return; } if (bounds.maxX >= newSize) shiftX = newSize - 1 - bounds.maxX; if (bounds.maxY >= newSize) shiftY = newSize - 1 - bounds.maxY; } saveEditorState(); if (shiftX !== 0 || shiftY !== 0) { shiftLevel(l, shiftX, shiftY); ENGINE.editor.validTrapSpots.clear(); } l.grid.w = newSize; l.grid.h = newSize; const pathOutOfBounds = ENGINE.path.some(k => { const p = UNPACK(k); return p.x < 0 || p.y < 0 || p.x >= newSize || p.y >= newSize; }); if (pathOutOfBounds) PathNavigator.clear(ENGINE); ENGINE.editor.isModified = true; updateViewport(); showMessage(`Grid: ${newSize}x${newSize}`, "text-sky-600 font-bold"); }
    
    function transformLevel(l, coordMap, newW, newH, axisMap) { saveEditorState(); const mapKey = (k) => { if (k === -1) return -1; const p = UNPACK(k); const tp = coordMap(p.x, p.y); return PACK(tp.x, tp.y); }; l.goalKey = mapKey(l.goalKey); l.gateKeys = l.gateKeys.map(mapKey); l.falseGoalKeys = new Set(Array.from(l.falseGoalKeys).map(mapKey)); l.blockSet = new Set(Array.from(l.blockSet).map(mapKey)); l.gooseSet = new Set(Array.from(l.gooseSet).map(mapKey)); l.mustPassKeys = l.mustPassKeys.map(mapKey); l.mustCrossKeys = l.mustCrossKeys.map(mapKey); const newFilterMap = new Map(); l.filterMap.forEach((v, k) => newFilterMap.set(mapKey(k), axisMap(v))); l.filterMap = newFilterMap; const newFlipMap = new Map(); l.flippingFilterMap.forEach((v, k) => newFlipMap.set(mapKey(k), axisMap(v))); l.flippingFilterMap = newFlipMap; const newPortalMap = new Map(); l.portalMap.forEach((v, k) => { newPortalMap.set(mapKey(k), { dest: v.dest === -1 ? -1 : mapKey(v.dest), color: v.color }); }); l.portalMap = newPortalMap; l.portalVisuals = l.portalVisuals.map(pv => ({ k1: mapKey(pv.k1), k2: mapKey(pv.k2), color: pv.color })); if (ENGINE.editor.pendingPortal) { ENGINE.editor.pendingPortal = mapKey(ENGINE.editor.pendingPortal); } ENGINE.path = ENGINE.path.map(mapKey); if(ENGINE.activeGateKey) ENGINE.activeGateKey = mapKey(ENGINE.activeGateKey); rebuildDerivedPathState(ENGINE); l.grid.w = newW; l.grid.h = newH; l.hints = []; ENGINE.hinter.pathList = []; ENGINE.editor.validTrapSpots.clear(); ENGINE.editor.isModified = true; updateViewport(); }
    
    const PathNavigator = {
        pushStep(state, key, isJump) {
            const l = state.mode === PLAY ? state.level : state.editor.workingLevel; const lastK = state.path[state.path.length - 1];
            if (lastK !== undefined && !isJump) { const p1 = UNPACK(lastK), p2 = UNPACK(key); const axis = (p2.y === p1.y) ? H : V; const mark = (k, ax) => { let u = state.cellUsage.get(k) || { h: false, v: false }; if (ax === H) u.h = true; else u.v = true; state.cellUsage.set(k, u); }; mark(lastK, axis); mark(key, axis); }
            const count = state.visitedCounts.get(key) || 0; if (count > 0 && key !== state.activeGateKey && (l && key !== l.goalKey)) { state.intersections++; } state.visitedCounts.set(key, count + 1); state.path.push(key); if (isJump) state.isPortalJump.add(state.path.length - 1);
            if (l && l.flippingFilterMap.has(key) && !state.crossedFlippingFilters.has(key)) { state.crossedFlippingFilters.set(key, state.flipCount); state.flipCount++; state.lastFlipTime = Date.now(); }
            assertStateConsistency(state);
        },
        truncateTo(state, targetIdx) {
            if (targetIdx < -1 || targetIdx >= state.path.length - 1) return; state.path.splice(targetIdx + 1); const newJumps = new Set(); for (const j of state.isPortalJump) if (j <= targetIdx) newJumps.add(j); state.isPortalJump = newJumps;
            if (state.path.length === 0) { state.activeGateKey = null; if ([DRAGGING, PORTAL_PAUSE].includes(state.logicState)) { setLogicState(IDLE); } } if (state.mode === EDITOR) state.editor.isModified = true; rebuildDerivedPathState(state); assertStateConsistency(state);
        },
        clear(state) { state.path = []; state.isPortalJump.clear(); state.activeGateKey = null; if ([DRAGGING, PORTAL_PAUSE, HAZARD_TRIGGERED].includes(state.logicState)) { setLogicState(IDLE); } if (state.mode === EDITOR) state.editor.isModified = true; rebuildDerivedPathState(state); assertStateConsistency(state); }
    };
    
    const cvs = $('gameCanvas'); const ctx = cvs.getContext('2d'); const msgEl = $('message'); const outEl = $('solutionOutput'); const winOutEl = $('winSolutionOutput'); const ghostEl = $('dragGhost');
    
    function transformPoint(x, y, variant, W, H) { switch (variant) { case 0: return { tx: x, ty: y }; case 1: return { tx: H - 1 - y, ty: x }; case 2: return { tx: W - 1 - x, ty: H - 1 - y }; case 3: return { tx: y, ty: W - 1 - x }; case 4: return { tx: W - 1 - x, ty: y }; case 5: return { tx: x, ty: H - 1 - y }; case 6: return { tx: y, ty: x }; case 7: return { tx: H - 1 - y, ty: W - 1 - x }; default: return { tx: x, ty: y }; } }
    function inverseTransformPoint(tx, ty, variant, W, H) { switch (variant) { case 0: return { x: tx, y: ty }; case 1: return { x: ty, y: H - 1 - tx }; case 2: return { x: W - 1 - tx, y: H - 1 - ty }; case 3: return { x: W - 1 - ty, y: tx }; case 4: return { x: W - 1 - tx, y: ty }; case 5: return { x: tx, y: H - 1 - ty }; case 6: return { x: ty, y:tx }; case 7: return { x: W - 1 - ty, y: H - 1 - tx }; default: return { x: tx, y: ty }; } }
    function transformAxis(axis, variant) { const swaps = [1, 3, 6, 7]; if (swaps.includes(variant)) { if (axis === H) return V; if (axis === V) return H; } return axis; }
    function getGridCoord(e) { const rect = cvs.getBoundingClientRect(); const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; if (!l) return {x:0, y:0}; const gridW = ENGINE.viewport.swapped ? l.grid.h : l.grid.w, gridH = ENGINE.viewport.swapped ? l.grid.w : l.grid.h; const tx = Math.max(0, Math.min(gridW - 1, Math.floor((e.clientX - rect.left) * (cvs.width / rect.width) / ENGINE.viewport.cellW))); const ty = Math.max(0, Math.min(gridH - 1, Math.floor((e.clientY - rect.top) * (cvs.height / rect.height) / ENGINE.viewport.cellH))); return inverseTransformPoint(tx, ty, ENGINE.variant, l.grid.w, l.grid.h); }
    
    function triggerJumpScare() { 
        $('gooseJumpScare').classList.remove('hidden'); 
        $('gooseJumpScare').classList.add('flex'); 
        setOverlayState(GOOSE_OVERLAY);
        setTimeout(() => { 
            $('gooseJumpScare').classList.add('hidden'); 
            $('gooseJumpScare').classList.remove('flex'); 
            setOverlayState(OVERLAY_NONE);
        }, 2500); 
    }
    
    function triggerBombDetonation(key) { 
        ENGINE.armedFalseGoals.delete(key);
        ENGINE.detonatedFalseGoals.add(key);
        setOverlayState(FALSE_GOAL_ANIMATING);
        const overlay = $('bombJumpScare'); overlay.classList.remove('hidden'); overlay.classList.add('flex'); SOUND_BUS.play("C2", "8n"); 
        setTimeout(() => { 
            overlay.querySelector('#scaryBomb').innerHTML = `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="#ef4444" stroke-width="10" stroke-dasharray="10 5" class="animate-ping"/><path d="M 50 10 L 50 90 M 10 50 L 90 50 M 20 20 L 80 80 M 20 80 L 80 20" stroke="#f97316" stroke-width="8"/></svg>`; 
            SOUND_BUS.play("F1", "4n"); 
            setTimeout(() => { 
                overlay.classList.add('hidden'); overlay.classList.remove('flex'); overlay.querySelector('#scaryBomb').innerHTML = `<svg viewBox="0 0 100 100"><use href="#def-falsegoal"/></svg>`; 
                setOverlayState(OVERLAY_NONE);
            }, 1000); 
        }, 1000); 
    }
    
    function deepCloneLevel(src) { const l = JSON.parse(JSON.stringify(src)); l.blockSet = new Set(src.blockSet); l.gooseSet = new Set(src.gooseSet); l.falseGoalKeys = new Set(src.falseGoalKeys); l.portalMap = new Map(); if(src.portalMap) src.portalMap.forEach((v, k) => l.portalMap.set(k, v)); l.filterMap = new Map(); if(src.filterMap) src.filterMap.forEach((v, k) => l.filterMap.set(k, v)); l.flippingFilterMap = new Map(); if(src.flippingFilterMap) src.flippingFilterMap.forEach((v, k) => l.flippingFilterMap.set(k, v)); return l; }
    // ======================================================
    // C) Level / NormalizeAndCaches
    // ======================================================
    function normalizeLevel(idx) { const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; if (idx < 0 || idx >= levels.length) return null; const raw = levels[idx]; if (!raw) return null; const adj = (v) => v - 1; const l = { id: idx, grid: { ...raw.grid }, reqLen: raw.reqLen, reqInt: raw.reqInt, goalKey: PACK(adj(raw.goal.x), adj(raw.goal.y)), gateKeys: raw.gates.map(g => PACK(adj(g.x), adj(g.y))), blockSet: new Set(), gooseSet: new Set(), falseGoalKeys: new Set(), portalMap: new Map(), portalVisuals: [], filterMap: new Map(), flippingFilterMap: new Map(), mustPassKeys: raw.mustPass?.map(m => PACK(adj(m.x), adj(m.y))) || [], mustCrossKeys: raw.mustCross?.map(m => PACK(adj(m.x), adj(m.y))) || [], hints: raw.hints || [] }; (raw.blocks || raw.walls)?.forEach(w => l.blockSet.add(PACK(adj(w.x), adj(w.y)))); raw.geese?.forEach(m => l.gooseSet.add(PACK(adj(m.x), adj(m.y)))); raw.filters?.forEach(f => l.filterMap.set(PACK(adj(f.x), adj(f.y)), f.axis)); raw.flippingFilters?.forEach(f => l.flippingFilterMap.set(PACK(adj(f.x), adj(f.y)), f.axis)); raw.falseGoals?.forEach(g => l.falseGoalKeys.add(PACK(adj(g.x), adj(g.y)))); raw.portals?.forEach(p => { const k1 = PACK(adj(p.x1), adj(p.y1)), k2 = PACK(adj(p.x2), adj(p.y2)); l.portalMap.set(k1, { dest: k2, color: p.color || '#d946ef' }); l.portalMap.set(k2, { dest: k1, color: p.color || '#d946ef' }); l.portalVisuals.push({ k1, k2, color: p.color || '#d946ef' }); }); return l; }
    
    function createSnapshot() { return { path: [...ENGINE.path], isPortalJump: new Set(ENGINE.isPortalJump), activeGateKey: ENGINE.activeGateKey, logicState: ENGINE.logicState, detonatedFalseGoals: new Set(ENGINE.detonatedFalseGoals) }; }
    function applySnapshot(snap) { ENGINE.path = [...snap.path]; ENGINE.isPortalJump = new Set(snap.isPortalJump); ENGINE.activeGateKey = snap.activeGateKey; setLogicState(snap.logicState); ENGINE.detonatedFalseGoals = new Set(snap.detonatedFalseGoals); const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; const armed = new Set(l?.falseGoalKeys || []); ENGINE.detonatedFalseGoals.forEach(k => armed.delete(k)); ENGINE.armedFalseGoals = armed; rebuildDerivedPathState(ENGINE); showMessage("", ""); }
    
    function isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, ctx = {}) {
        const { x, y } = UNPACK(key);
        const { w, h } = l.grid;
        if (!inBounds(x, y, w, h) || l.blockSet.has(key)) return false;
        if (ctx.mode === EDITOR && l.gooseSet.has(key)) return false;
        const lastK = path[path.length - 1];
        if (lastK === undefined) return true;
        if (ctx.mode !== EDITOR) {
            if (lastK === l.goalKey) return false;
            if (ctx.armedFalseGoals?.has(lastK)) return false;
            if (l.gateKeys.includes(key)) return false;
        } else if (path.length > 1 && l.gateKeys.includes(lastK)) return false;
        if (l.portalMap.has(lastK) && !jumpSet.has(path.length - 1)) return false;
        const lastP = UNPACK(lastK);
        const isPortalJumpCandidate = l.portalMap.has(lastK) && resolvePortal(l, lastK).dest === key;
        if (!isPortalJumpCandidate && Math.abs(x - lastP.x) + Math.abs(y - lastP.y) !== 1) return false;
        const axis = (y === lastP.y) ? H : V;
        const u = usage.get(key);
        if (u && ((axis === H && u.h) || (axis === V && u.v))) return false;
        const uLast = usage.get(lastK);
        if (uLast) {
            let entryAxis = NONE;
            if (path.length > 1 && !jumpSet.has(path.length - 1)) {
                const prevP = UNPACK(path[path.length - 2]);
                const lastP_check = UNPACK(lastK);
                entryAxis = (prevP.y === lastP_check.y) ? H : V;
            }
            if (axis !== entryAxis) {
                if ((axis === H && uLast.h) || (axis === V && uLast.v)) return false;
            }
        }
        const flipCount = ctx.flipCount || 0;
        const crossedSet = ctx.crossedSet || ctx.crossedFlippingFilters || new Map();
        let filterLast = l.filterMap.get(lastK);
        if (filterLast === undefined && l.flippingFilterMap.has(lastK)) {
            const relevantFlipCount = crossedSet.has(lastK) ? crossedSet.get(lastK) : flipCount;
            filterLast = (relevantFlipCount % 2 !== 0) ? (l.flippingFilterMap.get(lastK) === H ? V : H) : l.flippingFilterMap.get(lastK);
        }
        if (filterLast && filterLast !== axis) return false;
        let filterTarget = l.filterMap.get(key);
        if (filterTarget === undefined && l.flippingFilterMap.has(key)) {
            const relevantFlipCount = crossedSet.has(key) ? crossedSet.get(key) : flipCount;
            const baseAxis = l.flippingFilterMap.get(key);
            filterTarget = (relevantFlipCount % 2 !== 0) ? (baseAxis === H ? V : H) : baseAxis;
        }
        if (filterTarget && filterTarget !== axis) return false;
        return true;
    }

    const SolverCore = {
        _isMoveValid(key, path, counts, usage, ints, jumpSet, l, flipCount, crossedSet, options = {}) {
            return isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, {
                mode: PLAY,
                flipCount,
                crossedSet,
                hazardPolicy: options.hazardPolicy || 'forbid'
            });
        },
        _buildDistMap(l) {
            const { w, h } = l.grid;
            const map = new Map();
            const q = [{ k: l.goalKey, d: 0 }];
            map.set(l.goalKey, 0);
            let head = 0;
            while (head < q.length) {
                const { k, d } = q[head++];
                const p = UNPACK(k);
                const neighbors = [];
                const portal = resolvePortal(l, k);
                if (portal) neighbors.push(portal.dest);
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const nx = p.x + dx, ny = p.y + dy;
                    if (inBounds(nx, ny, w, h)) {
                        const nk = PACK(nx, ny);
                        if (!l.blockSet.has(nk)) neighbors.push(nk);
                    }
                });
                for (const nk of neighbors) {
                    if (!map.has(nk)) {
                        map.set(nk, d + 1);
                        q.push({ k: nk, d: d + 1 });
                    }
                }
            }
            return map;
        },
        _buildFlipperDistMap(l, flipperSet) {
            const { w, h } = l.grid;
            const map = new Map();
            const q = [];
            flipperSet.forEach(k => {
                map.set(k, 0);
                q.push({ k: k, d: 0 });
            });
            let head = 0;
            while (head < q.length) {
                const { k, d } = q[head++];
                const p = UNPACK(k);
                const neighbors = [];
                const portal = resolvePortal(l, k);
                if (portal) neighbors.push(portal.dest);
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const nx = p.x + dx, ny = p.y + dy;
                    if (inBounds(nx, ny, w, h)) {
                        const nk = PACK(nx, ny);
                        if (!l.blockSet.has(nk)) neighbors.push(nk);
                    }
                });
                for (const nk of neighbors) {
                    if (!map.has(nk)) {
                        map.set(nk, d + 1);
                        q.push({ k: nk, d: d + 1 });
                    }
                }
            }
            return map;
        },
        _estimateMustPassBoundFrom(key, state, l) {
            const mask = state.mustMask;
            if (mask === 0n) return l.distMapForSolver.get(key) ?? Infinity;
            if (l.mustPassDpMode === 'exact') {
                const memoKey = `${key}|${mask.toString()}`;
                const cached = l.mustPassKeyMaskCache.get(memoKey);
                if (cached !== undefined) return cached;
                let best = Infinity;
                for (let i = 0; i < l.mustPassKeys.length; i++) {
                    const bit = 1n << BigInt(i);
                    if ((mask & bit) === 0n) continue;
                    const dToMust = l.mustPassDistMaps[i].get(key);
                    if (dToMust === undefined) continue;
                    const rest = l.mustPassDp(mask ^ bit, i);
                    if (rest === Infinity) continue;
                    const total = dToMust + rest;
                    if (total < best) best = total;
                }
                l.mustPassKeyMaskCache.set(memoKey, best);
                return best;
            }
            let nearest = Infinity;
            const nodes = [];
            for (let i = 0; i < l.mustPassKeys.length; i++) {
                const bit = 1n << BigInt(i);
                if ((mask & bit) === 0n) continue;
                nodes.push(i);
                const d = l.mustPassDistMaps[i].get(key);
                if (d !== undefined && d < nearest) nearest = d;
            }
            if (nearest === Infinity) return Infinity;
            if (nodes.length === 0) return l.distMapForSolver.get(key) ?? Infinity;
            const nodeCount = nodes.length + 1;
            const visited = new Array(nodeCount).fill(false);
            const minEdge = new Array(nodeCount).fill(Infinity);
            minEdge[0] = 0;
            const edges = (a, b) => {
                if (a === b) return 0;
                if (a === 0) return l.mustPassToGoalDist[nodes[b - 1]];
                if (b === 0) return l.mustPassToGoalDist[nodes[a - 1]];
                return l.mustPassPairDist[nodes[a - 1]][nodes[b - 1]];
            };
            let mst = 0;
            for (let i = 0; i < nodeCount; i++) {
                let v = -1;
                for (let j = 0; j < nodeCount; j++) {
                    if (!visited[j] && (v === -1 || minEdge[j] < minEdge[v])) v = j;
                }
                if (v === -1 || minEdge[v] === Infinity) return Infinity;
                visited[v] = true;
                mst += minEdge[v];
                for (let to = 0; to < nodeCount; to++) {
                    if (visited[to]) continue;
                    const w = edges(v, to);
                    if (w < minEdge[to]) minEdge[to] = w;
                }
            }
            return nearest + mst;
        },
        _encodeMustCrossCounts(state) {
            if (!state.mustCrossCounts || state.mustCrossCounts.length === 0) return 0n;
            let code = 0n;
            for (let i = 0; i < state.mustCrossCounts.length; i++) {
                code = code * 3n + BigInt(state.mustCrossCounts[i]);
            }
            return code;
        },
        _portalForced(state, l) {
            const k = state.path[state.path.length - 1];
            return l.portalMap.has(k) && !state.isJump.has(state.path.length - 1);
        },
        _encodeUsage(state) {
            if (!state.usage || state.usage.size === 0) return '';
            const entries = [];
            state.usage.forEach((u, k) => {
                const bits = (u.h ? 1 : 0) | (u.v ? 2 : 0);
                if (bits) entries.push(`${k}:${bits}`);
            });
            entries.sort();
            return entries.join(',');
        },
        _encodeCounts(state, l) {
            if (!state.counts || state.counts.size === 0) return '';
            const entries = [];
            state.counts.forEach((c, k) => {
                if (c <= 1) return;
                if (k === l.goalKey || l.gateKeys.includes(k)) return;
                entries.push(`${k}:${c}`);
            });
            entries.sort();
            return entries.join(',');
        },
        _stateSignature(state, l, realLen) {
            const posKey = state.path[state.path.length - 1];
            const portalForced = this._portalForced(state, l) ? 1 : 0;
            const crossCounts = this._encodeMustCrossCounts(state).toString();
            const usageSig = this._encodeUsage(state);
            const countsSig = this._encodeCounts(state, l);
            return [
                posKey,
                realLen,
                state.ints,
                state.mustMask.toString(),
                state.mustCrossMask ? state.mustCrossMask.toString() : '0',
                crossCounts,
                portalForced,
                state.flipParity,
                state.flipperCrossMask ? state.flipperCrossMask.toString() : '0',
                state.flipperParityAtCrossMask ? state.flipperParityAtCrossMask.toString() : '0',
                usageSig,
                countsSig
            ].join('|');
        },
        _crossNeeds(state) {
            if (!state.mustCrossCounts) return 0;
            let needs = 0;
            for (let i = 0; i < state.mustCrossCounts.length; i++) needs += (2 - state.mustCrossCounts[i]);
            return needs;
        },
        _nearestOutstandingMustCrossDist(key, state, l) {
            if (!state.mustCrossMask || state.mustCrossMask === 0n) return Infinity;
            let best = Infinity;
            for (let i = 0; i < l.mustCrossKeys.length; i++) {
                const bit = 1n << BigInt(i);
                if ((state.mustCrossMask & bit) === 0n) continue;
                const d = l.mustCrossDistMaps[i].get(key);
                if (d !== undefined && d < best) best = d;
            }
            return best;
        },
        _hazardDecisionForKey(key, state, l, options = {}) {
            if (!l.gooseSet.has(key)) return { allowed: true, terminal: false };
            const policy = options.hazardPolicy || 'forbid';
            if (policy === 'allow_dead_end') return { allowed: true, terminal: true };
            return { allowed: false, terminal: true };
        },
        _getNeighbors(k, state, distMap, flipperDistMap, usageFreq, l, options, scratch) {
            const { w, h } = l.grid;
            const p = UNPACK(k);
            const candidates = [];
            const portal = resolvePortal(l, k);
            const portalForced = portal && !state.isJump.has(state.path.length - 1);
            const portalDest = portal ? portal.dest : -1;
            if (portalForced && portalDest !== -1) {
                candidates.push(portalDest);
            } else {
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const nx = p.x + dx, ny = p.y + dy;
                    if (inBounds(nx, ny, w, h)) candidates.push(PACK(nx, ny));
                });
            }
            const pEnd = UNPACK(l.goalKey);
            const cEnd = (pEnd.x + pEnd.y) % 2;
            const curLen = state.path.length - 1 - state.isJump.size;
            const hasMust = state.mustMask !== 0n;
            const crossNeed = this._crossNeeds(state);
            const mustBoundCache = scratch.mustBoundCache;
            const crossDistCache = scratch.crossDistCache;
            const mustCachePrefix = `${state.mustMask.toString()}|`;
            const crossCachePrefix = `${state.mustCrossMask?.toString() || '0'}|${crossNeed}|`;
            const getMustBound = (key) => {
                if (!hasMust) return 0;
                const cKey = mustCachePrefix + key;
                if (mustBoundCache.has(cKey)) return mustBoundCache.get(cKey);
                const bound = this._estimateMustPassBoundFrom(key, state, l);
                mustBoundCache.set(cKey, bound);
                return bound;
            };
            const getCrossBound = (key) => {
                if (crossNeed <= 0) return 0;
                const cKey = crossCachePrefix + key;
                if (crossDistCache.has(cKey)) return crossDistCache.get(cKey);
                const dNearest = this._nearestOutstandingMustCrossDist(key, state, l);
                const b = dNearest === Infinity ? Infinity : dNearest + Math.max(0, crossNeed - 1);
                crossDistCache.set(cKey, b);
                return b;
            };
            const valid = candidates.filter(nk => {
                if (!this._isMoveValid(nk, state.path, state.counts, state.usage, state.ints, state.isJump, l, state.flipCount, state.crossedFlippers, options)) return false;
                if (!this._hazardDecisionForKey(nk, state, l, options).allowed) return false;
                const isP = (portalDest === nk && portalForced);
                const nLen = curLen + (isP ? 0 : 1);
                const rSteps = l.reqLen - nLen;
                const pN = UNPACK(nk);
                const cN = (pN.x + pN.y) % 2;
                if (((Math.abs(cN - cEnd)) % 2) !== (rSteps % 2)) {
                    const dF = flipperDistMap.get(nk);
                    if (dF === undefined || dF > rSteps) return false;
                }
                const d = distMap.get(nk);
                if (d === undefined || d > rSteps) return false;
                if (hasMust) {
                    const bestBound = getMustBound(nk);
                    if (bestBound === Infinity || bestBound > rSteps) return false;
                }
                if (crossNeed > 0) {
                    const crossBound = getCrossBound(nk);
                    if (crossBound === Infinity || crossBound > rSteps) return false;
                }
                return true;
            });
            valid.sort((a, b) => {
                const fA = usageFreq.get(a) || 0;
                const fB = usageFreq.get(b) || 0;
                if (fA !== fB) return fA - fB;
                if (hasMust) {
                    const mA = getMustBound(a), mB = getMustBound(b);
                    if (mA !== mB) return mA - mB;
                }
                if (crossNeed > 0) {
                    const cA = getCrossBound(a), cB = getCrossBound(b);
                    if (cA !== cB) return cA - cB;
                }
                return (distMap.get(a) || 999) - (distMap.get(b) || 999);
            });
            return valid;
        },
        _pushState(s, k, isJump, l) {
            const log = [];
            const lastK = s.path[s.path.length - 1];
            if (!isJump) {
                const lP = UNPACK(lastK), cP = UNPACK(k);
                const axis = (cP.y === lP.y) ? H : V;
                const prop = axis === H ? 'h' : 'v';
                let uL = s.usage.get(lastK);
                if (!uL) {
                    uL = { h: false, v: false };
                    s.usage.set(lastK, uL);
                    log.push({ op: 'new_usage', key: lastK });
                }
                if (!uL[prop]) {
                    uL[prop] = true;
                    log.push({ op: 'set_prop', key: lastK, prop: prop });
                }
                let uC = s.usage.get(k);
                if (!uC) {
                    uC = { h: false, v: false };
                    s.usage.set(k, uC);
                    log.push({ op: 'new_usage', key: k });
                }
                if (!uC[prop]) {
                    uC[prop] = true;
                    log.push({ op: 'set_prop', key: k, prop: prop });
                }
            }
            const c = s.counts.get(k) || 0;
            if (c > 0 && k !== l.goalKey && !l.gateKeys.includes(k)) {
                s.ints++;
                log.push({ op: 'inc_int' });
            }
            if (c === 0) {
                s.counts.set(k, 1);
                log.push({ op: 'new_count', key: k });
            } else {
                s.counts.set(k, c + 1);
                log.push({ op: 'inc_count', key: k });
            }
            if (c === 0) {
                const mustIdx = l.mustPassIndex ? l.mustPassIndex.get(k) : undefined;
                if (mustIdx !== undefined && typeof s.mustMask === "bigint") {
                    const bit = 1n << BigInt(mustIdx);
                    if ((s.mustMask & bit) !== 0n) {
                        s.mustMask &= ~bit;
                        log.push({ op: 'mustmask', bit: bit });
                    }
                }
            }
            if (s.mustCrossCounts && typeof s.mustCrossMask === "bigint") {
                const crossIdx = l.mustCrossIndex ? l.mustCrossIndex.get(k) : undefined;
                if (crossIdx !== undefined) {
                    const prev = s.mustCrossCounts[crossIdx];
                    if (prev < 2) {
                        s.mustCrossCounts[crossIdx] = prev + 1;
                        log.push({ op: 'mustcross_inc', idx: crossIdx, prev });
                        if (prev + 1 >= 2) {
                            const bit = 1n << BigInt(crossIdx);
                            if ((s.mustCrossMask & bit) !== 0n) {
                                s.mustCrossMask &= ~bit;
                                log.push({ op: 'mustcross_mask_clear', bit });
                            }
                        }
                    }
                }
            }
            s.path.push(k);
            if (isJump) s.isJump.add(s.path.length - 1);
            if (l.flippingFilterMap.has(k) && !s.crossedFlippers.has(k)) {
                s.crossedFlippers.set(k, s.flipCount);
                const flipIdx = l.flipperIndex ? l.flipperIndex.get(k) : undefined;
                if (flipIdx !== undefined && typeof s.flipperCrossMask === "bigint" && typeof s.flipParity === "number") {
                    const bit = 1n << BigInt(flipIdx);
                    s.flipperCrossMask |= bit;
                    if (typeof s.flipperParityAtCrossMask === "bigint" && (s.flipParity & 1) === 1) s.flipperParityAtCrossMask |= bit;
                    log.push({ op: 'flipper_mask_set', bit, hadParity: (s.flipParity & 1) === 1 });
                }
                s.flipCount++;
                if (typeof s.flipParity === "number") s.flipParity = s.flipCount % 2;
                log.push({ op: 'flip_add', key: k });
            }
            return log;
        },
        _popState(s, log) {
            const k = s.path.pop();
            const idx = s.path.length;
            if (s.isJump.has(idx)) s.isJump.delete(idx);
            for (let i = log.length - 1; i >= 0; i--) {
                const entry = log[i];
                if (entry.op === 'inc_int') {
                    s.ints--;
                } else if (entry.op === 'new_count') {
                    s.counts.delete(entry.key);
                } else if (entry.op === 'inc_count') {
                    s.counts.set(entry.key, s.counts.get(entry.key) - 1);
                } else if (entry.op === 'set_prop') {
                    const u = s.usage.get(entry.key);
                    if (u) u[entry.prop] = false;
                } else if (entry.op === 'new_usage') {
                    s.usage.delete(entry.key);
                } else if (entry.op === 'flip_add') {
                    s.crossedFlippers.delete(entry.key);
                    s.flipCount--;
                    s.flipParity = s.flipCount % 2;
                } else if (entry.op === 'mustmask') {
                    s.mustMask |= entry.bit;
                } else if (entry.op === 'mustcross_inc') {
                    s.mustCrossCounts[entry.idx] = entry.prev;
                } else if (entry.op === 'mustcross_mask_clear') {
                    s.mustCrossMask |= entry.bit;
                } else if (entry.op === 'flipper_mask_set') {
                    s.flipperCrossMask &= ~entry.bit;
                    if (entry.hadParity) s.flipperParityAtCrossMask &= ~entry.bit;
                }
            }
        },
        _checkFinalConstraints(state, l) {
            for (const k of l.mustPassKeys) if (!state.counts.has(k)) return false;
            for (const k of l.mustCrossKeys) if ((state.counts.get(k) || 0) < 2) return false;
            for (const k of l.gooseSet) if (state.counts.has(k)) return false;
            return true;
        },
        async _solveInstance(startKey, distMap, flipperDistMap, usageFreq, l, options) {
            const mustCount = l.mustPassKeys.length;
            const mustCrossCount = l.mustCrossKeys.length;
            options = options || {};
            options.hazardPolicy = options.hazardPolicy || 'forbid';
            const state = {
                path: [startKey],
                counts: new Map(),
                usage: new Map(),
                ints: 0,
                isJump: new Set(),
                flipCount: 0,
                flipParity: 0,
                crossedFlippers: new Map(),
                flipperCrossMask: 0n,
                flipperParityAtCrossMask: 0n,
                mustMask: mustCount > 0 ? ((1n << BigInt(mustCount)) - 1n) : 0n,
                mustCrossMask: mustCrossCount > 0 ? ((1n << BigInt(mustCrossCount)) - 1n) : 0n,
                mustCrossCounts: mustCrossCount > 0 ? new Uint8Array(mustCrossCount) : null
            };
            const scratch = { mustBoundCache: new Map(), crossDistCache: new Map() };
            state.counts.set(startKey, 1);
            const startMustIdx = l.mustPassIndex ? l.mustPassIndex.get(startKey) : undefined;
            if (startMustIdx !== undefined) state.mustMask &= ~(1n << BigInt(startMustIdx));
            const startCrossIdx = l.mustCrossIndex ? l.mustCrossIndex.get(startKey) : undefined;
            if (startCrossIdx !== undefined && state.mustCrossCounts) {
                state.mustCrossCounts[startCrossIdx] = 1;
            }
            if (l.flippingFilterMap.has(startKey)) {
                state.crossedFlippers.set(startKey, state.flipCount);
                const flipIdx = l.flipperIndex ? l.flipperIndex.get(startKey) : undefined;
                if (flipIdx !== undefined) state.flipperCrossMask |= (1n << BigInt(flipIdx));
                state.flipCount++;
                state.flipParity = state.flipCount % 2;
            }
            const failedStates = new Set();
            const startNeighbors = this._getNeighbors(startKey, state, distMap, flipperDistMap, usageFreq, l, options, scratch);
            const stack = [{ k: startKey, neighbors: startNeighbors, log: [], sig: this._stateSignature(state, l, 0) }];
            let steps = 0;
            while (stack.length > 0) {
                if (options.signal?.aborted) throw new DOMException("Aborted", "AbortError");
                if (Date.now() - options.startTime > options.timeLimit) return SOLVER_TIMEOUT;
                if (++steps % 500 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                    options.onProgress(Date.now() - options.startTime);
                }
                const top = stack[stack.length - 1];
                if (top.neighbors.length === 0) {
                    failedStates.add(top.sig);
                    this._popState(state, top.log);
                    stack.pop();
                    continue;
                }
                const nextKey = top.neighbors.pop();
                const topPortal = resolvePortal(l, top.k);
                const isP = topPortal && !state.isJump.has(state.path.length - 1) ? topPortal.dest === nextKey : false;
                const transLog = this._pushState(state, nextKey, isP, l);
                const lastK = state.path[state.path.length - 1];
                const hazard = this._hazardDecisionForKey(nextKey, state, l, options);
                if (!hazard.allowed) {
                    this._popState(state, transLog);
                    continue;
                }
                const realLen = state.path.length - 1 - state.isJump.size;
                if (realLen > l.reqLen) {
                    this._popState(state, transLog);
                    continue;
                }
                if (state.ints > l.reqInt) {
                    this._popState(state, transLog);
                    continue;
                }
                const rSteps = l.reqLen - realLen;
                if ((l.reqInt - state.ints) > rSteps) {
                    this._popState(state, transLog);
                    continue;
                }
                const crossNeeds = this._crossNeeds(state);
                if (crossNeeds > rSteps) {
                    this._popState(state, transLog);
                    continue;
                }
                if (state.mustMask !== 0n) {
                    const mustBound = this._estimateMustPassBoundFrom(lastK, state, l);
                    if (mustBound === Infinity || mustBound > rSteps) {
                        this._popState(state, transLog);
                        continue;
                    }
                }
                if (state.mustCrossMask !== 0n) {
                    const crossDist = this._nearestOutstandingMustCrossDist(lastK, state, l);
                    if (crossDist === Infinity || (crossDist + Math.max(0, crossNeeds - 1)) > rSteps) {
                        this._popState(state, transLog);
                        continue;
                    }
                }
                if (lastK === l.goalKey) {
                    if (realLen === l.reqLen && state.ints === l.reqInt) {
                        if (this._checkFinalConstraints(state, l)) return { path: [...state.path], len: realLen };
                    }
                    this._popState(state, transLog);
                    continue;
                }
                const minRem = distMap.get(lastK) || Infinity;
                if (realLen + minRem > l.reqLen) {
                    this._popState(state, transLog);
                    continue;
                }
                const sig = this._stateSignature(state, l, realLen);
                if (failedStates.has(sig)) {
                    this._popState(state, transLog);
                    continue;
                }
                if (hazard.terminal) {
                    this._popState(state, transLog);
                    continue;
                }
                const neighbors = this._getNeighbors(nextKey, state, distMap, flipperDistMap, usageFreq, l, options, scratch);
                stack.push({ k: nextKey, neighbors, log: transLog, sig });
            }
            return null;
        },
        async _solveTrapSpots(startKey, l, validSpotsSet, options) {
            options = options || {};
            options.hazardPolicy = options.hazardPolicy || 'forbid';
            const { w, h } = l.grid;
            const state = { path: [startKey], counts: new Map(), usage: new Map(), ints: 0, isJump: new Set(), flipCount: 0, crossedFlippers: new Map() };
            state.counts.set(startKey, 1);
            if (l.flippingFilterMap.has(startKey)) {
                state.crossedFlippers.set(startKey, state.flipCount);
                state.flipCount++;
            }
            const getNeighbors = (k, s) => {
                const p = UNPACK(k);
                let candidates = [];
                const portal = resolvePortal(l, k);
                if (portal && !s.isJump.has(s.path.length - 1)) candidates.push(portal.dest);
                else [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const nx = p.x + dx, ny = p.y + dy;
                    if (inBounds(nx, ny, w, h)) candidates.push(PACK(nx, ny));
                });
                return candidates.filter(nk => this._isMoveValid(nk, s.path, s.counts, s.usage, s.ints, s.isJump, l, s.flipCount, s.crossedFlippers, options) && this._hazardDecisionForKey(nk, s, l, options).allowed);
            };
            const stack = [{ k: startKey, neighbors: getNeighbors(startKey, state), log: [] }];
            let steps = 0;
            while (stack.length > 0) {
                if (options.signal?.aborted) throw new DOMException("Aborted", "AbortError");
                if (Date.now() - options.startTime > options.timeLimit) return;
                if (++steps % 500 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                    options.onProgress(Date.now() - options.startTime);
                }
                const top = stack[stack.length - 1];
                if (top.neighbors.length === 0) {
                    this._popState(state, top.log);
                    stack.pop();
                    continue;
                }
                const nextKey = top.neighbors.pop();
                const topPortal = resolvePortal(l, top.k);
                const isP = topPortal && !state.isJump.has(state.path.length - 1) ? topPortal.dest === nextKey : false;
                const transLog = this._pushState(state, nextKey, isP, l);
                const hazard = this._hazardDecisionForKey(nextKey, state, l, options);
                if (!hazard.allowed) {
                    this._popState(state, transLog);
                    continue;
                }
                const realLen = state.path.length - 1 - state.isJump.size;
                if (realLen > l.reqLen) {
                    this._popState(state, transLog);
                    continue;
                }
                if (realLen === l.reqLen) {
                    if (state.ints === l.reqInt && this._checkFinalConstraints(state, l)) validSpotsSet.add(nextKey);
                    this._popState(state, transLog);
                    continue;
                }
                if (hazard.terminal) {
                    this._popState(state, transLog);
                    continue;
                }
                stack.push({ k: nextKey, neighbors: getNeighbors(nextKey, state), log: transLog });
            }
        }
    };


    const SOLVER_TIMEOUT = Symbol("solver-timeout");

    // ======================================================
    // H) Solver
    // ======================================================
    const PathfinderSolver = {
        async solve(level, options = {}) {
            const { timeLimit = 105000, maxSolutions = 5, onProgress = () => {}, onStateUpdate = () => {}, signal = null, hazardPolicy = 'forbid' } = options;
            const startTime = Date.now();
            const foundSolutions = [];
            foundSolutions.timedOut = false;
            if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
            onStateUpdate("Analyzing Bipartite Parity...");

            const distMap = SolverCore._buildDistMap(level);
            level.distMapForSolver = distMap;
            level.mustPassIndex = new Map();
            level.mustPassDistMaps = [];
            level.mustPassToGoalDist = [];
            level.mustPassPairDist = [];
            level.mustPassKeyMaskCache = new Map();
            level.mustPassDpMode = 'none';
            level.mustPassDp = () => Infinity;

            if (level.mustPassKeys.length > 0) {
                const { w, h } = level.grid;
                const buildMustPassDistMap = (targetKey) => {
                    const map = new Map();
                    const q = [{ k: targetKey, d: 0 }];
                    map.set(targetKey, 0);
                    let head = 0;
                    while (head < q.length) {
                        const { k, d } = q[head++];
                        const p = UNPACK(k);
                        const neighbors = [];
                        const portal = resolvePortal(level, k);
                        if (portal) neighbors.push(portal.dest);
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            const nx = p.x + dx, ny = p.y + dy;
                            if (inBounds(nx, ny, w, h)) {
                                const nk = PACK(nx, ny);
                                if (!level.blockSet.has(nk)) neighbors.push(nk);
                            }
                        });
                        for (const nk of neighbors) {
                            if (!map.has(nk)) {
                                map.set(nk, d + 1);
                                q.push({ k: nk, d: d + 1 });
                            }
                        }
                    }
                    return map;
                };
                for (let i = 0; i < level.mustPassKeys.length; i++) {
                    const mustKey = level.mustPassKeys[i];
                    level.mustPassIndex.set(mustKey, i);
                    level.mustPassDistMaps.push(buildMustPassDistMap(mustKey));
                    level.mustPassToGoalDist.push(distMap.get(mustKey) ?? Infinity);
                }
                const n = level.mustPassKeys.length;
                level.mustPassPairDist = Array.from({ length: n }, () => Array(n).fill(Infinity));
                for (let i = 0; i < n; i++) {
                    level.mustPassPairDist[i][i] = 0;
                    for (let j = i + 1; j < n; j++) {
                        const d = level.mustPassDistMaps[i].get(level.mustPassKeys[j]);
                        const val = d === undefined ? Infinity : d;
                        level.mustPassPairDist[i][j] = val;
                        level.mustPassPairDist[j][i] = val;
                    }
                }
                if (n <= 12) {
                    level.mustPassDpMode = 'exact';
                    const dpMemo = new Map();
                    level.mustPassDp = (mask, lastIdx) => {
                        if (mask === 0n) return level.mustPassToGoalDist[lastIdx];
                        const key = `${mask.toString()}|${lastIdx}`;
                        const cached = dpMemo.get(key);
                        if (cached !== undefined) return cached;
                        let best = Infinity;
                        for (let nxt = 0; nxt < n; nxt++) {
                            const bit = 1n << BigInt(nxt);
                            if ((mask & bit) === 0n) continue;
                            const d = level.mustPassPairDist[lastIdx][nxt];
                            if (d === Infinity) continue;
                            const rest = level.mustPassDp(mask ^ bit, nxt);
                            if (rest === Infinity) continue;
                            const total = d + rest;
                            if (total < best) best = total;
                        }
                        dpMemo.set(key, best);
                        return best;
                    };
                }
            }

            level.mustCrossIndex = new Map();
            level.mustCrossDistMaps = [];
            if (level.mustCrossKeys.length > 0) {
                for (let i = 0; i < level.mustCrossKeys.length; i++) {
                    const crossKey = level.mustCrossKeys[i];
                    level.mustCrossIndex.set(crossKey, i);
                    const map = new Map();
                    const q = [{ k: crossKey, d: 0 }];
                    map.set(crossKey, 0);
                    let head = 0;
                    while (head < q.length) {
                        const { k, d } = q[head++];
                        const p = UNPACK(k);
                        const neighbors = [];
                        const portal = resolvePortal(level, k);
                        if (portal) neighbors.push(portal.dest);
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            const nx = p.x + dx, ny = p.y + dy;
                            if (inBounds(nx, ny, level.grid.w, level.grid.h)) {
                                const nk = PACK(nx, ny);
                                if (!level.blockSet.has(nk)) neighbors.push(nk);
                            }
                        });
                        for (const nk of neighbors) {
                            if (!map.has(nk)) {
                                map.set(nk, d + 1);
                                q.push({ k: nk, d: d + 1 });
                            }
                        }
                    }
                    level.mustCrossDistMaps.push(map);
                }
            }

            level.flipperIndex = new Map();
            let fIdx = 0;
            level.flippingFilterMap.forEach((_, k) => level.flipperIndex.set(k, fIdx++));

            const flipperSet = new Set();
            level.portalMap.forEach((v, k) => {
                const p1 = UNPACK(k), p2 = UNPACK(v.dest);
                if (((p1.x + p1.y) % 2) !== ((p2.x + p2.y) % 2)) flipperSet.add(k);
            });
            const flipperDistMap = SolverCore._buildFlipperDistMap(level, flipperSet);

            const validGates = level.gateKeys.filter(gk => {
                const d = distMap.get(gk);
                if (d === undefined || d > level.reqLen) return false;
                const pStart = UNPACK(gk), pEnd = UNPACK(level.goalKey);
                const isMismatch = ((Math.abs((pStart.x + pStart.y) - (pEnd.x + pEnd.y))) % 2) !== (level.reqLen % 2);
                if (isMismatch) {
                    const dFlip = flipperDistMap.get(gk);
                    if (dFlip === undefined || dFlip > level.reqLen) return false;
                }
                return true;
            });
            if (validGates.length === 0) return [];

            onStateUpdate(`Solving (${validGates.length} viable gates)...`);
            let cellUsageFreq = new Map();
            if (level.hints && level.hints.length > 0) {
                level.hints.forEach(path => path.forEach(k => cellUsageFreq.set(k, (cellUsageFreq.get(k) || 0) + 1)));
            }
            validGates.sort(() => Math.random() - 0.5);
            for (const gateKey of validGates) {
                if (foundSolutions.length >= maxSolutions) break;
                await new Promise(r => setTimeout(r, 0));
                const internalOpts = { timeLimit, startTime, onProgress, signal, hazardPolicy };
                const result = await SolverCore._solveInstance(gateKey, distMap, flipperDistMap, cellUsageFreq, level, internalOpts);
                if (result === SOLVER_TIMEOUT) {
                    foundSolutions.timedOut = true;
                    break;
                }
                if (result) {
                    const solStr = JSON.stringify(result.path);
                    if (!foundSolutions.some(s => JSON.stringify(s.path) === solStr)) {
                        foundSolutions.push(result);
                        result.path.forEach(k => cellUsageFreq.set(k, (cellUsageFreq.get(k) || 0) + 1));
                    }
                }
            }
            return foundSolutions;
        },
        async findTrapSpots(level, options = {}) {
            const { timeLimit = 8000, onProgress = () => {}, onStateUpdate = () => {}, signal = null, hazardPolicy = 'forbid' } = options;
            const startTime = Date.now();
            const validSpots = new Set();
            if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
            onStateUpdate(`Mapping Traps (${level.gateKeys.length} gates)...`);
            for (const gateKey of level.gateKeys) {
                await new Promise(r => setTimeout(r, 0));
                const internalOpts = { timeLimit, startTime, onProgress, signal, hazardPolicy };
                await SolverCore._solveTrapSpots(gateKey, level, validSpots, internalOpts);
                if (Date.now() - startTime > timeLimit) break;
            }
            return validSpots;
        }
    };


    // ======================================================
    // D) Rules / ValidationAndWin
    // ======================================================
    function areWinMetricsSatisfied(state = ENGINE, level = (state.mode === PLAY ? state.level : state.editor.workingLevel)) { if (!level || !state.path.length) return false; const curLen = getRealLength(state); if (curLen !== level.reqLen || state.intersections !== level.reqInt) return false; const allMustPass = level.mustPassKeys.every(k => state.visitedCounts.get(k) > 0); const allMustCross = level.mustCrossKeys.every(k => (state.visitedCounts.get(k) || 0) >= 2); return allMustPass && allMustCross; }
    function checkWinConditionImpl(path, level, mode, logicState, isPortalJump, visitedCounts, intersections) { if (!path.length || [HAZARD_TRIGGERED].includes(logicState) || mode === EDITOR) return false; const last = path[path.length - 1]; if (last !== level.goalKey) return false; const stubState = { mode, level, editor: { workingLevel: level }, path, isPortalJump, visitedCounts, intersections }; return areWinMetricsSatisfied(stubState, level); }
    function checkFalseGoalCondition() {
        const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel;
        if (!l) return false;
        return getRealLength() === l.reqLen && ENGINE.intersections === l.reqInt;
    }
    function checkWinCondition() { if (checkWinConditionImpl(ENGINE.path, ENGINE.level, ENGINE.mode, ENGINE.logicState, ENGINE.isPortalJump, ENGINE.visitedCounts, ENGINE.intersections)) { setLogicState(RESOLVED); winOutEl.value = JSON.stringify(ENGINE.path).replace(/\s/g, ''); $('winExportArea').classList.toggle('hidden', !ENGINE.isDevMode); if (ENGINE.mode === PLAY) markLevelComplete(ENGINE.levelIdx); $('winModal').classList.remove('hidden'); SOUND_BUS.play("C5", "8n"); } }
    
    function isValidMoveEngine(key, path, counts, usage, ints, jumpSet, l) { return isValidMoveCommon(key, path, counts, usage, ints, jumpSet, l, { mode: ENGINE.mode, armedFalseGoals: ENGINE.armedFalseGoals, flipCount: ENGINE.flipCount, crossedSet: ENGINE.crossedFlippingFilters }); }
    
    function processStep(key) { const activeLevel = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; if ([HAZARD_TRIGGERED].includes(ENGINE.logicState) && ENGINE.mode !== EDITOR) return null; if (ENGINE.path.length > 1 && key === ENGINE.path[ENGINE.path.length - 2]) { PathNavigator.truncateTo(ENGINE, ENGINE.path.length - 2); SOUND_BUS.play("E4", "32n"); return "valid"; } if (isValidMoveEngine(key, ENGINE.path, ENGINE.visitedCounts, ENGINE.cellUsage, ENGINE.intersections, ENGINE.isPortalJump, activeLevel)) { if (ENGINE.mode === EDITOR) ENGINE.editor.isModified = true; if (ENGINE.mode !== EDITOR && activeLevel.gooseSet.has(key)) { ENGINE.revealedGeese.add(key); if (!ENGINE.gooseEncounteredThisLevel) { ENGINE.gooseEncounteredThisLevel = true; triggerJumpScare(); } setLogicState(HAZARD_TRIGGERED); SOUND_BUS.play("C2", "8n"); return "goose"; } ENGINE.undoStack.push(createSnapshot()); if(ENGINE.undoStack.length > 200) ENGINE.undoStack.shift(); PathNavigator.pushStep(ENGINE, key, false); if (ENGINE.armedFalseGoals.has(key) && checkFalseGoalCondition()) { triggerBombDetonation(key); return "detonate"; } const portal = resolvePortal(activeLevel, key); if (portal && portal.dest !== -1) { PathNavigator.pushStep(ENGINE, portal.dest, true); if (ENGINE.armedFalseGoals.has(portal.dest) && checkFalseGoalCondition()) { triggerBombDetonation(portal.dest); return "detonate"; } ENGINE.ripples.push({x: UNPACK(key).x, y: UNPACK(key).y, startTime: Date.now(), color: portal.color}); ENGINE.ripples.push({x: UNPACK(portal.dest).x, y: UNPACK(portal.dest).y, startTime: Date.now(), color: portal.color}); SOUND_BUS.play("A5", "16n"); setLogicState(PORTAL_PAUSE); checkWinCondition(); return "portal"; } SOUND_BUS.play("G4", "32n"); checkWinCondition(); return "valid"; } return null; }
    
    function attemptMoveTo(target) { if (ENGINE.mode === EDITOR && !ENGINE.editor.isPencilMode) return; if ([HAZARD_TRIGGERED].includes(ENGINE.logicState) && ENGINE.mode !== EDITOR) return; if (!ENGINE.path.length) return; const headPos = UNPACK(ENGINE.path[ENGINE.path.length - 1]); if (ENGINE.logicState === PORTAL_PAUSE) { if (target.x !== headPos.x || target.y !== headPos.y) setLogicState(DRAGGING); else return; } if (target.x === headPos.x && target.y === headPos.y) return; const dx = target.x - headPos.x; const dy = target.y - headPos.y; if (dx !== 0 && dy !== 0) return; const pathSteps = []; if (dx !== 0) { for (let i = 1; i <= Math.abs(dx); i++) pathSteps.push(PACK(headPos.x + Math.sign(dx) * i, headPos.y)); } else if (dy !== 0) { for (let i = 1; i <= Math.abs(dy); i++) pathSteps.push(PACK(headPos.x, headPos.y + Math.sign(dy) * i)); } for (const step of pathSteps) { const result = processStep(step); if (result === null || result === "goose" || result === "detonate") break; } }
    
    function updatePlayModeLayout() { if (ENGINE.mode !== PLAY) return; const megaBtn = $('megaSolverBtn'); const exportArea = $('exportArea'); if (ENGINE.isDevMode) { megaBtn.classList.remove('hidden'); exportArea.classList.remove('hidden'); $('devCopyBtn').classList.remove('hidden'); $('devGenBtn').classList.remove('hidden'); } else { megaBtn.classList.add('hidden'); exportArea.classList.add('hidden'); } }
    function isModalActive() { return !$('guideModal').classList.contains('hidden') || !$('editorHelpModal').classList.contains('hidden') || !$('winModal').classList.contains('hidden') || !$('megaModal').classList.contains('hidden') || !$('themeModal').classList.contains('hidden') || !$('unsavedModal').classList.contains('hidden'); }

    let gamepadGridPrimaryAction = () => {};

    function getFocusableGroups() {
        const groups = [
            { name: 'GRID', elements: [$('gameCanvas')] },
            { name: 'CONTROLS', elements: Array.from(document.querySelectorAll('#playControls button, #playControls [role="button"], #openThemeModalBtn, #muteBtn')).filter(el => !el.classList.contains('hidden') && el.offsetParent !== null) },
            { name: 'LEVEL', elements: [$('prevLevelBtn'), $('nextLevelBtn')].filter(Boolean) }
        ];
        if (ENGINE.mode === EDITOR) groups.push({ name: 'METRICS', elements: [$('editReqLen'), $('editReqInt')].filter(Boolean) });
        return groups.filter(g => g.elements.length > 0);
    }

    function applyFocusVisual(el) {
        document.querySelectorAll('.gamepad-focus').forEach(node => node.classList.remove('gamepad-focus', 'ring-4', 'ring-sky-400', 'ring-offset-2'));
        if (!ENGINE.ui.gamepadFocusEnabled || !el) return;
        el.classList.add('gamepad-focus', 'ring-4', 'ring-sky-400', 'ring-offset-2');
        if (typeof el.focus === 'function') el.focus({ preventScroll: true });
    }

    function setFocusGroup(groupName, index = 0, forceVisual = false) {
        const groups = getFocusableGroups();
        const gIdx = Math.max(0, groups.findIndex(g => g.name === groupName));
        const group = groups[gIdx] || groups[0];
        if (!group) return;
        ENGINE.ui.focusGroup = group.name;
        ENGINE.ui.focusIndex = Math.max(0, Math.min(index, group.elements.length - 1));
        if (forceVisual) ENGINE.ui.gamepadFocusEnabled = true;
        applyFocusVisual(group.elements[ENGINE.ui.focusIndex]);
    }

    function cycleFocusGroup() {
        const groups = getFocusableGroups();
        if (!groups.length) return;
        const idx = groups.findIndex(g => g.name === ENGINE.ui.focusGroup);
        const next = groups[(idx + 1 + groups.length) % groups.length];
        setFocusGroup(next.name, 0, true);
    }

    function moveFocusWithinGroup(delta) {
        const groups = getFocusableGroups();
        const group = groups.find(g => g.name === ENGINE.ui.focusGroup);
        if (!group || !group.elements.length) return;
        ENGINE.ui.focusIndex = (ENGINE.ui.focusIndex + delta + group.elements.length) % group.elements.length;
        applyFocusVisual(group.elements[ENGINE.ui.focusIndex]);
    }

    function activateFocusedControl() {
        const groups = getFocusableGroups();
        const group = groups.find(g => g.name === ENGINE.ui.focusGroup);
        const el = group?.elements?.[ENGINE.ui.focusIndex];
        if (!el) return;
        if (el.id === 'gameCanvas') {
            gamepadGridPrimaryAction();
            return;
        }
        el.click();
    }

    function dismissGuideOrHelpModal() {
        if (!$('guideModal').classList.contains('hidden')) { $('guideModal').classList.add('hidden'); return true; }
        if (!$('editorHelpModal').classList.contains('hidden')) { $('editorHelpModal').classList.add('hidden'); return true; }
        return false;
    }
    function switchMode(newMode) { const isEd = newMode === EDITOR; ENGINE.mode = newMode; setLogicState(IDLE); setOverlayState(OVERLAY_NONE); PathNavigator.clear(ENGINE); ENGINE.undoStack = []; ENGINE.revealedGeese.clear(); ENGINE.gooseEncounteredThisLevel = false; ENGINE.armedFalseGoals.clear(); ENGINE.detonatedFalseGoals.clear(); $('editorPalette').classList.toggle('hidden', !isEd); $('playMetrics').style.display = isEd ? 'none' : 'flex'; $('editorMetrics').style.display = isEd ? 'flex' : 'none'; $('gameButtonGrid').classList.toggle('hidden', isEd); $('editorButtonGrid').classList.toggle('hidden', !isEd); const exportArea = $('exportArea'); $('editCopyBtn').classList.toggle('hidden', !isEd); $('editGenBtn').classList.toggle('hidden', !isEd); $('devCopyBtn').classList.toggle('hidden', isEd || !ENGINE.isDevMode); $('devGenBtn').classList.toggle('hidden', isEd || !ENGINE.isDevMode); if (isEd) { ENGINE.variant = 0; ENGINE.editor.workingLevel = deepCloneLevel(ENGINE.level); ENGINE.editor.isPencilMode = false; ENGINE.editor.undoStack = []; ENGINE.editor.validTrapSpots.clear(); ENGINE.editor.emptyClickCount = 0; $('editReqLen').value = ENGINE.editor.workingLevel.reqLen || 0; $('editReqInt').value = ENGINE.editor.workingLevel.reqInt || 0; ENGINE.editor.isModified = false; exportArea.classList.remove('hidden'); updatePencilState(); } else { updatePlayModeLayout(); loadLevel(ENGINE.levelIdx, true); } updateAppScale(); updateViewport(); syncEditorPalettePlacement(); updateCompletionUI(); showMessage("", ""); }
    function updatePencilState() { const btn = $('editPencilBtn'); const svg = btn.querySelector('svg'); if (ENGINE.editor.isPencilMode) { btn.classList.add('selected'); svg.setAttribute('fill', 'currentColor'); } else { btn.classList.remove('selected'); svg.setAttribute('fill', 'none'); } }
    function saveEditorState() { ENGINE.editor.isModified = true; ENGINE.editor.undoStack.push(deepCloneLevel(ENGINE.editor.workingLevel)); if (ENGINE.editor.undoStack.length > 50) ENGINE.editor.undoStack.shift(); ENGINE.hinter.pathList = []; }
    function restoreEditorState() { if (ENGINE.editor.undoStack.length === 0) return; ENGINE.editor.isModified = true; ENGINE.editor.workingLevel = ENGINE.editor.undoStack.pop(); let newPending = null; ENGINE.editor.workingLevel.portalMap.forEach((v, k) => { if (v.dest === -1) newPending = k; }); ENGINE.editor.pendingPortal = newPending; ENGINE.hinter.pathList = []; ENGINE.editor.validTrapSpots.clear(); showMessage("Undo Grid Action", "text-slate-500"); }
    function pickUpObject(k) { if(ENGINE.editor.isPencilMode) return null; saveEditorState(); ENGINE.editor.draggedFromGrid = true; ENGINE.editor.validTrapSpots.clear(); const l = ENGINE.editor.workingLevel; l.hints = []; if (l.gateKeys.includes(k)) { l.gateKeys = l.gateKeys.filter(gk => gk !== k); return {type:'gate'}; } if (l.goalKey === k) { l.goalKey = -1; return {type:'goal'}; } if (l.falseGoalKeys.has(k)) { l.falseGoalKeys.delete(k); return {type:'falseGoal'}; } if (l.blockSet.has(k)) { l.blockSet.delete(k); return {type:'block'}; } if (l.gooseSet.has(k)) { l.gooseSet.delete(k); return {type:'goose'}; } if (l.mustPassKeys.includes(k)) { l.mustPassKeys = l.mustPassKeys.filter(mk => mk !== k); return {type:'mustPass'}; } if (l.mustCrossKeys.includes(k)) { l.mustCrossKeys = l.mustCrossKeys.filter(mk => mk !== k); return {type:'mustCross'}; } if (l.filterMap.has(k)) { const a = l.filterMap.get(k); l.filterMap.delete(k); return {type: a === H ? 'filterH' : 'filterV'}; } if (l.flippingFilterMap.has(k)) { const a = l.flippingFilterMap.get(k); l.flippingFilterMap.delete(k); return {type: a === H ? 'flipH' : 'flipV'}; } if (l.portalMap.has(k)) { const port = l.portalMap.get(k); l.portalMap.delete(k); if (ENGINE.editor.pendingPortal === k) { ENGINE.editor.pendingPortal = null; showMessage("Portal Cancelled", "text-slate-500"); } else { l.portalVisuals = l.portalVisuals.filter(pv => pv.k1 !== k && pv.k2 !== k); const otherK = port.dest; if (otherK !== -1 && l.portalMap.has(otherK)) { l.portalMap.get(otherK).dest = -1; l.portalMap.get(otherK).color = '#999'; ENGINE.editor.pendingPortal = otherK; showMessage("Portal unpaired! Place next terminal.", "text-fuchsia-600 font-bold"); } } return {type: 'portal'}; } ENGINE.editor.undoStack.pop(); ENGINE.editor.draggedFromGrid = false; return null; }
    function placeEditorObject(k) { const l = ENGINE.editor.workingLevel; const toolType = ENGINE.editor.draggedObject ? ENGINE.editor.draggedObject.type : ENGINE.editor.selectedTool; if (!toolType) return; if (ENGINE.editor.pendingPortal && toolType !== 'portal' && toolType !== 'eraser') { showMessage("Finish portal pair first!", "text-red-600 font-bold"); return; } if (l.gateKeys.includes(k) || l.goalKey === k || l.falseGoalKeys.has(k) || l.blockSet.has(k) || l.gooseSet.has(k) || l.filterMap.has(k) || l.flippingFilterMap.has(k) || l.portalMap.has(k) || l.mustPassKeys.includes(k) || l.mustCrossKeys.includes(k)) { if (toolType === 'eraser') { pickUpObject(k); return; } return showMessage("Occupied", "text-red-500"); } if (toolType === 'eraser') return; saveEditorState(); ENGINE.editor.validTrapSpots.clear(); l.hints = []; switch(toolType) { case 'gate': l.gateKeys.push(k); break; case 'goal': l.goalKey = k; break; case 'falseGoal': l.falseGoalKeys.add(k); break; case 'block': l.blockSet.add(k); break; case 'mustPass': l.mustPassKeys.push(k); break; case 'mustCross': l.mustCrossKeys.push(k); break; case 'goose': l.gooseSet.add(k); break; case 'filterH': l.filterMap.set(k, H); break; case 'filterV': l.filterMap.set(k, V); break; case 'flipH': l.flippingFilterMap.set(k, H); break; case 'flipV': l.flippingFilterMap.set(k, V); break; case 'portal': if (!ENGINE.editor.pendingPortal) { ENGINE.editor.pendingPortal = k; l.portalMap.set(k, { dest: -1, color: '#999' }); showMessage("Place second terminal.", "text-fuchsia-600 font-bold"); } else { const k1 = ENGINE.editor.pendingPortal; if (k === k1) return; const color = ENGINE.editor.paletteColors[l.portalVisuals.length % 5]; l.portalMap.set(k1, { dest: k, color }); l.portalMap.set(k, { dest: k1, color }); l.portalVisuals.push({ k1, k2: k, color }); ENGINE.editor.pendingPortal = null; showMessage("Portal paired.", "text-fuchsia-600 font-bold"); } break; } ENGINE.editor.draggedObject = null; }
    
    function validateLevel(l) { const { w, h } = l.grid; const err = (msg) => { showMessage(msg, "text-red-500 font-bold"); return false; }; if (ENGINE.editor.pendingPortal) return err("Incomplete portal pair."); let unpaired = false; l.portalMap.forEach(v => { if(!l.portalMap.has(v.dest)) unpaired = true; }); if (unpaired) return err("Unpaired portal exists."); for (let x = 0; x < w; x++) { for (let y = 0; y < h; y++) { const k = PACK(x,y); if (l.mustCrossKeys.includes(k)) { const neighbors = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => PACK(x+dx, y+dy)); const diags = [[1,1],[1,-1],[-1,1],[-1,-1]].map(([dx,dy]) => PACK(x+dx, y+dy)); if (neighbors.some(nk => l.blockSet.has(nk))) return err("Block touches MustCross"); if (neighbors.some(nk => l.gooseSet.has(nk))) return err("Goose touches MustCross"); const left = PACK(x-1,y), right = PACK(x+1,y), up = PACK(x,y-1), down = PACK(x,y+1); if ([left, right].some(nk => l.filterMap.get(nk) === V || l.flippingFilterMap.get(nk) === V)) return err("Vertical Filter adj to MustCross"); if ([up, down].some(nk => l.filterMap.get(nk) === H || l.flippingFilterMap.get(nk) === H)) return err("Horizontal Filter adj to MustCross"); if (diags.some(nk => l.filterMap.has(nk) || l.flippingFilterMap.has(nk))) return err("Filter diag to MustCross"); } const f = l.filterMap.get(k); if (f) { const neighbors = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => PACK(x+dx, y+dy)); for (const nk of neighbors) { const nf = l.filterMap.get(nk); if (nf && nf !== f) return err("Opposing filters adjacent."); } } } } const barrier = (k) => l.blockSet.has(k) || l.gooseSet.has(k) || l.filterMap.has(k) || l.flippingFilterMap.has(k); const walkable = []; for(let x=0; x<w; x++) for(let y=0; y<h; y++) { const k = PACK(x,y); if (!barrier(k)) walkable.push(k); } if (walkable.length > 0) { const q = [walkable[0]]; const visited = new Set([walkable[0]]); let head = 0; while(head < q.length) { const k = q[head++]; const p = UNPACK(k); const nks = [[0,1],[0,-1],[1,0],[-1,0]].map(([dx,dy]) => PACK(p.x+dx, p.y+dy)); if (l.portalMap.has(k)) nks.push(l.portalMap.get(k).dest); for(const nk of nks) { const np = UNPACK(nk); if (inBounds(np.x, np.y, w, h) && !visited.has(nk) && !barrier(nk)) { visited.add(nk); q.push(nk); } } } if (visited.size !== walkable.length) return err("Grid partitioned by barriers."); } return true; }
    function generateLevelString() { const l = ENGINE.editor.workingLevel; const isValid = validateLevel(l); const reqLen = parseInt($('editReqLen').value) || 0; const reqInt = parseInt($('editReqInt').value) || 0; let exportedHints = l.hints || []; if (ENGINE.path.length > 1 && ENGINE.path[ENGINE.path.length - 1] === l.goalKey) { const curLen = getRealLength(); const validLen = curLen === reqLen; const validInt = ENGINE.intersections === reqInt; const validPass = l.mustPassKeys.every(k => ENGINE.visitedCounts.get(k) > 0); const validCross = l.mustCrossKeys.every(k => (ENGINE.visitedCounts.get(k) || 0) >= 2); if (validLen && validInt && validPass && validCross) { const currentPathStr = JSON.stringify(ENGINE.path); const alreadyExists = exportedHints.some(h => JSON.stringify(h) === currentPathStr); if (!alreadyExists) { exportedHints = [ENGINE.path, ...exportedHints].slice(0, 5); } } } const out = { grid: l.grid, gates: expCoords(l.gateKeys), goal: {x:UNPACK(l.goalKey).x+1, y:UNPACK(l.goalKey).y+1}, falseGoals: expCoords(l.falseGoalKeys), reqLen: reqLen, reqInt: reqInt, blocks: expCoords(l.blockSet), mustPass: expCoords(l.mustPassKeys), mustCross: expCoords(l.mustCrossKeys), filters: Array.from(l.filterMap.entries()).map(([k, axis]) => ({x:UNPACK(k).x+1, y:UNPACK(k).y+1, axis})), flippingFilters: Array.from(l.flippingFilterMap.entries()).map(([k, axis]) => ({x:UNPACK(k).x+1, y:UNPACK(k).y+1, axis})), portals: l.portalVisuals.map(pv => ({ x1: UNPACK(pv.k1).x+1, y1: UNPACK(pv.k1).y+1, x2: UNPACK(pv.k2).x+1, y2: UNPACK(pv.k2).y+1, color: pv.color })), geese: expCoords(l.gooseSet), hints: exportedHints }; const json = JSON.stringify(out).replace(/\s/g, '').slice(1, -1); outEl.value = json; outEl.select(); document.execCommand('copy'); ENGINE.editor.isModified = false; if (isValid) { showMessage("Data Generated & Copied!", "text-white font-black"); } else { setTimeout(() => showMessage("Data Copied (Check Errors!)", "text-white font-black"), 1500); } }
    
    function getScreenPos(cx, cy) { const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; const { tx, ty } = transformPoint(cx, cy, ENGINE.variant, l.grid.w, l.grid.h); return { sx: (tx + 0.5) * ENGINE.viewport.cellW, sy: (ty + 0.5) * ENGINE.viewport.cellH }; }
    function drawBombAsset(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); const scale = s / 100; ctx.scale(scale, scale); ctx.beginPath(); ctx.arc(0, 10, 25, 0, Math.PI * 2); ctx.fillStyle = '#334155'; ctx.fill(); ctx.beginPath(); ctx.moveTo(0, -15); ctx.quadraticCurveTo(15, -30, 30, -25); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 4; ctx.stroke(); ctx.beginPath(); ctx.arc(30, -25, 5, 0, Math.PI * 2); ctx.fillStyle = '#ef4444'; ctx.fill(); ctx.beginPath(); ctx.arc(30, -25, 2.5, 0, Math.PI * 2); ctx.fillStyle = '#fde047'; ctx.fill(); ctx.beginPath(); ctx.moveTo(-5, -15); ctx.lineTo(5, -15); ctx.lineTo(5, -5); ctx.lineTo(-5, -5); ctx.closePath(); ctx.fillStyle = '#64748b'; ctx.fill(); ctx.restore(); }
    function drawPath(pathArr, isJumpSet, strokeStyle, width, isCaution = false) { if (!pathArr.length) return; ctx.save(); ctx.lineWidth = width; ctx.lineCap = isCaution ? 'butt' : 'round'; ctx.lineJoin = 'round'; const drawDot = (sx, sy, color) => { ctx.save(); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(sx, sy, width / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }; if (pathArr.length === 1 && !isCaution) { const start = UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); drawDot(sStart.sx, sStart.sy, (strokeStyle === 'rainbow') ? '#ff0000' : strokeStyle); ctx.restore(); return; } if (isCaution) { const trace = () => { const start = UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); ctx.beginPath(); ctx.moveTo(sStart.sx, sStart.sy); ctx.lineTo(sStart.sx, sStart.sy); for (let i = 1; i < pathArr.length; i++) { const p = UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); if (isJumpSet.has(i)) { ctx.moveTo(s.sx, s.sy); ctx.lineTo(s.sx, s.sy); } else { ctx.lineTo(s.sx, s.sy); } } }; ctx.strokeStyle = '#fbbf24'; trace(); ctx.stroke(); ctx.strokeStyle = '#000000'; ctx.setLineDash([width, width]); trace(); ctx.stroke(); ctx.setLineDash([]); } else if (ENGINE.rainbowActive) { const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3']; let totalLength = 0; const segments = []; for (let i = 1; i < pathArr.length; i++) { if (isJumpSet.has(i)) continue; const p1 = UNPACK(pathArr[i - 1]); const p2 = UNPACK(pathArr[i]); const s1 = getScreenPos(p1.x, p1.y); const s2 = getScreenPos(p2.x, p2.y); const dx = s2.sx - s1.sx; const dy = s2.sy - s1.sy; const len = Math.hypot(dx, dy); segments.push({ s1, s2, len }); totalLength += len; } const start = UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); drawDot(sStart.sx, sStart.sy, colors[0]); let curTravel = 0; segments.forEach(seg => { const mid = curTravel + seg.len / 2; const t = mid / Math.max(totalLength, 1); const colorIndex = Math.floor(t * colors.length) % colors.length; ctx.strokeStyle = colors[colorIndex]; ctx.beginPath(); ctx.moveTo(seg.s1.sx, seg.s1.sy); ctx.lineTo(seg.s2.sx, seg.s2.sy); ctx.stroke(); curTravel += seg.len; }); let jumpTravel = 0; for (let i = 1; i < pathArr.length; i++) { if (isJumpSet.has(i)) { const p = UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); const t = jumpTravel / Math.max(totalLength, 1); const colorIndex = Math.floor(t * colors.length) % colors.length; drawDot(s.sx, s.sy, colorIndex >= 0 ? colors[colorIndex] : colors[0]); } else { const p1 = UNPACK(pathArr[i - 1]); const p2 = UNPACK(pathArr[i]); jumpTravel += Math.hypot(p2.x - p1.x, p2.y - p1.y) * ENGINE.viewport.cellW; } } } else { ctx.strokeStyle = strokeStyle; const trace = () => { const start = UNPACK(pathArr[0]); const sStart = getScreenPos(start.x, start.y); ctx.beginPath(); ctx.moveTo(sStart.sx, sStart.sy); ctx.lineTo(sStart.sx, sStart.sy); for (let i = 1; i < pathArr.length; i++) { const p = UNPACK(pathArr[i]); const s = getScreenPos(p.x, p.y); if (isJumpSet.has(i)) { ctx.moveTo(s.sx, s.sy); ctx.lineTo(s.sx, s.sy); } else { ctx.lineTo(s.sx, s.sy); } } }; trace(); ctx.stroke(); } ctx.restore(); }
    function drawProhibitedAsset(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); ctx.beginPath(); ctx.arc(0, 0, s * 0.35, 0, Math.PI * 2); ctx.strokeStyle = "#ef4444"; ctx.lineWidth = s * 0.1; ctx.stroke(); ctx.beginPath(); const lineLen = s * 0.25; ctx.moveTo(-lineLen, -lineLen); ctx.lineTo(lineLen, lineLen); ctx.stroke(); ctx.restore(); }
    function drawRequiredAsset(ctx, cx, cy, s, hit, colors) { ctx.save(); ctx.translate(cx, cy); const tilt = hit ? 15 : -15; ctx.rotate(tilt * Math.PI / 180); const scale = s / 35; ctx.scale(scale, scale); ctx.beginPath(); ctx.moveTo(-1, 0); ctx.lineTo(1, 0); ctx.lineTo(1.5, -12); ctx.lineTo(-1.5, -12); ctx.closePath(); ctx.fillStyle = '#94a3b8'; ctx.fill(); ctx.beginPath(); ctx.arc(0, -18, 7, 0, Math.PI * 2); ctx.fillStyle = hit ? colors.pin : colors.pinUnflipped; ctx.fill(); ctx.restore(); }
    function drawMustCrossAsset(ctx, cx, cy, s, color) { ctx.save(); ctx.strokeStyle = color; ctx.globalAlpha = 0.25; ctx.lineWidth = s * 0.08; const outer = s * 0.4, inner = s * 0.18; ctx.beginPath(); ctx.moveTo(cx - outer, cy - inner); ctx.lineTo(cx - inner, cy - inner); ctx.lineTo(cx - inner, cy - outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx + outer, cy - inner); ctx.lineTo(cx + inner, cy - inner); ctx.lineTo(cx + inner, cy - outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - outer, cy + inner); ctx.lineTo(cx - inner, cy + inner); ctx.lineTo(cx - inner, cy + outer); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx + outer, cy + inner); ctx.lineTo(cx + inner, cy + inner); ctx.lineTo(cx + inner, cy + outer); ctx.stroke(); ctx.restore(); }
    function drawGooseAsset(ctx, cx, cy, s, isCheatReveal = false) { ctx.save(); if (isCheatReveal) ctx.globalAlpha = 0.5; const mapX = (v) => cx - s/2 + (v / 100 * s), mapY = (v) => cy - s/2 + (v / 100 * s); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.moveTo(mapX(30), mapY(0)); ctx.lineTo(mapX(70), mapY(0)); ctx.lineTo(mapX(100), mapY(30)); ctx.lineTo(mapX(100), mapY(70)); ctx.lineTo(mapX(70), mapY(100)); ctx.lineTo(mapX(30), mapY(100)); ctx.lineTo(mapX(0), mapY(70)); ctx.lineTo(mapX(0), mapY(30)); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.moveTo(mapX(25), mapY(60)); ctx.quadraticCurveTo(mapX(25), mapY(45), mapX(45), mapY(45)); ctx.lineTo(mapX(65), mapY(45)); ctx.quadraticCurveTo(mapX(75), mapY(45), mapX(75), mapY(55)); ctx.quadraticCurveTo(mapX(75), mapY(65), mapX(65), mapY(65)); ctx.lineTo(mapX(40), mapY(65)); ctx.quadraticCurveTo(mapX(25), mapY(65), mapX(25), mapY(60)); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(25), mapY(55)); ctx.lineTo(mapX(15), mapY(45)); ctx.lineTo(mapX(30), mapY(55)); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(60), mapY(45)); ctx.lineTo(mapX(60), mapY(25)); ctx.quadraticCurveTo(mapX(60), mapY(18), mapX(68), mapY(18)); ctx.quadraticCurveTo(mapX(75), mapY(18), mapX(75), mapY(25)); ctx.lineTo(mapX(75), mapY(35)); ctx.lineTo(mapX(68), mapY(35)); ctx.lineTo(mapX(68), mapY(45)); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(mapX(70), mapY(23), s * 0.02, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.moveTo(mapX(75), mapY(29)); ctx.lineTo(mapX(88), mapY(32)); ctx.lineTo(mapX(75), mapY(35)); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(mapX(45), mapY(65)); ctx.lineTo(mapX(40), mapY(78)); ctx.lineTo(mapX(52), mapY(78)); ctx.closePath(); ctx.moveTo(mapX(58), mapY(65)); ctx.lineTo(mapX(53), mapY(78)); ctx.lineTo(mapX(65), mapY(78)); ctx.closePath(); ctx.fill(); ctx.restore(); }
    function drawFilterAsset(ctx, cx, cy, s, axis, color) { ctx.save(); ctx.translate(cx, cy); if (axis === V) ctx.rotate(Math.PI / 2); ctx.fillStyle = color; ctx.globalAlpha = 0.25; const w = s * 0.45, t = s * 0.08; ctx.fillRect(-s/2 + s*0.1, -w/2, s*0.8, t); ctx.fillRect(-s/2 + s*0.1, w/2 - t, s*0.8, t); ctx.restore(); }
    function drawFlippingFilter(ctx, cx, cy, s, axis, color, rotation, crossed) { ctx.save(); ctx.translate(cx, cy); ctx.rotate(rotation); if (axis === V) ctx.rotate(Math.PI / 2); ctx.fillStyle = color; ctx.globalAlpha = 0.25; const w = s * 0.45, t = s * 0.08; ctx.fillRect(-s/2 + s*0.1, -w/2, s*0.8, t); ctx.fillRect(-s/2 + s*0.1, w/2 - t, s*0.8, t); if (ENGINE.mode === EDITOR) { ctx.globalAlpha = crossed ? 0.4 : 1.0; ctx.fillStyle = color; ctx.font = `900 ${s * 0.45}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('↺', 0, 0); } ctx.restore(); }
    function drawScorchMark(ctx, cx, cy, s) { ctx.save(); ctx.translate(cx, cy); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 0.4); grad.addColorStop(0, 'rgba(0,0,0,0.5)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); const radii = [0.35, 0.15, 0.4, 0.2, 0.3, 0.15, 0.35, 0.2, 0.4, 0.15, 0.3, 0.25, 0.35, 0.15, 0.4, 0.2]; for (let i = 0; i < 16; i++) { const a = (i / 16) * Math.PI * 2; const r = s * radii[i]; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); } ctx.closePath(); ctx.fill(); ctx.restore(); }
    
    // ======================================================
    // E) Render / Canvas
    // ======================================================
    function render() { 
        const vp = ENGINE.viewport, l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; if (!vp.cellW || !l) return; const th = THEMES[currentTheme]; ctx.fillStyle = th.canvasBg; ctx.fillRect(0, 0, cvs.width, cvs.height); const W = l.grid.w, H = l.grid.h, dispW = ENGINE.viewport.swapped ? H : W, dispH = ENGINE.viewport.swapped ? W : H, inset = vp.cellW * 0.25; ctx.beginPath(); ctx.strokeStyle = th.grid; ctx.lineWidth = 1; for (let i = 0; i <= dispW; i++) { const x = i * vp.cellW; ctx.moveTo(x, inset); ctx.lineTo(x, cvs.height - inset); } for (let i = 0; i <= dispH; i++) { const y = i * vp.cellH; ctx.moveTo(inset, y); ctx.lineTo(cvs.width - inset, y); } ctx.stroke(); 
        
        if (ENGINE.mode === EDITOR && ENGINE.editor.validTrapSpots && ENGINE.editor.validTrapSpots.size > 0) { ENGINE.editor.validTrapSpots.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const cx = sx - vp.cellW / 2, cy = sy - vp.cellH / 2; ctx.save(); ctx.fillStyle = th.colors.goal + '40'; ctx.fillRect(cx + 2, cy + 2, vp.cellW - 4, vp.cellH - 4); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = 3; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.1]); ctx.strokeRect(cx + 2, cy + 2, vp.cellW - 4, vp.cellH - 4); ctx.restore(); }); } 
        
        let reqLen = 0, showParityWarnings = false, targetParity = 0, hasFlippingPortal = false; 
        if ((ENGINE.mode === EDITOR || ENGINE.cheatActive) && l.goalKey !== -1) { 
            reqLen = ENGINE.mode === EDITOR ? (parseInt($('editReqLen').value) || 0) : l.reqLen; 
            if (reqLen > 0 || ENGINE.path.length > 0 || ENGINE.cheatActive) { 
                showParityWarnings = true; const gp = UNPACK(l.goalKey); targetParity = (gp.x + gp.y + reqLen) % 2; 
                l.portalVisuals.forEach(pv => { const p1 = UNPACK(pv.k1), p2 = UNPACK(pv.k2); if ((p1.x + p1.y) % 2 === (p2.x + p2.y) % 2) hasFlippingPortal = true; }); 
            } 
        } 
        
        l.filterMap.forEach((axis, k) => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawFilterAsset(ctx, sx, sy, vp.cellW, transformAxis(axis, ENGINE.variant), th.colors.filter); }); 
        
        l.flippingFilterMap.forEach((baseAxis, k) => { 
            const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); 
            const crossed = ENGINE.crossedFlippingFilters.has(k); 
            const targetFlips = crossed ? ENGINE.crossedFlippingFilters.get(k) : ENGINE.flipCount; 
            let currentVisualFlips = targetFlips; 
            if (!crossed && ENGINE.visualFlipCount !== undefined) { currentVisualFlips = ENGINE.visualFlipCount; } 
            const rotation = currentVisualFlips * (Math.PI / 2); 
            drawFlippingFilter(ctx, sx, sy, vp.cellW, transformAxis(baseAxis, ENGINE.variant), th.colors.filter, rotation, crossed); 
        }); 
        
        l.mustCrossKeys.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawMustCrossAsset(ctx, sx, sy, vp.cellW, th.colors.cross); }); 
        l.blockSet.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const cx = sx - vp.cellW / 2, cy = sy - vp.cellH / 2, cr = vp.cellW * 0.2; ctx.fillStyle = th.colors.block; ctx.beginPath(); ctx.roundRect(cx + 1, cy + 1, vp.cellW - 2, vp.cellH - 2, cr); ctx.fill(); ctx.fillStyle = th.grid; for(let r=1;r<=3;r++) for(let c=1;c<=3;c++) { ctx.beginPath(); ctx.arc(cx+(c*0.25*vp.cellW),cy+(r*0.25*vp.cellH),vp.cellW*0.045,0,Math.PI*2); ctx.fill(); } }); 
        
        l.portalVisuals.forEach(pv => { const color = ENGINE.mode === EDITOR ? pv.color : th.colors.portal; ctx.strokeStyle = color; ctx.lineWidth = vp.cellW * 0.1; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); [UNPACK(pv.k1), UNPACK(pv.k2)].forEach(p => { const { sx, sy } = getScreenPos(p.x, p.y); ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.3, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = color + '25'; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); if (showParityWarnings && !hasFlippingPortal) { if ((p.x + p.y) % 2 !== targetParity) drawProhibitedAsset(ctx, sx, sy, vp.cellW); } }); }); ctx.setLineDash([]); 
        
        if (ENGINE.editor.pendingPortal) { const pp = UNPACK(ENGINE.editor.pendingPortal), { sx, sy } = getScreenPos(pp.x, pp.y); ctx.strokeStyle = th.colors.portal; ctx.lineWidth = vp.cellW * 0.1; ctx.setLineDash([vp.cellW * 0.1, vp.cellW * 0.08]); ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.3, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = th.colors.portal + '25'; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.2, 0, Math.PI * 2); ctx.fill(); } 
        l.mustPassKeys.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); const isHit = ENGINE.visitedCounts.get(k) > 0; drawRequiredAsset(ctx, sx, sy, vp.cellW, isHit, th.colors); }); 
        
        const now = Date.now(); ENGINE.ripples = ENGINE.ripples.filter(r => now - r.startTime < 600); ENGINE.ripples.forEach(r => { const pct = (now - r.startTime) / 600, { sx, sy } = getScreenPos(r.x, r.y); ctx.save(); ctx.globalAlpha = 1 - pct; ctx.strokeStyle = r.color; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * (0.3 + pct * 1.2), 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }); 
        
        l.gateKeys.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); ctx.save(); ctx.translate(sx, sy); ctx.rotate(-Math.PI / 4); const color = (ENGINE.activeGateKey === k || !ENGINE.activeGateKey) ? th.colors.gate : '#94a3b8'; ctx.strokeStyle = color; ctx.lineWidth = vp.cellW * 0.12; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; for(let i=0; i<2; i++) { const offset = (i - 0.5) * vp.cellW * 0.32; ctx.beginPath(); ctx.moveTo(offset - vp.cellW * 0.1, -vp.cellW * 0.2); ctx.lineTo(offset + vp.cellW * 0.1, 0); ctx.lineTo(offset - vp.cellW * 0.1, vp.cellW * 0.2); ctx.stroke(); } ctx.restore(); if (showParityWarnings && !hasFlippingPortal) { if ((p.x + p.y) % 2 !== targetParity) drawProhibitedAsset(ctx, sx, sy, vp.cellW); } }); 
        
        if (ENGINE.path.length) { const stroke = ENGINE.rainbowActive ? 'rainbow' : th.path; drawPath(ENGINE.path, ENGINE.isPortalJump, stroke, vp.cellW * 0.25); } 
        
        if (ENGINE.overlayState === HINT_ANIMATING && ENGINE.hinter.pathList.length) { 
            ctx.save(); ctx.globalAlpha = ENGINE.hinter.alpha; 
            const hPath = ENGINE.hinter.pathList[ENGINE.hinter.currentPathIdx], displayPath = hPath.slice(0, Math.floor(ENGINE.hinter.index)), hintsJumps = new Set(); 
            for(let i=1; i<displayPath.length; i++){ const p1 = UNPACK(displayPath[i-1]), p2 = UNPACK(displayPath[i]); if (Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) > 1) hintsJumps.add(i); } 
            drawPath(displayPath, hintsJumps, '#22c55e', vp.cellW * 0.3, true); 
            ctx.restore(); 
        } 
        
        if (l.goalKey !== -1) { const goalP = UNPACK(l.goalKey), sGoal = getScreenPos(goalP.x, goalP.y); ctx.save(); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = vp.cellW * 0.1; ctx.beginPath(); ctx.arc(sGoal.sx, sGoal.sy, vp.cellW * 0.32, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = th.colors.goal; ctx.beginPath(); ctx.arc(sGoal.sx, sGoal.sy, vp.cellW * 0.14, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } 
        
        l.falseGoalKeys.forEach(k => { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); if (ENGINE.armedFalseGoals.has(k)) { ctx.save(); ctx.strokeStyle = th.colors.goal; ctx.lineWidth = vp.cellW * 0.1; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.32, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = th.colors.goal; ctx.beginPath(); ctx.arc(sx, sy, vp.cellW * 0.14, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } else if (ENGINE.detonatedFalseGoals.has(k)) { drawScorchMark(ctx, sx, sy, vp.cellW); } else if (ENGINE.mode === EDITOR) { drawBombAsset(ctx, sx, sy, vp.cellW); } }); 
        
        l.gooseSet.forEach(k => { if (ENGINE.revealedGeese.has(k) || ENGINE.cheatActive || ENGINE.mode === EDITOR) { const p = UNPACK(k), { sx, sy } = getScreenPos(p.x, p.y); drawGooseAsset(ctx, sx, sy, vp.cellW, ENGINE.cheatActive && !ENGINE.revealedGeese.has(k)); } }); 
        
        if (ENGINE.mode === PLAY) { const curLen = getRealLength(ENGINE); $('lengthInfo').innerText = `${curLen}/${l.reqLen}`; const intEl = $('intersectionInfo'); intEl.innerText = `${ENGINE.intersections}/${l.reqInt}`; if (ENGINE.intersections > l.reqInt) { intEl.classList.remove('text-white'); intEl.classList.add('text-red-300'); } else { intEl.classList.add('text-white'); intEl.classList.remove('text-red-300'); } } 
        else if (ENGINE.mode === EDITOR) { const curLen = getRealLength(ENGINE); const lMet = $('editCopyMetrics'); if (lMet) lMet.innerText = `Set (${curLen}/${ENGINE.intersections})`; }
    }
    
    async function runGameSolver() { 
        if (ENGINE.activeSolverController) return; 
        stopHintAnimation();
        
        ENGINE.activeSolverController = new AbortController(); 
        setOverlayState(SOLVER_RUNNING);
        
        const uiTimer = $('solverTimer'); 
        const searchLabel = $('searchLabel'); 
        const startTime = Date.now();

        try { 
            const activeLevel = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; 
            const solutions = await PathfinderSolver.solve(activeLevel, { 
                timeLimit: 105000, 
                signal: ENGINE.activeSolverController.signal, 
                onStateUpdate: (msg) => { 
                    searchLabel.innerText = msg; 
                    showMessage(msg, "text-sky-600"); 
                }, 
                onProgress: (elapsedMs) => { uiTimer.innerText = (elapsedMs / 1000).toFixed(1) + 's'; } 
            }); 
            
            if (solutions.length > 0) { 
                const paths = solutions.map(s => s.path); 
                if (ENGINE.mode === EDITOR) { ENGINE.editor.workingLevel.hints = paths.slice(0, 4); } 
                ENGINE.hinter.pathList = paths; 
                const seenHints = new Set((ENGINE.foundHintsSinceLoad || []).map(p => JSON.stringify(p)));
                if (!ENGINE.foundHintsSinceLoad) ENGINE.foundHintsSinceLoad = [];
                paths.forEach(path => { const key = JSON.stringify(path); if (!seenHints.has(key)) { ENGINE.foundHintsSinceLoad.push(path); seenHints.add(key); } });
                ENGINE.hinter.source = 'dynamic'; 
                ENGINE.hinter.currentPathIdx = 0; 
                outEl.value = JSON.stringify(paths).replace(/\s/g, ''); 
                startHintAnimation(); 
            } else { 
                outEl.value = solutions.timedOut ? "Solver timed out before proving unsat." : "No strict solutions found."; 
                showMessage(solutions.timedOut ? "Solver timed out." : "No valid path found.", "text-amber-600"); 
                setOverlayState(OVERLAY_NONE);
            } 
        } catch (err) { 
            setOverlayState(OVERLAY_NONE);
            if (err.name === 'AbortError') { showMessage("Solver cancelled.", "text-amber-600"); } 
            else { console.error("Solver error:", err); } 
        } finally { 
            ENGINE.activeSolverController = null; 
        } 
    }
    
    function startHintAnimation() { 
        if (!ENGINE.hinter.pathList.length) return; 
        setOverlayState(HINT_ANIMATING);
        ENGINE.hinter.alpha = 1; ENGINE.hinter.index = 0; 
        showMessage(`Solution ${ENGINE.hinter.currentPathIdx + 1}/${ENGINE.hinter.pathList.length}`, "text-emerald-600"); 
    }

    function stopHintAnimation() {
        ENGINE.hinter.pathList = [];
        ENGINE.hinter.currentPathIdx = 0;
        ENGINE.hinter.index = 0;
        ENGINE.hinter.alpha = 0;
        setOverlayState(OVERLAY_NONE);
    }
    
    function loadLevel(idx, keepVariant = false) { 
        if (ENGINE.activeSolverController) return; 
        const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : (typeof FALLBACK_RAW_LEVELS !== 'undefined' ? FALLBACK_RAW_LEVELS : null); 
        if (!levels) return; 

        ENGINE.levelIdx = idx; 
        const isEditor = ENGINE.mode === EDITOR; 
        if (isEditor) { ENGINE.variant = 0; } 
        else if (!keepVariant) { ENGINE.variant = Math.floor(Math.random() * 8); } 
        
        setLogicState(IDLE);
        setOverlayState(OVERLAY_NONE);
        
        ENGINE.level = normalizeLevel(idx); 
        assertLevelShape(ENGINE.level); 
        PathNavigator.clear(ENGINE); 
        ENGINE.undoStack = []; 
        ENGINE.revealedGeese.clear(); 
        ENGINE.ripples = []; 
        ENGINE.gooseEncounteredThisLevel = false; 
        ENGINE.armedFalseGoals = new Set(ENGINE.level.falseGoalKeys || []);
        ENGINE.detonatedFalseGoals = new Set();
        ENGINE.foundHintsSinceLoad = [];
        if (isEditor) { 
            ENGINE.editor.workingLevel = deepCloneLevel(ENGINE.level); 
            ENGINE.editor.isPencilMode = false; 
            ENGINE.editor.undoStack = []; 
            ENGINE.editor.validTrapSpots.clear(); 
            ENGINE.editor.emptyClickCount = 0; 
            $('editReqLen').value = ENGINE.editor.workingLevel.reqLen || 0; 
            $('editReqInt').value = ENGINE.editor.workingLevel.reqInt || 0; 
            ENGINE.editor.isModified = false; 
            updatePencilState(); 
        } 
        const lvlStr = `${idx+1}`; 
        $('levelTitle').innerText = lvlStr; 
        $('levelTitle').style.fontSize = lvlStr.length >= 3 ? '2.5rem' : ''; 
        $('winModal').classList.add('hidden'); 
        showMessage("", ""); 
        updateAppScale();
        updateViewport(); 
        updateCompletionUI();
    }
    
    function updateViewport() { const rect = cvs.getBoundingClientRect(); if (rect.width === 0) return; const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel; if (!l) return; const swaps = [1, 3, 6, 7]; ENGINE.viewport.swapped = swaps.includes(ENGINE.variant); const gridW = ENGINE.viewport.swapped ? l.grid.h : l.grid.w, gridH = ENGINE.viewport.swapped ? l.grid.w : l.grid.h; ENGINE.viewport.cellW = cvs.width / gridW; ENGINE.viewport.cellH = cvs.height / gridH; }
    
    let messageTimer = null;
    function showMessage(t, c) {
        msgEl.innerText = t;
        msgEl.className = "text-center font-black uppercase tracking-tighter architectural-tight leading-tight drop-shadow-md";
        msgEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--theme-alert-text').trim() || "#ffffff";
        const overlay = $('alertOverlay');
        if (t === "") { overlay.style.opacity = '0'; return; }
        overlay.style.opacity = '1';
        if (messageTimer) clearTimeout(messageTimer);
        messageTimer = setTimeout(() => { overlay.style.opacity = '0'; }, 2000);
    }
    
    // ======================================================
    // F/G/H) Input + UI Wiring + Solver Boot
    // ======================================================
    window.onload = () => {
        let pendingAction = null; const tryNavigate = (actionFn) => { if (ENGINE.mode === EDITOR && ENGINE.editor.isModified) { pendingAction = actionFn; $('unsavedModal').classList.remove('hidden'); } else { actionFn(); } };
        $('unsavedStayBtn').onclick = () => { closeAllModals(); pendingAction = null; $('unsavedModal').classList.add('hidden'); };
        $('unsavedLeaveBtn').onclick = () => { closeAllModals(); $('unsavedModal').classList.add('hidden'); if (pendingAction) pendingAction(); };
        
        const handleGridPressAtPoint = (clientX, clientY) => handleDown({ clientX, clientY });
        gamepadGridPrimaryAction = () => {
            const rect = cvs.getBoundingClientRect();
            handleGridPressAtPoint(rect.left + rect.width / 2, rect.top + rect.height / 2);
        };

        let activePointerId = null; const handleDown = (e) => {
            if (ENGINE.activeSolverController || [RESOLVED, HAZARD_TRIGGERED].includes(ENGINE.logicState) || [HINT_ANIMATING, FALSE_GOAL_ANIMATING, SOLVER_RUNNING].includes(ENGINE.overlayState)) return;
            const p = getGridCoord(e); const k = PACK(p.x, p.y); const activeLevel = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel;
            ENGINE.resetStreak = 0;
            if (ENGINE.mode === EDITOR && !ENGINE.editor.isPencilMode) {
                const occupied = activeLevel.gateKeys.includes(k) || activeLevel.goalKey === k || activeLevel.falseGoalKeys.has(k) || activeLevel.blockSet.has(k) || activeLevel.gooseSet.has(k) || activeLevel.filterMap.has(k) || activeLevel.flippingFilterMap.has(k) || activeLevel.portalMap.has(k) || activeLevel.mustPassKeys.includes(k) || activeLevel.mustCrossKeys.includes(k);
                if (occupied) { ENGINE.editor.emptyClickCount = 0; ENGINE.editor.draggedObject = pickUpObject(k); if (ENGINE.editor.draggedObject) { setLogicState(EDIT_DRAG); ghostEl.style.display = 'flex'; } } else if (ENGINE.editor.selectedTool) { ENGINE.editor.emptyClickCount = 0; placeEditorObject(k); } else { ENGINE.editor.emptyClickCount++; if (ENGINE.editor.emptyClickCount >= 2) { showMessage("Click pencil to draw.", "text-white font-bold"); } } return;
            }
            if (ENGINE.path.length > 0) {
                if (ENGINE.path.length === 1 && activeLevel.gateKeys.includes(k) && k !== ENGINE.activeGateKey) {
                    PathNavigator.clear(ENGINE);
                    ENGINE.activeGateKey = k;
                    PathNavigator.pushStep(ENGINE, k, false);
                    setLogicState(DRAGGING);
                    return;
                }
                if (ENGINE.mode === EDITOR && ENGINE.editor.isPencilMode) {
                    const idx = ENGINE.path.indexOf(k); let shouldReverse = false;
                    if (idx !== -1) { if (idx < ENGINE.path.length / 2) shouldReverse = true; } else { const headP = UNPACK(ENGINE.path[ENGINE.path.length - 1]); const tailP = UNPACK(ENGINE.path[0]); const distHead = Math.abs(p.x - headP.x) + Math.abs(p.y - headP.y); const distTail = Math.abs(p.x - tailP.x) + Math.abs(p.y - tailP.y); if (distTail < distHead) shouldReverse = true; }
                    if (shouldReverse) { ENGINE.path.reverse(); const newJumps = new Set(); ENGINE.isPortalJump.forEach(jIdx => newJumps.add(ENGINE.path.length - jIdx)); ENGINE.isPortalJump = newJumps; rebuildDerivedPathState(ENGINE); }
                }
                const lastIdx = ENGINE.path.lastIndexOf(k); if (lastIdx !== -1 && lastIdx < ENGINE.path.length - 1) { PathNavigator.truncateTo(ENGINE, lastIdx); setLogicState(DRAGGING); return; }
                setLogicState(DRAGGING); attemptMoveTo(p);
            } else {
                if (!activeLevel) return;
                if (ENGINE.mode === EDITOR && ENGINE.editor.isPencilMode) { ENGINE.activeGateKey = null; PathNavigator.pushStep(ENGINE, k, false); setLogicState(DRAGGING); attemptMoveTo(p); } else {
                    let bestGate = null; if (activeLevel.gateKeys.includes(k)) { bestGate = k; } else { let minDist = Infinity; for (let i = 0; i < activeLevel.gateKeys.length; i++) { const gk = activeLevel.gateKeys[i]; const gp = UNPACK(gk); if (p.x === gp.x || p.y === gp.y) { const dist = Math.abs(p.x - gp.x) + Math.abs(p.y - gp.y); if (dist > 0 && dist < minDist) { minDist = dist; bestGate = gk; } } } }
                    if (bestGate !== null) { ENGINE.activeGateKey = bestGate; PathNavigator.pushStep(ENGINE, bestGate, false); setLogicState(DRAGGING); if (bestGate !== k) { attemptMoveTo(p); } }
                }
            }
        };

        const handleUp = (e) => {
            if (ENGINE.logicState === THEME_DRAG) {
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                let isSameElement = (dropTarget && dropTarget.dataset.themeColor === ENGINE.themeDragColor);
                if (dropTarget && dropTarget.dataset.themeColor && !isSameElement) {
                    if (ENGINE.themeDragCategory === dropTarget.dataset.category) {
                        replaceThemeColor(ENGINE.themeDragTheme, dropTarget.dataset.themeColor, ENGINE.themeDragColor, dropTarget.dataset.category);
                    } else {
                        showMessage("Mismatched Categories", "text-white font-black");
                    }
                }
                setLogicState(IDLE); ENGINE.themeDragColor = null; ENGINE.themeDragTheme = null; ENGINE.themeDragCategory = null; ghostEl.style.display = 'none'; ghostEl.innerHTML = '';
                if (!ENGINE.themeTapSelectedColor) { document.querySelectorAll('.theme-swatch-selected').forEach(el => el.classList.remove('ring-4', 'ring-[var(--theme-modal-accent)]', 'theme-swatch-selected', 'z-10', 'scale-110')); }
            }
            if (ENGINE.logicState === EDIT_DRAG && ENGINE.mode === EDITOR) { const crect = cvs.getBoundingClientRect(); if (e.clientX >= crect.left && e.clientX <= crect.right && e.clientY >= crect.top && e.clientY <= crect.bottom) { placeEditorObject(PACK(getGridCoord(e).x, getGridCoord(e).y)); } else { if (ENGINE.editor.draggedFromGrid) { ENGINE.editor.draggedObject = null; saveEditorState(); showMessage("Deleted", "text-white font-black"); } } ENGINE.editor.draggedObject = null; setLogicState(IDLE); } if (ENGINE.logicState === DRAGGING) setLogicState(IDLE);
        };

        cvs.addEventListener('pointerdown', e => { if (e.button !== 0 && e.pointerType === 'mouse') return; if (activePointerId !== null) return; e.preventDefault(); activePointerId = e.pointerId; cvs.setPointerCapture(activePointerId); handleDown(e); });
        window.addEventListener('pointermove', e => {
            if (ENGINE.logicState === THEME_DRAG) { ghostEl.style.left = e.clientX + 'px'; ghostEl.style.top = e.clientY + 'px'; e.preventDefault(); return; }
            if (ENGINE.mode === EDITOR && (ENGINE.editor.draggedObject || (ENGINE.editor.selectedTool && ENGINE.logicState === EDIT_DRAG))) { const size = ENGINE.viewport.cellW, ghostSize = size * 1.15; ghostEl.style.width = ghostSize + 'px'; ghostEl.style.height = ghostSize + 'px'; ghostEl.style.left = e.clientX + 'px'; ghostEl.style.top = e.clientY + 'px'; const type = ENGINE.editor.draggedObject ? ENGINE.editor.draggedObject.type : ENGINE.editor.selectedTool; const paletteIcon = document.querySelector(`.palette-item[data-type="${type}"] svg`); if (paletteIcon && ghostEl.innerHTML === '') { ghostEl.innerHTML = paletteIcon.outerHTML; } const palEl = $('editorPalette'); let isOverPalette = false; if (!palEl.classList.contains('hidden')) { const palRect = palEl.getBoundingClientRect(); isOverPalette = e.clientX >= palRect.left && e.clientX <= palRect.right && e.clientY >= palRect.top && e.clientY <= palRect.bottom; } ghostEl.style.display = isOverPalette ? 'none' : 'flex'; } else { ghostEl.style.display = 'none'; ghostEl.innerHTML = ''; } if (e.pointerId !== activePointerId && ENGINE.logicState !== EDIT_DRAG) return; e.preventDefault(); if (ENGINE.logicState === DRAGGING) attemptMoveTo(getGridCoord(e));
        });
        window.addEventListener('pointerup', e => { handleUp(e); if (activePointerId !== null && cvs.hasPointerCapture(activePointerId)) cvs.releasePointerCapture(activePointerId); activePointerId = null; });

        [cvs, $('hintBtn'), $('editCopyMetrics')].forEach(el => { if (!el) return; if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex', '0'); });

        const GAMEPAD_MAP = { A: 0, B: 1, UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15 };
        const GAMEPAD_REPEAT_INITIAL = 220;
        const GAMEPAD_REPEAT_RATE = 100;

        function gamepadMoveGrid(dx, dy) {
            if (isModalActive()) return;
            const l = ENGINE.mode === PLAY ? ENGINE.level : ENGINE.editor.workingLevel;
            if (!l) return;
            if (!ENGINE.path.length) {
                const firstGate = l.gateKeys && l.gateKeys.length ? UNPACK(l.gateKeys[0]) : null;
                if (!firstGate) return;
                ENGINE.activeGateKey = l.gateKeys[0];
                PathNavigator.pushStep(ENGINE, l.gateKeys[0], false);
                setLogicState(DRAGGING);
            }
            const head = UNPACK(ENGINE.path[ENGINE.path.length - 1]);
            attemptMoveTo({ x: head.x + dx, y: head.y + dy });
        }

        function handleGamepadDirection(dir) {
            if (ENGINE.ui.focusGroup === 'GRID') {
                if (dir === 'UP') gamepadMoveGrid(0, -1);
                if (dir === 'DOWN') gamepadMoveGrid(0, 1);
                if (dir === 'LEFT') gamepadMoveGrid(-1, 0);
                if (dir === 'RIGHT') gamepadMoveGrid(1, 0);
                return;
            }
            moveFocusWithinGroup((dir === 'LEFT' || dir === 'UP') ? -1 : 1);
        }

        function handleBPress() {
            const now = Date.now();
            if (now - ENGINE.ui.bLastPressTime <= 320) {
                if (ENGINE.ui.bSingleTimer) { clearTimeout(ENGINE.ui.bSingleTimer); ENGINE.ui.bSingleTimer = null; }
                cycleFocusGroup();
                ENGINE.ui.bLastPressTime = 0;
                return;
            }
            ENGINE.ui.bLastPressTime = now;
            ENGINE.ui.bSingleTimer = setTimeout(() => { dismissGuideOrHelpModal(); ENGINE.ui.bSingleTimer = null; }, 320);
        }

        function pollGamepadInput() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            const pad = pads && pads[0];
            if (!pad) return;
            ENGINE.gamepad.hasPad = true;
            const now = Date.now();

            const pressed = idx => !!pad.buttons[idx] && pad.buttons[idx].pressed;
            const wasPressed = idx => !!ENGINE.gamepad.lastButtons[idx];
            const anyPressed = pad.buttons.some(b => !!b && b.pressed);
            if (anyPressed) ENGINE.gamepad.hasPad = true;

            if (pressed(GAMEPAD_MAP.A) && !wasPressed(GAMEPAD_MAP.A)) activateFocusedControl();
            if (pressed(GAMEPAD_MAP.B) && !wasPressed(GAMEPAD_MAP.B)) handleBPress();

            const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
            let activeDir = null;
            for (const dir of dirs) {
                const idx = GAMEPAD_MAP[dir];
                if (pressed(idx)) { activeDir = dir; if (!wasPressed(idx)) { handleGamepadDirection(dir); ENGINE.gamepad.nextMoveAt = now + GAMEPAD_REPEAT_INITIAL; } }
            }
            if (activeDir && now >= ENGINE.gamepad.nextMoveAt) {
                handleGamepadDirection(activeDir);
                ENGINE.gamepad.nextMoveAt = now + GAMEPAD_REPEAT_RATE;
            }

            ENGINE.gamepad.lastButtons = pad.buttons.map(b => b.pressed);
        }

        window.addEventListener('gamepadconnected', () => setFocusGroup(ENGINE.ui.focusGroup || 'GRID', ENGINE.ui.focusIndex || 0));
        window.addEventListener('gamepaddisconnected', () => { ENGINE.gamepad.hasPad = false; ENGINE.gamepad.lastButtons = []; ENGINE.ui.gamepadFocusEnabled = false; applyFocusVisual(null); });
        setFocusGroup('CONTROLS', 0);
        
        window.addEventListener('resize', () => {
            updateAppScale();
            setFocusGroup(ENGINE.ui.focusGroup || 'GRID', ENGINE.ui.focusIndex || 0);
        });
        updateAppScale();

        $('gridRotateBtn').onclick = () => { closeAllModals(); if (ENGINE.overlayState !== OVERLAY_NONE || !ENGINE.editor.workingLevel) return; const l = ENGINE.editor.workingLevel; transformLevel(l, (x, y) => ({ x: l.grid.h - 1 - y, y: x }), l.grid.h, l.grid.w, (a) => a === H ? V : H); showMessage("Rotated", "text-white font-black"); };
        $('gridMirrorBtn').onclick = () => { closeAllModals(); if (ENGINE.overlayState !== OVERLAY_NONE || !ENGINE.editor.workingLevel) return; const l = ENGINE.editor.workingLevel; ENGINE.editor.mirrorHorizontal = !ENGINE.editor.mirrorHorizontal; $('mirrorIconSvg').style.transform = ENGINE.editor.mirrorHorizontal ? 'rotate(90deg)' : 'rotate(0deg)'; if (ENGINE.editor.mirrorHorizontal) { transformLevel(l, (x, y) => ({ x: l.grid.w - 1 - x, y: y }), l.grid.w, l.grid.h, (a) => a); } else { transformLevel(l, (x, y) => ({ x: x, y: l.grid.h - 1 - y }), l.grid.w, l.grid.h, (a) => a); } showMessage("Mirrored", "text-white font-black"); };
        $('gridSizeMinusBtn').onclick = () => { closeAllModals(); changeGridSize(-1); };
        $('gridSizePlusBtn').onclick = () => { closeAllModals(); changeGridSize(1); };
        $('muteBtn').onclick = () => { closeAllModals(); ENGINE.muted = !ENGINE.muted; $('muteSlash').style.display = ENGINE.muted ? 'block' : 'none'; };
        $('orientationToggleBtn').onclick = () => { closeAllModals(); ENGINE.ui.forceLandscapeLayout = !ENGINE.ui.forceLandscapeLayout; updateLayoutMode(); updateAppScale(); updateViewport(); showMessage(ENGINE.ui.forceLandscapeLayout ? 'Landscape layout on.' : 'Standard layout on.', 'text-sky-600'); };
        
        const perspectiveAction = () => { closeAllModals(); if (ENGINE.activeSolverController) return; ENGINE.variant = (ENGINE.variant + 1) % 8; updateViewport(); rebuildDerivedPathState(ENGINE); SOUND_BUS.play("D5", "32n"); };
        $('whoaBtn').onclick = perspectiveAction;
        
        $('resetBtn').onclick = () => { 
            closeAllModals();
            if (ENGINE.overlayState !== OVERLAY_NONE || ENGINE.activeSolverController) return; 
            if (ENGINE.cheatActive) {
                if (ENGINE.cheatTimer) clearTimeout(ENGINE.cheatTimer);
                ENGINE.cheatTimer = setTimeout(() => { ENGINE.cheatActive = false; }, 3000);
            } else {
                ENGINE.resetStreak++; 
                if (ENGINE.resetStreak >= 5) { 
                    ENGINE.cheatActive = true; 
                    SOUND_BUS.play("F5", "8n"); 
                    if (ENGINE.cheatTimer) clearTimeout(ENGINE.cheatTimer);
                    ENGINE.cheatTimer = setTimeout(() => { 
                        ENGINE.cheatActive = false; 
                        ENGINE.resetStreak = 0; 
                    }, 3000); 
                } 
            }
            loadLevel(ENGINE.levelIdx, true); 
        };

        $('undoBtn').onclick = () => { closeAllModals(); if(ENGINE.undoStack.length) applySnapshot(ENGINE.undoStack.pop()); };
        $('devGenBtn').onclick = async () => { closeAllModals(); const hints = ENGINE.foundHintsSinceLoad || []; if (!hints.length) { showMessage("No hints found yet.", ""); return; } const hintText = JSON.stringify(hints).replace(/\s/g, ''); outEl.value = hintText; try { await navigator.clipboard.writeText(hintText); } catch (e) { outEl.select(); document.execCommand('copy'); } showMessage(`Copied ${hints.length} hint${hints.length === 1 ? '' : 's'}`, ""); };
        $('editGenBtn').onclick = () => { closeAllModals(); generateLevelString(); };
        $('devCopyBtn').onclick = () => { closeAllModals(); if (outEl.value) { outEl.select(); document.execCommand('copy'); showMessage("Copied", "text-white font-black"); } };
        $('editCopyBtn').onclick = () => { closeAllModals(); if (ENGINE.path.length > 0) { const pathStr = JSON.stringify(ENGINE.path).replace(/\s/g, ''); outEl.value = pathStr; outEl.select(); document.execCommand('copy'); showMessage("Path Copied", "text-white font-black"); } };

        const hintBtn = $('hintBtn'); const hintTopHalf = $('hintTopHalf'); let isHintExpanded = false;
        const toggleHint = () => { 
            if (isHintExpanded) { 
                hintTopHalf.classList.add('hidden'); 
                hintTopHalf.classList.remove('flex'); 
                hintBtn.style.height = '2.5rem';
                hintBtn.style.marginTop = '0';
            } else { 
                hintTopHalf.classList.remove('hidden'); 
                hintTopHalf.classList.add('flex'); 
                hintBtn.style.height = '5.275rem';
                hintBtn.style.marginTop = '-2.775rem';
            } 
            isHintExpanded = !isHintExpanded; 
        };
        const updateHintLabel = () => { const hasSaved = ENGINE.level && ENGINE.level.hints && ENGINE.level.hints.length > 0; const mainLabel = $('hintMainLabel'); if (isHintExpanded) { mainLabel.innerText = "Saved Hint"; mainLabel.style.color = hasSaved ? "white" : "#cbd5e1"; } else { mainLabel.innerText = "Hint"; mainLabel.style.color = "white"; } };
        hintBtn.onclick = (e) => {
            closeAllModals();
            if (ENGINE.overlayState !== OVERLAY_NONE || ENGINE.activeSolverController) return;
            if (!isHintExpanded) { toggleHint(); updateHintLabel(); } else {
                const rect = hintBtn.getBoundingClientRect(); const clickY = e.clientY - rect.top; const isTopHalf = clickY < rect.height / 2;
                if (isTopHalf) runGameSolver(); else { if (ENGINE.level?.hints?.length > 0) { ENGINE.hinter.pathList = ENGINE.level.hints; ENGINE.hinter.currentPathIdx = (ENGINE.hinter.source === 'saved' ? (ENGINE.hinter.currentPathIdx + 1) % ENGINE.hinter.pathList.length : 0); ENGINE.hinter.source = 'saved'; startHintAnimation(); } else showMessage("No saved hint.", "text-white font-black"); }
                toggleHint(); updateHintLabel();
            }
        };
        document.addEventListener('click', (e) => { if (isHintExpanded && !hintBtn.contains(e.target)) { toggleHint(); updateHintLabel(); } });

        $('solverCloseBtn').onclick = () => { if (ENGINE.activeSolverController) ENGINE.activeSolverController.abort(); };
        const handleWinClose = (callback) => { const circle = $('winCircle'); circle.classList.add('animate-spin-grow-fade'); setTimeout(() => { circle.classList.remove('animate-spin-grow-fade'); $('winModal').classList.add('hidden'); callback(); }, 1000); };
        $('copyWinDataBtn').onclick = () => { if (winOutEl.value) { winOutEl.select(); document.execCommand('copy'); } };
        $('prevLevelBtn').onclick = () => tryNavigate(() => { closeAllModals(); if (ENGINE.overlayState !== OVERLAY_NONE || ENGINE.activeSolverController) return; const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; loadLevel(ENGINE.levelIdx > 0 ? ENGINE.levelIdx - 1 : levels.length - 1); outEl.value = ''; });
        $('nextLevelBtn').onclick = () => tryNavigate(() => { closeAllModals(); if (ENGINE.overlayState !== OVERLAY_NONE || ENGINE.activeSolverController) return; const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; loadLevel(ENGINE.levelIdx < levels.length - 1 ? ENGINE.levelIdx + 1 : 0); outEl.value = ''; });
        $('nextLevelModalBtn').onclick = () => { const levels = (typeof window.RAW_LEVELS !== 'undefined') ? window.RAW_LEVELS : FALLBACK_RAW_LEVELS; handleWinClose(() => { if (ENGINE.levelIdx < levels.length - 1) loadLevel(ENGINE.levelIdx + 1); }); };
        $('dismissWinModalBtn').onclick = () => handleWinClose(() => { setLogicState(IDLE); });
        
        $('guideBtn').onclick = () => { 
            const isVisible = !$('guideModal').classList.contains('hidden');
            closeAllModals();
            if (!isVisible) $('guideModal').classList.remove('hidden');
        };
        $('closeGuideX').onclick = () => $('guideModal').classList.add('hidden');
        $('megaSolverBtn').onclick = () => { closeAllModals(); MEGA.run(); };
        $('closeMegaModalBtn').onclick = () => { $('megaModal').classList.add('hidden'); if(ENGINE.activeSolverController) ENGINE.activeSolverController.abort(); };
        $('copyMegaDataBtn').onclick = () => { const el = $('megaOutput'); if (el.value) { el.select(); document.execCommand('copy'); } };
        
        const tModal = $('themeModal');
        $('openThemeModalBtn').onclick = () => { closeAllModals(); updateLayoutMode(); refreshThemeFooter(); tModal.classList.remove('hidden'); };
        $('closeThemeModalBtn').onclick = () => { tModal.classList.add('hidden'); closeEditor(); };
        $('dismissThemeModalBtn').onclick = () => { tModal.classList.add('hidden'); closeEditor(); };
        $('openThemeEditorBtn').onclick = () => { $('themeSelectView').classList.add('hidden'); $('themeEditView').classList.remove('hidden'); $('themeEditView').classList.add('flex'); renderThemeEditors(); };
        const closeEditor = () => { $('themeEditView').classList.add('hidden'); $('themeEditView').classList.remove('flex'); $('themeSelectView').classList.remove('hidden'); refreshThemeFooter(); };
        const refreshThemeFooter = () => {
            const editBtn = $('openThemeEditorBtn');
            const footer = $('themeSelectFooter');
            const dismissBtn = $('dismissThemeModalBtn');
            const canModify = ENGINE.isDevMode || ENGINE.mode === EDITOR;
            if (editBtn) editBtn.classList.toggle('hidden', !canModify);
            if (footer) footer.classList.toggle('justify-center', !canModify);
            if (footer) footer.classList.toggle('justify-between', canModify);
            if (dismissBtn) dismissBtn.classList.remove('hidden');
        };
        $('backToThemeSelectBtn').onclick = closeEditor;
        $('doneThemeEditBtn').onclick = closeEditor;
        $('devToggleBtn').onclick = () => { ENGINE.isDevMode = !ENGINE.isDevMode; updatePlayModeLayout(); showMessage(ENGINE.isDevMode ? "Dev Enabled" : "Player Enabled", "text-white font-black"); };
        document.querySelectorAll('.editor-input').forEach(el => el.addEventListener('input', () => { ENGINE.hinter.pathList = []; ENGINE.editor.validTrapSpots.clear(); ENGINE.editor.isModified = true; }));
        $('modeToggleBtn').onclick = () => { closeAllModals(); switchMode(EDITOR); };
        $('editModeToggleBtn').onclick = () => tryNavigate(() => { closeAllModals(); switchMode(PLAY); });
        
        $('editTrapSpotsBtn').onclick = async () => { 
            const isVisible = !$('editorHelpModal').classList.contains('hidden');
            if (isVisible) { $('editorHelpModal').classList.add('hidden'); return; }
            closeAllModals();
            if (ENGINE.activeSolverController) return; 
            stopHintAnimation();
            const l = ENGINE.editor.workingLevel; l.reqLen = parseInt($('editReqLen').value); l.reqInt = parseInt($('editReqInt').value); 
            ENGINE.activeSolverController = new AbortController(); 
            setOverlayState(SOLVER_RUNNING);
            const uiTimer = $('solverTimer'); const searchLabel = $('searchLabel'); 
            try { 
                const spots = await PathfinderSolver.findTrapSpots(l, { 
                    timeLimit: 8000, 
                    signal: ENGINE.activeSolverController.signal, 
                    onStateUpdate: (msg) => { searchLabel.innerText = msg; showMessage(msg, "text-white font-black"); }, 
                    onProgress: (elapsedMs) => { uiTimer.innerText = (elapsedMs / 1000).toFixed(1) + 's'; } 
                }); 
                ENGINE.editor.validTrapSpots = spots; 
                render();
                if (spots.size > 0) showMessage(`Found ${spots.size} spots.`, "text-white font-black"); 
                else showMessage("No spots found.", "text-white font-black"); 
                setOverlayState(OVERLAY_NONE);
            } catch (err) { 
                setOverlayState(OVERLAY_NONE);
                if (err.name !== 'AbortError') console.error(err); 
            } finally { 
                ENGINE.activeSolverController = null; 
            } 
        };
        document.querySelectorAll('.palette-item[data-type]').forEach(el => { el.addEventListener('pointerdown', (e) => { if(ENGINE.mode === EDITOR) { if (ENGINE.overlayState !== OVERLAY_NONE) return; ENGINE.editor.draggedFromGrid = false; ENGINE.editor.emptyClickCount = 0; if (ENGINE.editor.pendingPortal && el.dataset.type !== 'portal' && el.dataset.type !== 'eraser') { showMessage("Finish portal pair!", "text-white font-black"); return; } if (ENGINE.editor.selectedTool === el.dataset.type) { ENGINE.editor.selectedTool = null; el.classList.remove('selected'); } else { ENGINE.editor.selectedTool = el.dataset.type; ENGINE.editor.draggedObject = {type: el.dataset.type}; setLogicState(EDIT_DRAG); document.querySelectorAll('.palette-item.selected').forEach(x => x.classList.remove('selected')); el.classList.add('selected'); } ENGINE.editor.isPencilMode = false; updatePencilState(); } }); });
        $('editPencilBtn').onclick = () => { closeAllModals(); if (ENGINE.overlayState !== OVERLAY_NONE) return; ENGINE.editor.isPencilMode = !ENGINE.editor.isPencilMode; if (ENGINE.editor.isPencilMode) { ENGINE.editor.selectedTool = null; document.querySelectorAll('.palette-item.selected').forEach(x => x.classList.remove('selected')); } else { setLogicState(IDLE); } updatePencilState(); };
        
        const eraserBtn = $('editEraserBtn'); let eraserTimer = null, eraserFired = false;
        eraserBtn.addEventListener('pointerdown', (e) => { if (ENGINE.mode !== EDITOR) return; eraserTimer = setTimeout(() => { PathNavigator.clear(ENGINE); showMessage("Cleared", "text-white font-black"); eraserFired = true; }, 1500); });
        const handleEraserRelease = () => { if (eraserTimer) { clearTimeout(eraserTimer); if (!eraserFired) { if (ENGINE.path.length > 1) PathNavigator.truncateTo(ENGINE, ENGINE.path.length - 2); else PathNavigator.clear(ENGINE); } eraserTimer = null; eraserFired = false; } };
        eraserBtn.addEventListener('pointerup', handleEraserRelease); eraserBtn.addEventListener('pointerleave', handleEraserRelease);
        
        $('editUndoGridBtn').onclick = () => { closeAllModals(); restoreEditorState(); };
        $('editResetGrid').onclick = () => { closeAllModals(); saveEditorState(); const l = ENGINE.editor.workingLevel; Object.assign(l, {gateKeys: [], goalKey: -1, falseGoalKeys: new Set(), blockSet: new Set(), gooseSet: new Set(), mustPassKeys: [], mustCrossKeys: [], filterMap: new Map(), flippingFilterMap: new Map(), portalMap: new Map(), portalVisuals: []}); PathNavigator.clear(ENGINE); showMessage("Reset", "text-white font-black"); };
        $('editNewLevel').onclick = () => tryNavigate(() => {
            closeAllModals();
            ENGINE.editor.workingLevel = { grid: { w: 10, h: 10 }, reqLen: 0, reqInt: 0, goalKey: -1, falseGoalKeys: new Set(), gateKeys: [], blockSet: new Set(), gooseSet: new Set(), portalMap: new Map(), portalVisuals: [], filterMap: new Map(), flippingFilterMap: new Map(), mustPassKeys: [], mustCrossKeys: [], hints: [] };
            PathNavigator.clear(ENGINE); ENGINE.hinter.pathList = []; ENGINE.editor.pendingPortal = null; ENGINE.editor.validTrapSpots.clear(); $('levelTitle').innerText = "??"; $('editReqLen').value = 0; $('editReqInt').value = 0; ENGINE.editor.isPencilMode = false; updatePencilState(); ENGINE.editor.isModified = true; updateViewport(); showMessage("New Level Created", "text-white font-black");
        });
        $('editHelpBtn').onclick = () => { 
            const isVisible = !$('editorHelpModal').classList.contains('hidden');
            closeAllModals();
            if (!isVisible) $('editorHelpModal').classList.remove('hidden');
        };
        $('closeEditorHelpX').onclick = () => $('editorHelpModal').classList.add('hidden');
        $('editMegaSolver').onclick = () => { closeAllModals(); if (!ENGINE.editor.workingLevel) return; ENGINE.editor.workingLevel.reqLen = parseInt($('editReqLen').value); ENGINE.editor.workingLevel.reqInt = parseInt($('editReqInt').value); runGameSolver(); };
        $('editCopyMetrics').onclick = () => { closeAllModals(); if (ENGINE.path.length > 0) { const len = getRealLength(); $('editReqLen').value = len; $('editReqInt').value = ENGINE.intersections; ENGINE.editor.workingLevel.reqLen = len; ENGINE.editor.workingLevel.reqInt = ENGINE.intersections; showMessage("Metrics Set", "text-white font-black"); } };
        
        const originalLoop = loop;
        loop = function() {
            pollGamepadInput();
            originalLoop();
        };

        const loader = {
            progress: 0, hasLoaded: false, finish() { const overlay = $('loadingOverlay'); overlay.style.opacity = '0'; setTimeout(() => overlay.classList.add('hidden'), 500); populateThemes(); },
            triggerFallback() { if (this.hasLoaded) return; this.hasLoaded = true; window.RAW_LEVELS = FALLBACK_RAW_LEVELS; this.finish(); loadLevel(0); updatePlayModeLayout(); loop(); },
            start() {
                const loadThemes = new Promise(resolve => { 
                    const s = document.createElement('script'); 
                    s.src = "./themes.js"; 
                    s.onload = () => { 
                        if (window.THEMES_MORE) Object.assign(THEMES, window.THEMES_MORE);
                        ensureThemeLeaveColors();
                        resolve(); 
                    }; 
                    s.onerror = () => resolve(); 
                    document.head.appendChild(s); 
                });
                const loadLevels = new Promise((resolve, reject) => { 
                    const s = document.createElement('script'); 
                    s.src = "./levels.js"; 
                    s.onload = () => resolve(); 
                    s.onerror = () => reject(); 
                    document.head.appendChild(s); 
                });
                Promise.all([loadThemes, loadLevels]).then(() => { if (this.hasLoaded) return; this.hasLoaded = true; loadLevel(0); updatePlayModeLayout(); loop(); this.finish(); }).catch(() => this.triggerFallback());
                setTimeout(() => this.triggerFallback(), 5000);
            }
        };

        const startBoot = async () => {
            try {
                if (firebaseConfigRaw) await initAuth();
            } catch (e) {}
            syncProgress(auth?.currentUser);
            loader.start();
        };

        startBoot();
        ensureThemeLeaveColors();
        applyTheme('classic');
    };
</script>
</body>
</html>
